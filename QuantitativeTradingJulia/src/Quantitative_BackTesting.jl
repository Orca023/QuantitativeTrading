# module Quantitative_BackTesting
# Main.Quantitative_BackTesting
Base.push!(LOAD_PATH, ".")  # 增加當前目錄為導入擴展包時候的搜索路徑之一，用於導入當前目錄下自定義的模組（Julia代碼文檔 .jl）;
# Base.MainInclude.include(Base.filter(Base.contains(r".*\.jl$"), Base.Filesystem.readdir()));  # 在 Jupyterlab 中實現加載 Base.MainInclude.include("*.jl") 文檔，其中 r".*\.jl$" 為解析脚本文檔名的正則表達式;
# Base.MainInclude.include(popfirst!(ARGS));
# println(Base.PROGRAM_FILE)


#################################################################################;

# Title: Julia statistical algorithm server v20161211
# Explain: Julia market timing, Julia pick stock, Julia size position, Julia back testing, Julia indicators, Julia data cleaning
# Author: 趙健
# E-mail: 283640621@qq.com
# Telephont number: +86 18604537694
# E-mail: chinaorcaz@gmail.com
# Date: 歲在壬寅
# Operating system: Windows10 x86_64 Inter(R)-Core(TM)-m3-6Y30
# Interpreter: julia-1.9.3-win64.exe
# Interpreter: julia-1.10.3-linux-x86_64.tar.gz
# Operating system: google-pixel-2 android-11 termux-0.118 ubuntu-22.04-LTS-rootfs arm64-aarch64 MSM8998-Snapdragon835-Qualcomm®-Kryo™-280
# Interpreter: julia-1.10.3-linux-aarch64.tar.gz

# 使用説明：
# 使用 Base.MainInclude.include() 函數可導入本地 Julia 脚本文檔到當前位置執行;
# Base.MainInclude.include("/home/QuantitativeTrading/QuantitativeTradingJulia/Quantitative_BackTesting.jl");
# Base.MainInclude.include("C:/QuantitativeTrading/QuantitativeTradingJulia/Quantitative_BackTesting.jl");
# Base.MainInclude.include("./Quantitative_BackTesting.jl");

# 控制臺命令列運行指令：
# C:\> C:/QuantitativeTrading/Julia/Julia-1.9.3/bin/julia.exe -p 4 --project=C:/QuantitativeTrading/QuantitativeTradingJulia/ C:/QuantitativeTrading/QuantitativeTradingJulia/QuantitativeTradingServer.jl configFile=C:/QuantitativeTrading/config.txt webPath=C:/QuantitativeTrading/html/ host=::0 port=10001 key=username:password number_Worker_threads=1 isConcurrencyHierarchy=Tasks is_monitor=false time_sleep=0.02 monitor_dir=C:/QuantitativeTrading/Intermediary/ monitor_file=C:/QuantitativeTrading/Intermediary/intermediary_write_C.txt output_dir=C:/QuantitativeTrading/Intermediary/ output_file=C:/QuantitativeTrading/Intermediary/intermediary_write_Julia.txt temp_cache_IO_data_dir=C:/QuantitativeTrading/temp/
# root@localhost:~# /usr/julia/julia-1.10.3/bin/julia -p 4 --project=/home/QuantitativeTrading/QuantitativeTradingJulia/ /home/QuantitativeTrading/QuantitativeTradingJulia/QuantitativeTradingServer.jl configFile=/home/QuantitativeTrading/config.txt webPath=/home/QuantitativeTrading/html/ host=::0 port=10001 key=username:password number_Worker_threads=1 isConcurrencyHierarchy=Tasks is_monitor=false time_sleep=0.02 monitor_dir=/home/QuantitativeTrading/Intermediary/ monitor_file=/home/QuantitativeTrading/Intermediary/intermediary_write_C.txt output_dir=/home/QuantitativeTrading/Intermediary/ output_file=/home/QuantitativeTrading/Intermediary/intermediary_write_Julia.txt temp_cache_IO_data_dir=/home/QuantitativeTrading/temp/

#################################################################################;


using Statistics;  # 導入 Julia 的原生標準模組「Statistics」，用於數據統計計算;
using Dates;  # 導入 Julia 的原生標準模組「Dates」，用於處理時間和日期數據，也可以用全名 Main.Dates. 訪問模組内的方法（函數）;
using Distributed;  # 導入 Julia 的原生標準模組「Distributed」，用於提供并行化和分佈式功能;
# using Sockets;  # 導入 Julia 的原生標準模組「Sockets」，用於創建 TCP server 服務器;
# using Base64;  # 導入 Julia 的原生標準模組「Base64」，用於按照 Base64 方式編解碼字符串;
# using SharedArrays;

# Distributed.@everywhere using Dates, Distributed, Sockets, Base64;  # SharedArrays;  # 使用廣播關鍵字 Distributed.@everywhere 在所有子進程中加載指定模組或函數或變量;

# https://discourse.juliacn.com/t/topic/2969
# 如果想臨時更換pkg工具下載鏡像源，在julia解釋器環境命令行輸入命令：
# julia> ENV["JULIA_PKG_SERVER"]="https://mirrors.bfsu.edu.cn/julia/static"
# 或者：
# Windows Powershell: $env:JULIA_PKG_SERVER = 'https://pkg.julialang.org'
# Linux/macOS Bash: export JULIA_PKG_SERVER="https://pkg.julialang.org"
using Gadfly;  # 導入第三方擴展包「Gadfly」，用於繪圖，需要在控制臺先安裝第三方擴展包「Gadfly」：julia> using Pkg; Pkg.add("Gadfly") 成功之後才能使用;
using Cairo;  # 導入第三方擴展包「Cairo」，用於持久化保存圖片到硬盤文檔，需要在控制臺先安裝第三方擴展包「Cairo」：julia> using Pkg; Pkg.add("Cairo") 成功之後才能使用;
using Fontconfig;  # 導入第三方擴展包「Fontconfig」，用於持久化保存圖片到硬盤文檔，需要在控制臺先安裝第三方擴展包「Fontconfig」：julia> using Pkg; Pkg.add("Fontconfig") 成功之後才能使用;
# using Plots;  # 導入第三方擴展包「Plots」，用於繪圖，需要在控制臺先安裝第三方擴展包「Plots」：julia> using Pkg; Pkg.add("Plots") 成功之後才能使用;
# using DataFrames;  # 導入第三方擴展包「DataFrames」，需要在控制臺先安裝第三方擴展包「DataFrames」：julia> using Pkg; Pkg.add("DataFrames") 成功之後才能使用;
# # https://github.com/JuliaData/DataFrames.jl
# # https://dataframes.juliadata.org/stable/
# using JLD;  # 導入第三方擴展包「JLD」，用於操作 Julia 語言專有的硬盤「.jld」文檔數據，需要在控制臺先安裝第三方擴展包「JLD」：julia> using Pkg; Pkg.add("JLD") 成功之後才能使用;
# https://github.com/JuliaIO/JLD.jl
# using HDF5;
# # https://github.com/JuliaIO/HDF5.jl
# using JSON;  # 導入第三方擴展包「JSON」，用於轉換JSON字符串為字典 Base.Dict 對象，需要在控制臺先安裝第三方擴展包「JSON」：julia> using Pkg; Pkg.add("JSON") 成功之後才能使用;
# # https://github.com/JuliaIO/JSON.jl
# using CSV;  # 導入第三方擴展包「CSV」，用於操作「.csv」文檔，需要在控制臺先安裝第三方擴展包「CSV」：julia> using Pkg; Pkg.add("CSV") 成功之後才能使用;
# # https://github.com/JuliaData/CSV.jl
# # https://csv.juliadata.org/stable/
# using XLSX;  # 導入第三方擴展包「XLSX」，用於操作「.xlsx」文檔（Microsoft Office Excel），需要在控制臺先安裝第三方擴展包「XLSX」：julia> using Pkg; Pkg.add("XLSX") 成功之後才能使用;
# # https://github.com/felipenoris/XLSX.jl
# # https://felipenoris.github.io/XLSX.jl/stable/
# using Optim;  # 導入第三方擴展包「Optim」，用於通用形式優化問題求解（optimization），需要在控制臺先安裝第三方擴展包「Optim」：julia> using Pkg; Pkg.add("Optim") 成功之後才能使用;
# # https://julianlsolvers.github.io/Optim.jl/stable/
# # https://github.com/JuliaNLSolvers/Optim.jl
# using JuMP;  # 導入第三方擴展包「JuMP」，用於帶有約束條件的通用形式優化問題求解（optimization），需要在控制臺先安裝第三方擴展包「JuMP」：julia> using Pkg; Pkg.add("JuMP") 成功之後才能使用;
# using Gurobi;  # 導入第三方擴展包「Gurobi」，用於 JuMP 調用的求解器（underlying solver）做缐性、整數、二次、混合整數等問題優化，需要在控制臺先安裝第三方擴展包「Gurobi」：julia> using Pkg; Pkg.add("Gurobi") 成功之後才能使用;
# using Ipopt;  # 導入第三方擴展包「Ipopt」，用於 JuMP 調用的求解器（underlying solver）做非缐性問題優化，需要在控制臺先安裝第三方擴展包「Ipopt」：julia> using Pkg; Pkg.add("Ipopt") 成功之後才能使用;
# using Cbc;  # 導入第三方擴展包「Cbc」，用於 JuMP 調用的求解器（underlying solver）做整數、混合整數問題優化，需要在控制臺先安裝第三方擴展包「Cbc」：julia> using Pkg; Pkg.add("Cbc") 成功之後才能使用;
# using GLPK;  # 導入第三方擴展包「GLPK」，用於 JuMP 調用的求解器（underlying solver）做缐性問題優化，需要在控制臺先安裝第三方擴展包「GLPK」：julia> using Pkg; Pkg.add("GLPK") 成功之後才能使用;
# # https://jump.dev/
# # https://jump.dev/JuMP.jl/stable/
# # https://github.com/jump-dev/JuMP.jl
# using LsqFit;  # 導入第三方擴展包「LsqFit」，用於任意形式曲缐方程擬合（Curve Fitting），需要在控制臺先安裝第三方擴展包「LsqFit」：julia> using Pkg; Pkg.add("LsqFit") 成功之後才能使用;
# # https://julianlsolvers.github.io/LsqFit.jl/latest/
# # https://github.com/JuliaNLSolvers/LsqFit.jl
# using Interpolations;  # 導入第三方擴展包「Interpolations」，用於插值運算（Interpolation），需要在控制臺先安裝第三方擴展包「Interpolations」：julia> using Pkg; Pkg.add("Interpolations") 成功之後才能使用;
# # https://juliamath.github.io/Interpolations.jl/stable/
# # https://github.com/JuliaMath/Interpolations.jl/
# using DataInterpolations;  # 導入第三方擴展包「DataInterpolations」，用於一維（1 Dimension）插值運算（Interpolation），需要在控制臺先安裝第三方擴展包「DataInterpolations」：julia> using Pkg; Pkg.add("DataInterpolations") 成功之後才能使用;
# # https://github.com/SciML/DataInterpolations.jl
# using NLsolve;  # 導入第三方擴展包「NLsolve」，用於求解任意形式多元非缐性方程組，需要在控制臺先安裝第三方擴展包「NLsolve」：julia> using Pkg; Pkg.add("NLsolve") 成功之後才能使用;
# # https://github.com/JuliaNLSolvers/NLsolve.jl
# using Roots;  # 導入第三方擴展包「Roots」，用於求解任意形式一元非缐性方程，需要在控制臺先安裝第三方擴展包「Roots」：julia> using Pkg; Pkg.add("Roots") 成功之後才能使用;
# # https://juliamath.github.io/Roots.jl/stable
# # https://github.com/JuliaMath/Roots.jl
# using ForwardDiff;  # 導入第三方擴展包「ForwardDiff」，用於任意形式一元方程數值微分（自動微分）計算，需要在控制臺先安裝第三方擴展包「ForwardDiff」：julia> using Pkg; Pkg.add("ForwardDiff") 成功之後才能使用;
# # https://juliadiff.org/ForwardDiff.jl/stable/
# # https://github.com/JuliaDiff/ForwardDiff.jl
# using Calculus;  # 導入第三方擴展包「Calculus」，用於任意形式多元方程數值微分（自動微分）計算，需要在控制臺先安裝第三方擴展包「Calculus」：julia> using Pkg; Pkg.add("Calculus") 成功之後才能使用;
# # https://github.com/JuliaMath/Calculus.jl
# using Cubature;  # 導入第三方擴展包「Cubature」，用於任意形式多元方程數值積分（自動積分）計算，需要在控制臺先安裝第三方擴展包「Cubature」：julia> using Pkg; Pkg.add("Cubature") 成功之後才能使用;
# # https://github.com/JuliaMath/Cubature.jl
# using DifferentialEquations;  # 導入第三方擴展包「DifferentialEquations」，用於求解任意形式微分方程，需要在控制臺先安裝第三方擴展包「DifferentialEquations」：julia> using Pkg; Pkg.add("DifferentialEquations") 成功之後才能使用;
# # https://docs.sciml.ai/DiffEqDocs/stable/
# # https://github.com/SciML/DifferentialEquations.jl
# using Symbolics;  # 導入第三方擴展包「Symbolics」，用於符號計算，需要在控制臺先安裝第三方擴展包「Symbolics」：julia> using Pkg; Pkg.add("Symbolics") 成功之後才能使用;
# # https://symbolics.juliasymbolics.org/stable/
# # https://github.com/JuliaSymbolics/Symbolics.jl
# using SymPy;  # 導入第三方擴展包「SymPy」，用於符號計算，需要在控制臺先安裝第三方擴展包「SymPy」：julia> using Pkg; Pkg.add("SymPy") 成功之後才能使用;
# # https://jverzani.github.io/SymPyCore.jl/dev/
# # https://github.com/JuliaPy/SymPy.jl
# using TimeSeries;  # 導入第三方擴展包「TimeSeries」，用於連續型數據（continuous）的時間序列（Time Series）分析，需要在控制臺先安裝第三方擴展包「TimeSeries」：julia> using Pkg; Pkg.add("TimeSeries") 成功之後才能使用;
# # https://juliastats.org/TimeSeries.jl/latest/
# # https://github.com/JuliaStats/TimeSeries.jl
# using CountTimeSeries;  # 導入第三方擴展包「CountTimeSeries」，用於離散型數據（discrete）的時間序列（Time Series）分析，需要在控制臺先安裝第三方擴展包「CountTimeSeries」：julia> using Pkg; Pkg.add("CountTimeSeries") 成功之後才能使用;
# # https://github.com/ManuelStapper/CountTimeSeries.jl
# # https://github.com/ManuelStapper/CountTimeSeries.jl/blob/master/CountTimeSeries_documentation.pdf

Distributed.@everywhere using Statistics, Dates, Distributed, Gadfly, Cairo, Fontconfig;

# 使用 Base.MainInclude.include() 函數可導入本地 Julia 脚本文檔到當前位置執行;
# Base.MainInclude.include("./Statis_Descript.jl");
# Base.MainInclude.include(Base.Filesystem.joinpath(Base.@__DIR__, "Statis_Descript.jl"));
# Base.Filesystem.joinpath(Base.@__DIR__, "Statis_Descript.jl")
# Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "lib", "Statis_Descript.jl")
# Base.Filesystem.joinpath(Base.Filesystem.pwd(), "lib", "Statis_Descript.jl")

# 匯入自定義的日棒缐（K-Line）原始數據整理模組脚本文檔「./Quantitative_Data_Cleaning.jl」;
# Base.MainInclude.include("./Quantitative_Data_Cleaning.jl");

# 匯入自定義的量化交易指標計算模組脚本文檔「./Quantitative_Indicators.jl」;
Base.MainInclude.include("./Quantitative_Indicators.jl");
# return_Intuitive_Momentum = Intuitive_Momentum(
#     training_data["ticker_symbol"]["close_price"],  # ::Core.Array{Core.Union{Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1},
#     Core.Int64(3);  # 觀察收益率歷史向前推的交易日長度;
#     y_P_Positive = Core.nothing,  # ::Core.Float64 = Core.Float64(1.0),  # 增長率（正）的可能性（頻率）示意;
#     y_P_Negative = Core.nothing,  # ::Core.Float64 = Core.Float64(1.0),  # 衰退率（負）的可能性（頻率）示意;
#     weight = Core.nothing  # Core.Array{Core.Float64, 1}()  # [Core.Float64(Core.Int64(i) / Core.Int64(P1)) for i in 1:Core.Int64(P1)]  # ::Core.Array{Core.Any, 1} = Core.Array{Core.Float64, 1}()  # 每計增長率的權重（weight）值，距離當下時長的倒數（直覺推理有效性示意）;
# );
# println("closing price growth rate", return_Intuitive_Momentum);
# return_Intuitive_Momentum_KLine = Intuitive_Momentum_KLine(
#     Base.Dict{Core.String, Core.Any}(
#         "date_transaction" => training_data["ticker_symbol"]["date_transaction"],  # 交易日期;
#         "turnover_volume" => training_data["ticker_symbol"]["turnover_volume"],  # 成交量;
#         # "turnover_amount" => training_data["ticker_symbol"]["turnover_amount"],  # 成交總金額;
#         "opening_price" => training_data["ticker_symbol"]["opening_price"],  # 開盤成交價;
#         "close_price" => training_data["ticker_symbol"]["close_price"],  # 收盤成交價;
#         "low_price" => training_data["ticker_symbol"]["low_price"],  # 最低成交價;
#         "high_price" => training_data["ticker_symbol"]["high_price"],  # 最高成交價;
#         # "focus" => training_data["ticker_symbol"]["focus"],  # 當日成交價重心;
#         # "amplitude" => training_data["ticker_symbol"]["amplitude"],  # 當日成交價絕對振幅;
#         # "amplitude_rate" => training_data["ticker_symbol"]["amplitude_rate"],  # 當日成交價相對振幅（%）;
#         # "opening_price_Standardization" => training_data["ticker_symbol"]["opening_price_Standardization"],  # 日棒缐（K Line Daily）數據交易日首筆成交價（開盤價）標準化值;
#         # "closing_price_Standardization" => training_data["ticker_symbol"]["closing_price_Standardization"],  # 日棒缐（K Line Daily）數據交易日尾筆成交價（收盤價）標準化值;
#         # "low_price_Standardization" => training_data["ticker_symbol"]["low_price_Standardization"],  # 日棒缐（K Line Daily）數據交易日最低成交價標準化值;
#         # "high_price_Standardization" => training_data["ticker_symbol"]["high_price_Standardization"],  # 日棒缐（K Line Daily）數據交易日最高成交價標準化值;
#         "turnover_volume_growth_rate" => training_data["ticker_symbol"]["turnover_volume_growth_rate"],  # 成交量的成長率;
#         "opening_price_growth_rate" => training_data["ticker_symbol"]["opening_price_growth_rate"],  # 開盤價的成長率;
#         "closing_price_growth_rate" => training_data["ticker_symbol"]["closing_price_growth_rate"],  # 收盤價的成長率;
#         "closing_minus_opening_price_growth_rate" => training_data["ticker_symbol"]["closing_minus_opening_price_growth_rate"],  # 收盤價減開盤價的成長率;
#         "high_price_proportion" => training_data["ticker_symbol"]["high_price_proportion"],  # 收盤價和開盤價裏的最大值占最高價的比例;
#         "low_price_proportion" => training_data["ticker_symbol"]["low_price_proportion"],  # 最低價占收盤價和開盤價裏的最小值的比例;
#         # "turnover_rate" => training_data["ticker_symbol"]["turnover_rate"],  # 成交量換手率;
#         # "price_earnings" => training_data["ticker_symbol"]["price_earnings"],  # 每股收益（公司經營利潤率 ÷ 股本）;
#         # "book_value_per_share" => training_data["ticker_symbol"]["book_value_per_share"],  # 每股净值（公司净資產 ÷ 股本）;
#         # "capitalization" => training_data["ticker_symbol"]["capitalization"]  # 總市值;
#     ),
#     Core.Int64(3);  # 觀察收益率歷史向前推的交易日長度;
#     y_P_Positive = Core.nothing,  # ::Core.Float64 = Core.Float64(1.0),  # 增長率（正）的可能性（頻率）示意;
#     y_P_Negative = Core.nothing,  # ::Core.Float64 = Core.Float64(1.0),  # 衰退率（負）的可能性（頻率）示意;
#     weight = Core.nothing,  # [Core.Float64(Core.Int64(j) / Core.Int64(P1)) for j in 1:Core.Int64(P1)],
#     Intuitive_Momentum = Intuitive_Momentum
# );
# println("turnover volume growth rate", return_Intuitive_Momentum_KLine["P1_turnover_volume_growth_rate"]);
# println("opening price growth rate", return_Intuitive_Momentum_KLine["P1_opening_price_growth_rate"]);
# println("closing price growth rate", return_Intuitive_Momentum_KLine["P1_closing_price_growth_rate"]);
# println("closing minus opening price growth rate", return_Intuitive_Momentum_KLine["P1_closing_minus_opening_price_growth_rate"]);
# println("high price proportion", return_Intuitive_Momentum_KLine["P1_high_price_proportion"]);
# println("low price proportion", return_Intuitive_Momentum_KLine["P1_low_price_proportion"]);
# println("intuitive momentum indicator", return_Intuitive_Momentum_KLine["P1_Intuitive_Momentum"]);

# 匯入自定義的量化交易擇時模組脚本文檔「./Quantitative_MarketTiming.jl」;
Base.MainInclude.include("./Quantitative_MarketTiming.jl");
# return_MarketTiming = MarketTiming(
#     training_data = Base.Dict{Core.String, Core.Any}("ticker_symbol" => training_data["ticker_symbol"]),  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("date_transaction" => ::Core.Array{Dates.Date, 1}[Dates.Date("2024-01-02")], "turnover_volume" => ::Core.Array{Core.Int64, 1}[Core.Int64()], "opening_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "close_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "low_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "high_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()])),
#     testing_data = Base.Dict{Core.String, Core.Any}("ticker_symbol" => testing_data["ticker_symbol"]),  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("date_transaction" => ::Core.Array{Dates.Date, 1}[Dates.Date("2024-01-02")], "turnover_volume" => ::Core.Array{Core.Int64, 1}[Core.Int64()], "opening_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "close_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "low_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "high_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()])),
#     Pdata_0 = [Core.Int64(3), Core.Float64(+1.0), Core.Float64(-1.0), Core.Float64(0.0)],  # training_data["ticker_symbol"]["Pdata_0"],
#     # weight = Core.Array{Core.Float64, 1}(),  # training_data["ticker_symbol"]["weight"],  # [Core.Float64(1.0) for i in 1:Base.length(training_data)],
#     Plower = [-Base.Inf, -Base.Inf, -Base.Inf, -Base.Inf],  # training_data["ticker_symbol"]["Plower"],
#     Pupper = [+Base.Inf, +Base.Inf, +Base.Inf, +Base.Inf],  # training_data["ticker_symbol"]["Pupper"],
#     MarketTiming_fit_model = MarketTiming_fit_model,
#     Quantitative_Indicators_Function = Intuitive_Momentum_KLine,
#     investment_method = "Long_Position_and_Short_Selling"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
# );
# return_MarketTiming === Base.Dict{Core.String, Core.Any}(
#     Base.string(ticker_symbol) => Base.Dict{Core.String, Core.Any}(
#         "Coefficient" => coefficient_from_fit,  # 最優化計算之後得到的參數;
#         "y_profit" => y_profit,  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
#         "y_Long_Position_profit" => y_Long_Position_profit,  # 優化目標變量;
#         "y_Short_Selling_profit" => y_Short_Selling_profit,  # 優化目標變量;
#         "y_loss" => y_loss,  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
#         "y_Long_Position_loss" => y_Long_Position_loss,  # 優化目標變量;
#         "y_Short_Selling_loss" => y_Short_Selling_loss,  # 優化目標變量;
#         "profit_total" => y_total,  # 每兩次對衝交易利潤 × 頻率，纍加總計;
#         "Long_Position_profit_total" => y_total_Long_Position,  # 每兩次對衝交易利潤 × 頻率，纍加總計;
#         "Short_Selling_profit_total" => y_total_Short_Selling,  # 每兩次對衝交易利潤 × 頻率，纍加總計;
#         "profit_Positive" => y_Positive,  # 每兩次對衝交易收益纍加總計;
#         "Long_Position_profit_Positive" => y_Positive_Long_Position,  # 每兩次對衝交易收益纍加總計;
#         "Short_Selling_profit_Positive" => y_Positive_Short_Selling,  # 每兩次對衝交易收益纍加總計;
#         "profit_Positive_probability" => y_P_Positive,  # 每兩次對衝交易正利潤概率;
#         "Long_Position_profit_Positive_probability" => y_P_Positive_Long_Position,  # 每兩次對衝交易正利潤概率;
#         "Short_Selling_profit_Positive_probability" => y_P_Positive_Short_Selling,  # 每兩次對衝交易正利潤概率;
#         "profit_Negative" => y_Negative,  # 每兩次對衝交易損失纍加總計;
#         "Long_Position_profit_Negative" => y_Negative_Long_Position,  # 每兩次對衝交易損失纍加總計;
#         "Short_Selling_profit_Negative" => y_Negative_Short_Selling,  # 每兩次對衝交易損失纍加總計;
#         "profit_Negative_probability" => y_P_Negative,  # 每兩次對衝交易負利潤概率;
#         "Long_Position_profit_Negative_probability" => y_P_Negative_Long_Position,  # 每兩次對衝交易負利潤概率;
#         "Short_Selling_profit_Negative_probability" => y_P_Negative_Short_Selling,  # 每兩次對衝交易負利潤概率;
#         "Long_Position_profit_date_transaction" => y_A_Long_Position,  # 每兩次對衝交易利潤，向量;
#         "Short_Selling_profit_date_transaction" => y_A_Short_Selling,  # 每兩次對衝交易利潤，向量;
#         "maximum_drawdown" => y_maximum_drawdown,  # 兩次對衝交易之間的最大回撤值，取極值統計;
#         "maximum_drawdown_Long_Position" => y_maximum_drawdown_Long_Position,  # 兩次對衝交易之間的最大回撤值，取極值統計;
#         "maximum_drawdown_Short_Selling" => y_maximum_drawdown_Short_Selling,  # 兩次對衝交易之間的最大回撤值，取極值統計;
#         "Long_Position_drawdown_date_transaction" => y_H_Long_Position,  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
#         "Short_Selling_drawdown_date_transaction" => y_H_Short_Selling,  # 向量，記錄做空模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
#         "average_price_amplitude_date_transaction" => y_amplitude,  # 兩兩次對衝交易日成交價振幅平方和，均值;
#         "Long_Position_average_price_amplitude_date_transaction" => y_amplitude_Long_Position,  # 兩兩次對衝交易日成交價振幅平方和，均值;
#         "Short_Selling_average_price_amplitude_date_transaction" => y_amplitude_Short_Selling,  # 兩兩次對衝交易日成交價振幅平方和，均值;
#         "Long_Position_price_amplitude_date_transaction" => y_D_Long_Position,  # 兩次對衝交易日成交價振幅平方和，向量;
#         "Short_Selling_price_amplitude_date_transaction" => y_D_Short_Selling,  # 兩次對衝交易日成交價振幅平方和，向量;
#         "average_volume_turnover_date_transaction" => y_turnover,  # 兩次對衝交易日成交量（換手率）均值;
#         "Long_Position_average_volume_turnover_date_transaction" => y_turnover_Long_Position,  # 兩次對衝交易日成交量（換手率）均值;
#         "Short_Selling_average_volume_turnover_date_transaction" => y_turnover_Short_Selling,  # 兩次對衝交易日成交量（換手率）均值;
#         "Long_Position_volume_turnover_date_transaction" => y_E_Long_Position,  # 兩次對衝交易日成交量（換手率）向量;
#         "Short_Selling_volume_turnover_date_transaction" => y_E_Short_Selling,  # 兩次對衝交易日成交量（換手率）向量;
#         "average_date_transaction_between" => y_date_transaction_between,  # 兩次對衝交易間隔日長，均值;
#         "Long_Position_average_date_transaction_between" => y_date_transaction_between_Long_Position,  # 兩次對衝交易間隔日長，均值;
#         "Short_Selling_average_date_transaction_between" => y_date_transaction_between_Short_Selling,  # 兩次對衝交易間隔日長，均值;
#         "Long_Position_date_transaction_between" => y_C_Long_Position,  # 兩次對衝交易間隔日長，向量;
#         "Short_Selling_date_transaction_between" => y_C_Short_Selling,  # 兩次對衝交易間隔日長，向量;
#         "Long_Position_date_transaction" => y_F_Long_Position,  # 按規則執行交易的日期，向量;
#         "Short_Selling_date_transaction" => y_F_Short_Selling,  # 按規則執行交易的日期，向量;
#         "P1_Array" => P1_Array,  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
#         "revenue_and_expenditure_records_date_transaction" => y_G,  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
#         "weight_MarketTiming" => weight_MarketTiming_Dict  # 擇時權重，每兩次對衝交易的盈利概率占比;
#     )
# );
# println("optimization - coefficient : ", return_MarketTiming["ticker_symbol"]["Coefficient"]);  # 最優化計算之後得到的參數;
# println("optimization - coefficient StandardDeviation : ", return_MarketTiming["ticker_symbol"]["Coefficient-StandardDeviation"]);  # 擬合得到的參數解的標準差;
# println("optimization - coefficient Confidence Lower 95% : ", return_MarketTiming["ticker_symbol"]["Coefficient-Confidence-Lower-95%"]);  # 擬合得到的參數解的區間估計下限;
# println("optimization - coefficient Confidence Upper 95% : ", return_MarketTiming["ticker_symbol"]["Coefficient-Confidence-Upper-95%"]);  # 擬合得到的參數解的區間估計上限;
# println("y - fit : ", return_MarketTiming["ticker_symbol"]["Yfit"]);  # 擬合 y 值;
# println("y - fit Uncertainty Lower : ", return_MarketTiming["ticker_symbol"]["Yfit-Uncertainty-Lower"]);  # 擬合的應變量 Yvals 誤差下限;
# println("y - fit Uncertainty Upper : ", return_MarketTiming["ticker_symbol"]["Yfit-Uncertainty-Upper"]);  # 擬合的應變量 Yvals 誤差上限;
# println("residual : ", return_MarketTiming["ticker_symbol"]["Residual"]);  # 擬合殘差;
# println("optimization - y_profit : ", return_MarketTiming["ticker_symbol"]["y_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
# println("Long Position optimization - y_profit : ", return_MarketTiming["ticker_symbol"]["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
# println("Short Selling optimization - y_profit : ", return_MarketTiming["ticker_symbol"]["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
# println("optimization - y_loss : ", return_MarketTiming["ticker_symbol"]["y_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
# println("Long Position optimization - y_loss : ", return_MarketTiming["ticker_symbol"]["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
# println("Short Selling optimization - y_loss : ", return_MarketTiming["ticker_symbol"]["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
# println("profit total per share : ", return_MarketTiming["ticker_symbol"]["profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# println("Long Position profit total per share : ", return_MarketTiming["ticker_symbol"]["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# println("Short Selling profit total per share : ", return_MarketTiming["ticker_symbol"]["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# println("profit Positive : ", return_MarketTiming["ticker_symbol"]["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# println("Long Position profit Positive : ", return_MarketTiming["ticker_symbol"]["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# println("Short Selling_profit Positive : ", return_MarketTiming["ticker_symbol"]["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# println("profit Positive probability : ", return_MarketTiming["ticker_symbol"]["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# println("Long Position profit Positive probability : ", return_MarketTiming["ticker_symbol"]["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# println("Short Selling profit Positive probability : ", return_MarketTiming["ticker_symbol"]["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# println("profit Negative : ", return_MarketTiming["ticker_symbol"]["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# println("Long Position profit Negative : ", return_MarketTiming["ticker_symbol"]["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# println("Short Selling profit Negative : ", return_MarketTiming["ticker_symbol"]["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# println("profit Negative probability : ", return_MarketTiming["ticker_symbol"]["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# println("Long Position profit Negative probability : ", return_MarketTiming["ticker_symbol"]["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# println("Short Selling profit Negative probability : ", return_MarketTiming["ticker_symbol"]["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# println("maximum_drawdown : ", return_MarketTiming["ticker_symbol"]["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# println("maximum_drawdown_Long_Position : ", return_MarketTiming["ticker_symbol"]["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# println("maximum_drawdown_Short_Selling : ", return_MarketTiming["ticker_symbol"]["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# println("Long_Position_drawdown_date_transaction : ", return_MarketTiming["ticker_symbol"]["Long_Position_drawdown_date_transaction"]);  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
# println("Short_Selling_drawdown_date_transaction : ", return_MarketTiming["ticker_symbol"]["Short_Selling_drawdown_date_transaction"]);  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
# println("average price amplitude date transaction : ", return_MarketTiming["ticker_symbol"]["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# println("Long Position average price amplitude date transaction : ", return_MarketTiming["ticker_symbol"]["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# println("Short Selling average price amplitude date transaction : ", return_MarketTiming["ticker_symbol"]["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# println("average volume turnover date transaction : ", return_MarketTiming["ticker_symbol"]["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# println("Long Position average volume turnover date transaction : ", return_MarketTiming["ticker_symbol"]["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# println("Short Selling average volume turnover date transaction : ", return_MarketTiming["ticker_symbol"]["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# println("average date transaction between : ", return_MarketTiming["ticker_symbol"]["average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# println("Long Position average date transaction between : ", return_MarketTiming["ticker_symbol"]["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# println("Short Selling average date transaction between : ", return_MarketTiming["ticker_symbol"]["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# println("number Long Position date transaction : ", Base.length(return_MarketTiming["ticker_symbol"]["Long_Position_date_transaction"]));
# println("number Short Selling date transaction : ", Base.length(return_MarketTiming["ticker_symbol"]["Short_Selling_date_transaction"]));
# println("weight MarketTiming : ", return_MarketTiming["ticker_symbol"]["weight_MarketTiming"]);  # 擇時權重，每兩次對衝交易的盈利概率占比;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
# println(return_MarketTiming["ticker_symbol"]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
# println(return_MarketTiming["ticker_symbol"]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
# println(return_MarketTiming["ticker_symbol"]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
# println(return_MarketTiming["ticker_symbol"]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
# # Gadfly.hstack(return_MarketTiming["ticker_symbol"]["Curve-fit-image"], return_MarketTiming["ticker_symbol"]["Residual-image"]);
# # Gadfly.title(Gadfly.hstack(return_MarketTiming["ticker_symbol"]["Curve-fit-image"], return_MarketTiming["ticker_symbol"]["Residual-image"]), "market timing model optimization");
# # Gadfly.vstack(Gadfly.hstack(return_MarketTiming["ticker_symbol"]["Curve-fit-image"]), Gadfly.hstack(return_MarketTiming["ticker_symbol"]["Residual-image"]));
# # Gadfly.title(Gadfly.vstack(Gadfly.hstack(return_MarketTiming["ticker_symbol"]["Curve-fit-image"]), Gadfly.hstack(return_MarketTiming["ticker_symbol"]["Residual-image"])), "market timing model optimization");
# # Gadfly.hstack(return_MarketTiming["Curve-fit-image"], return_MarketTiming["Residual-image"]);
# # Gadfly.title(Gadfly.hstack(return_MarketTiming["Curve-fit-image"], return_MarketTiming["Residual-image"]), "market timing model optimization");
# Gadfly.vstack(Gadfly.hstack(return_MarketTiming["Curve-fit-image"]), Gadfly.hstack(return_MarketTiming["Residual-image"]));
# Gadfly.title(Gadfly.vstack(Gadfly.hstack(return_MarketTiming["Curve-fit-image"]), Gadfly.hstack(return_MarketTiming["Residual-image"])), "market timing model optimization");
# return_MarketTiming_fit_model = MarketTiming_fit_model(
#     Base.Dict{Core.String, Core.Any}("ticker_symbol" => training_data["ticker_symbol"]),  # training_data,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("date_transaction" => ::Core.Array{Dates.Date, 1}[Dates.Date("2024-01-02")], "turnover_volume" => ::Core.Array{Core.Int64, 1}[Core.Int64()], "opening_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "close_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "low_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "high_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()])),
#     return_MarketTiming["ticker_symbol"]["Coefficient"][1],  # Core.Int64(3),  # P1,  # 觀察收益率歷史向前推的交易日長度;
#     return_MarketTiming["ticker_symbol"]["Coefficient"][2],  # Core.Float64(+0.1),  # P2  # 買入閾值;
#     return_MarketTiming["ticker_symbol"]["Coefficient"][3],  # Core.Float64(-0.1),  # P3  # 賣出閾值;
#     return_MarketTiming["ticker_symbol"]["Coefficient"][4],  # Core.Float64(0.0),  # P4  # risk threshold drawdown loss; # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
#     Intuitive_Momentum_KLine,
#     "Long_Position_and_Short_Selling"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
# );
# return_MarketTiming_fit_model === Base.Dict{Core.String, Core.Any}(
#     "ticker_symbol" => Base.Dict{Core.String, Core.Any}(
#         "y_profit" => y_profit,  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
#         "y_Long_Position_profit" => y_Long_Position_profit,  # 優化目標變量;
#         "y_Short_Selling_profit" => y_Short_Selling_profit,  # 優化目標變量;
#         "y_loss" => y_loss,  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
#         "y_Long_Position_loss" => y_Long_Position_loss,  # 優化目標變量;
#         "y_Short_Selling_loss" => y_Short_Selling_loss,  # 優化目標變量;
#         "profit_total" => y_total,  # 每兩次對衝交易利潤 × 頻率，纍加總計;
#         "Long_Position_profit_total" => y_total_Long_Position,  # 每兩次對衝交易利潤 × 頻率，纍加總計;
#         "Short_Selling_profit_total" => y_total_Short_Selling,  # 每兩次對衝交易利潤 × 頻率，纍加總計;
#         "profit_Positive" => y_Positive,  # 每兩次對衝交易收益纍加總計;
#         "Long_Position_profit_Positive" => y_Positive_Long_Position,  # 每兩次對衝交易收益纍加總計;
#         "Short_Selling_profit_Positive" => y_Positive_Short_Selling,  # 每兩次對衝交易收益纍加總計;
#         "profit_Positive_probability" => y_P_Positive,  # 每兩次對衝交易正利潤概率;
#         "Long_Position_profit_Positive_probability" => y_P_Positive_Long_Position,  # 每兩次對衝交易正利潤概率;
#         "Short_Selling_profit_Positive_probability" => y_P_Positive_Short_Selling,  # 每兩次對衝交易正利潤概率;
#         "profit_Negative" => y_Negative,  # 每兩次對衝交易損失纍加總計;
#         "Long_Position_profit_Negative" => y_Negative_Long_Position,  # 每兩次對衝交易損失纍加總計;
#         "Short_Selling_profit_Negative" => y_Negative_Short_Selling,  # 每兩次對衝交易損失纍加總計;
#         "profit_Negative_probability" => y_P_Negative,  # 每兩次對衝交易負利潤概率;
#         "Long_Position_profit_Negative_probability" => y_P_Negative_Long_Position,  # 每兩次對衝交易負利潤概率;
#         "Short_Selling_profit_Negative_probability" => y_P_Negative_Short_Selling,  # 每兩次對衝交易負利潤概率;
#         "Long_Position_profit_date_transaction" => y_A_Long_Position,  # 每兩次對衝交易利潤，向量;
#         "Short_Selling_profit_date_transaction" => y_A_Short_Selling,  # 每兩次對衝交易利潤，向量;
#         "maximum_drawdown" => y_maximum_drawdown,  # 兩次對衝交易之間的最大回撤值，取極值統計;
#         "maximum_drawdown_Long_Position" => y_maximum_drawdown_Long_Position,  # 兩次對衝交易之間的最大回撤值，取極值統計;
#         "maximum_drawdown_Short_Selling" => y_maximum_drawdown_Short_Selling,  # 兩次對衝交易之間的最大回撤值，取極值統計;
#         "Long_Position_drawdown_date_transaction" => y_H_Long_Position,  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
#         "Short_Selling_drawdown_date_transaction" => y_H_Short_Selling,  # 向量，記錄做空模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
#         "average_price_amplitude_date_transaction" => y_amplitude,  # 兩兩次對衝交易日成交價振幅平方和，均值;
#         "Long_Position_average_price_amplitude_date_transaction" => y_amplitude_Long_Position,  # 兩兩次對衝交易日成交價振幅平方和，均值;
#         "Short_Selling_average_price_amplitude_date_transaction" => y_amplitude_Short_Selling,  # 兩兩次對衝交易日成交價振幅平方和，均值;
#         "Long_Position_price_amplitude_date_transaction" => y_D_Long_Position,  # 兩次對衝交易日成交價振幅平方和，向量;
#         "Short_Selling_price_amplitude_date_transaction" => y_D_Short_Selling,  # 兩次對衝交易日成交價振幅平方和，向量;
#         "average_volume_turnover_date_transaction" => y_turnover,  # 兩次對衝交易日成交量（換手率）均值;
#         "Long_Position_average_volume_turnover_date_transaction" => y_turnover_Long_Position,  # 兩次對衝交易日成交量（換手率）均值;
#         "Short_Selling_average_volume_turnover_date_transaction" => y_turnover_Short_Selling,  # 兩次對衝交易日成交量（換手率）均值;
#         "Long_Position_volume_turnover_date_transaction" => y_E_Long_Position,  # 兩次對衝交易日成交量（換手率）向量;
#         "Short_Selling_volume_turnover_date_transaction" => y_E_Short_Selling,  # 兩次對衝交易日成交量（換手率）向量;
#         "average_date_transaction_between" => y_date_transaction_between,  # 兩次對衝交易間隔日長，均值;
#         "Long_Position_average_date_transaction_between" => y_date_transaction_between_Long_Position,  # 兩次對衝交易間隔日長，均值;
#         "Short_Selling_average_date_transaction_between" => y_date_transaction_between_Short_Selling,  # 兩次對衝交易間隔日長，均值;
#         "Long_Position_date_transaction_between" => y_C_Long_Position,  # 兩次對衝交易間隔日長，向量;
#         "Short_Selling_date_transaction_between" => y_C_Short_Selling,  # 兩次對衝交易間隔日長，向量;
#         "Long_Position_date_transaction" => y_F_Long_Position,  # 按規則執行交易的日期，向量;
#         "Short_Selling_date_transaction" => y_F_Short_Selling,  # 按規則執行交易的日期，向量;
#         "P1_Array" => P1_Array,  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
#         "revenue_and_expenditure_records_date_transaction" => y_G  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
#     )
# );
# println("y_profit = ", return_MarketTiming_fit_model["002611"]["y_profit"]);  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
# println("y_Long_Position_profit = ", return_MarketTiming_fit_model["002611"]["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
# println("y_Short_Selling_profit = ", return_MarketTiming_fit_model["002611"]["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
# println("y_loss = ", return_MarketTiming_fit_model["002611"]["y_loss"]);  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
# println("y_Long_Position_loss = ", return_MarketTiming_fit_model["002611"]["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
# println("y_Short_Selling_loss = ", return_MarketTiming_fit_model["002611"]["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
# println("profit_total = ", return_MarketTiming_fit_model["ticker_symbol"]["profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
# println("Long_Position_profit_total = ", return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
# println("Short_Selling_profit_total = ", return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
# println("profit_Positive = ", return_MarketTiming_fit_model["ticker_symbol"]["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# println("Long_Position_profit_Positive = ", return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# println("Short_Selling_profit_Positive = ", return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# println("profit_Positive_probability = ", return_MarketTiming_fit_model["ticker_symbol"]["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# println("Long_Position_profit_Positive_probability = ", return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# println("Short_Selling_profit_Positive_probability = ", return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# println("profit_Negative = ", return_MarketTiming_fit_model["ticker_symbol"]["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# println("Long_Position_profit_Negative = ", return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# println("Short_Selling_profit_Negative = ", return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# println("profit_Negative_probability = ", return_MarketTiming_fit_model["ticker_symbol"]["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# println("Long_Position_profit_Negative_probability = ", return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# println("Short_Selling_profit_Negative_probability = ", return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
# println("maximum_drawdown = ", return_MarketTiming_fit_model["ticker_symbol"]["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# println("maximum_drawdown_Long_Position = ", return_MarketTiming_fit_model["ticker_symbol"]["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# println("maximum_drawdown_Short_Selling = ", return_MarketTiming_fit_model["ticker_symbol"]["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_drawdown_date_transaction"]);  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_drawdown_date_transaction"]);  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
# println("average_price_amplitude_date_transaction = ", return_MarketTiming_fit_model["ticker_symbol"]["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# println("Long_Position_average_price_amplitude_date_transaction = ", return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# println("Short_Selling_average_price_amplitude_date_transaction = ", return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
# println("average_volume_turnover_date_transaction = ", return_MarketTiming_fit_model["ticker_symbol"]["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# println("Long_Position_average_volume_turnover_date_transaction = ", return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# println("Short_Selling_average_volume_turnover_date_transaction = ", return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
# println("average_date_transaction_between = ", return_MarketTiming_fit_model["ticker_symbol"]["average_date_transaction_between"]);  # 兩次交易間隔日長，均值;
# println("Long_Position_average_date_transaction_between = ", return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# println("Short_Selling_average_date_transaction_between = ", return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# println("weight_MarketTiming = ", return_MarketTiming_fit_model["ticker_symbol"]["weight_MarketTiming"]);  # 擇時權重，每兩次對衝交易的盈利概率占比;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
# println(return_MarketTiming_fit_model["ticker_symbol"]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
# println(return_MarketTiming_fit_model["ticker_symbol"]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
# println(return_MarketTiming_fit_model["ticker_symbol"]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;

# 匯入自定義的量化交易選股模組脚本文檔「./Quantitative_PickStock.jl」;
Base.MainInclude.include("./Quantitative_PickStock.jl");
# return_PickStock = PickStock(
#     training_data = training_data,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("date_transaction" => ::Core.Array{Dates.Date, 1}[Dates.Date("2024-01-02")], "turnover_volume" => ::Core.Array{Core.Int64, 1}[Core.Int64()], "opening_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "close_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "low_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "high_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()])),
#     testing_data = testing_data,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("date_transaction" => ::Core.Array{Dates.Date, 1}[Dates.Date("2024-01-02")], "turnover_volume" => ::Core.Array{Core.Int64, 1}[Core.Int64()], "opening_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "close_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "low_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "high_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()])),
#     Pdata_0 = [Core.Int64(3), Core.Int64(5)],  # training_data["Pdata_0"],
#     # weight = Core.Array{Core.Float64, 1}(),  # training_data["weight"],  # [Core.Float64(1.0) for i in 1:Base.length(training_data)],
#     Plower = [-Base.Inf, -Base.Inf],  # training_data["Plower"],
#     Pupper = [+Base.Inf, +Base.Inf],  # training_data["Pupper"],
#     MarketTiming_Parameter = MarketTiming_Parameter,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Array{Core.Union{Core.Int64, Core.Float64}, 1}[Core.Int64(), Core.Float64(), Core.Float64(), Core.Float64()], "Short_Selling" => ::Core.Array{Core.Union{Core.Int64, Core.Float64}, 1}[Core.Int64(), Core.Float64(), Core.Float64(), Core.Float64()])),
#     PickStock_fit_model = PickStock_fit_model,
#     MarketTiming = MarketTiming,
#     MarketTiming_fit_model = MarketTiming_fit_model,
#     Quantitative_Indicators_Function = Intuitive_Momentum_KLine,
#     investment_method = "Long_Position_and_Short_Selling"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
# );
# println("optimization - coefficient : ", return_PickStock["Coefficient"]);  # 最優化計算之後得到的參數;
# println("optimization - coefficient StandardDeviation : ", return_PickStock["Coefficient-StandardDeviation"]);  # 擬合得到的參數解的標準差;
# println("optimization - coefficient Confidence Lower 95% : ", return_PickStock["Coefficient-Confidence-Lower-95%"]);  # 擬合得到的參數解的區間估計下限;
# println("optimization - coefficient Confidence Upper 95% : ", return_PickStock["Coefficient-Confidence-Upper-95%"]);  # 擬合得到的參數解的區間估計上限;
# println("y - fit : ", return_PickStock["Yfit"]);  # 擬合 y 值;
# println("y - fit Uncertainty Lower : ", return_PickStock["Yfit-Uncertainty-Lower"]);  # 擬合的應變量 Yvals 誤差下限;
# println("y - fit Uncertainty Upper : ", return_PickStock["Yfit-Uncertainty-Upper"]);  # 擬合的應變量 Yvals 誤差上限;
# println("residual : ", return_PickStock["Residual"]);  # 擬合殘差;
# println("optimization - y_profit : ", return_PickStock["y_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
# println("Long Position optimization - y_profit : ", return_PickStock["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
# println("Short Selling optimization - y_profit : ", return_PickStock["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
# println("optimization - y_loss : ", return_PickStock["y_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
# println("Long Position optimization - y_loss : ", return_PickStock["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
# println("Short Selling optimization - y_loss : ", return_PickStock["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
# println("maximum_drawdown : ", return_PickStock["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# println("maximum_drawdown_Long_Position : ", return_PickStock["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# println("maximum_drawdown_Short_Selling : ", return_PickStock["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# println("profit total per share : ", return_PickStock["profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# println("Long Position profit total per share : ", return_PickStock["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# println("Short Selling profit total per share : ", return_PickStock["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# println("profit Positive : ", return_PickStock["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# println("Long Position profit Positive : ", return_PickStock["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# println("Short Selling_profit Positive : ", return_PickStock["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# println("profit Positive probability : ", return_PickStock["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# println("Long Position profit Positive probability : ", return_PickStock["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# println("Short Selling profit Positive probability : ", return_PickStock["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# println("profit Negative : ", return_PickStock["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# println("Long Position profit Negative : ", return_PickStock["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# println("Short Selling profit Negative : ", return_PickStock["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# println("profit Negative probability : ", return_PickStock["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# println("Long Position profit Negative probability : ", return_PickStock["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# println("Short Selling profit Negative probability : ", return_PickStock["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# println("average price amplitude date transaction : ", return_PickStock["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# println("Long Position average price amplitude date transaction : ", return_PickStock["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# println("Short Selling average price amplitude date transaction : ", return_PickStock["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# println("average volume turnover date transaction : ", return_PickStock["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# println("Long Position average volume turnover date transaction : ", return_PickStock["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# println("Short Selling average volume turnover date transaction : ", return_PickStock["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# println("average date transaction between : ", return_PickStock["average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# println("Long Position average date transaction between : ", return_PickStock["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# println("Short Selling average date transaction between : ", return_PickStock["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# println("number PickStock transaction : ", return_PickStock["number_PickStock_transaction"]);  # 交易過股票的總隻數，函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
# println("weight_PickStock : ", return_PickStock["weight_PickStock"]);  # 選股權重，每隻股票的盈利概率占比;
# println("pick stock sort ticker symbol : ", return_PickStock["PickStock_sort"]["ticker_symbol"]);  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;
# println("pick stock sort score : ", return_PickStock["PickStock_sort"]["score"]);  # 依照選股規則排序篩選出的股票得分值存儲數組;
# println(return_PickStock["PickStock_transaction_sequence"]);  # 記錄按規則篩選股票按照擇時規則交易信息的序列字典（Dict）;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]);  # 記錄按規則篩選股票按照擇時規則交易信息的序列字典（Dict）;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
# println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
# println("test profit estimate : ", return_PickStock["test_profit"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# println("test odds ratio estimate : ", return_PickStock["test_odds_ratio"]);
# println("test date transaction between : ", return_PickStock["test_date_transaction_between"]);
# # println(return_PickStock["testData"]);;  # 傳入測試數據集的計算結果;
# println("test profit total per share : ", return_PickStock["testData"]["profit_total"]);
# println("test Long Position profit total per share : ", return_PickStock["testData"]["Long_Position_profit_total"]);
# println("test Short Selling profit total per share : ", return_PickStock["testData"]["Short_Selling_profit_total"]);
# println("test profit positive per share : ", return_PickStock["testData"]["profit_Positive"]);
# println("test Long Position profit positive per share : ", return_PickStock["testData"]["Long_Position_profit_Positive"]);
# println("test Short Selling profit positive per share : ", return_PickStock["testData"]["Short_Selling_profit_Positive"]);
# println("test profit positive probability : ", return_PickStock["testData"]["profit_Positive_probability"]);
# println("test Long Position profit positive probability : ", return_PickStock["testData"]["Long_Position_profit_Positive_probability"]);
# println("test Short Selling profit positive probability : ", return_PickStock["testData"]["Short_Selling_profit_Positive_probability"]);
# println("test profit negative per share : ", return_PickStock["testData"]["profit_Negative"]);
# println("test Long Position profit negative per share : ", return_PickStock["testData"]["Long_Position_profit_Negative"]);
# println("test Short Selling profit negative per share : ", return_PickStock["testData"]["Short_Selling_profit_Negative"]);
# println("test profit negative probability : ", return_PickStock["testData"]["profit_Negative_probability"]);
# println("test Long Position profit negative probability : ", return_PickStock["testData"]["Long_Position_profit_Negative_probability"]);
# println("test Short Selling profit negative probability : ", return_PickStock["testData"]["Short_Selling_profit_Negative_probability"]);
# println("test average date transaction between : ", return_PickStock["testData"]["average_date_transaction_between"]);
# println("test Long Position average date transaction between : ", return_PickStock["testData"]["Long_Position_average_date_transaction_between"]);
# println("test Short Selling average date transaction between : ", return_PickStock["testData"]["Short_Selling_average_date_transaction_between"]);
# println("test number_PickStock_transaction : ", return_PickStock["testData"]["number_PickStock_transaction"]);  # 交易過股票的總隻數;
# println("test weight PickStock : ", return_PickStock["testData"]["weight_PickStock"]);  # 選股權重，每隻股票的盈利概率占比;
# # println(return_PickStock["testData"]["PickStock_transaction_sequence"]["002611"]["P1_Array"]);
# # println(return_PickStock["testData"]["PickStock_transaction_sequence"]["002611"]["Long_Position_date_transaction"]);
# # println(return_PickStock["testData"]["PickStock_transaction_sequence"]["002611"]["Short_Selling_date_transaction"]);
# # println(return_PickStock["testData"]["PickStock_transaction_sequence"]["002611"]);
# # Gadfly.hstack(return_PickStock["002611"]["Curve-fit-image"], return_PickStock["002611"]["Residual-image"]);
# # Gadfly.title(Gadfly.hstack(return_PickStock["002611"]["Curve-fit-image"], return_PickStock["002611"]["Residual-image"]), "pick stock model optimization");
# # Gadfly.vstack(Gadfly.hstack(return_PickStock["002611"]["Curve-fit-image"]), Gadfly.hstack(return_PickStock["002611"]["Residual-image"]));
# # Gadfly.title(Gadfly.vstack(Gadfly.hstack(return_PickStock["002611"]["Curve-fit-image"]), Gadfly.hstack(return_PickStock["002611"]["Residual-image"])), "pick stock model optimization");
# # Gadfly.hstack(return_PickStock["Curve-fit-image"], return_PickStock["Residual-image"]);
# # Gadfly.title(Gadfly.hstack(return_PickStock["Curve-fit-image"], return_PickStock["Residual-image"]), "pick stock model optimization");
# Gadfly.vstack(Gadfly.hstack(return_PickStock["Curve-fit-image"]), Gadfly.hstack(return_PickStock["Residual-image"]));
# Gadfly.title(Gadfly.vstack(Gadfly.hstack(return_PickStock["Curve-fit-image"]), Gadfly.hstack(return_PickStock["Residual-image"])), "pick stock model optimization");
# return_PickStock_fit_model = PickStock_fit_model(
#     training_data,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("date_transaction" => ::Core.Array{Dates.Date, 1}[Dates.Date("2024-01-02")], "turnover_volume" => ::Core.Array{Core.Int64, 1}[Core.Int64()], "opening_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "close_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "low_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "high_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()])),
#     return_PickStock["Coefficient"][1],  # Core.Int64(3),  # P1,  # 觀察收益率歷史向前推的交易日長度;
#     return_PickStock["Coefficient"][2],  # Core.Int64(3),  # P2  # 依據市值高低分組選股的分類數目;
#     MarketTiming_Parameter,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Array{Core.Union{Core.Int64, Core.Float64}, 1}[Core.Int64(), Core.Float64(), Core.Float64(), Core.Float64()], "Short_Selling" => ::Core.Array{Core.Union{Core.Int64, Core.Float64}, 1}[Core.Int64(), Core.Float64(), Core.Float64(), Core.Float64()])),
#     MarketTiming,
#     MarketTiming_fit_model,
#     Intuitive_Momentum_KLine,
#     "Long_Position_and_Short_Selling"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
# );
# println("y_profit = ", return_PickStock_fit_model["y_profit"]);  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
# println("y_Long_Position_profit = ", return_PickStock_fit_model["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
# println("y_Short_Selling_profit = ", return_PickStock_fit_model["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
# println("y_loss = ", return_PickStock_fit_model["y_loss"]);  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
# println("y_Long_Position_loss = ", return_PickStock_fit_model["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
# println("y_Short_Selling_loss = ", return_PickStock_fit_model["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
# println("maximum_drawdown = ", return_PickStock_fit_model["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# println("maximum_drawdown_Long_Position = ", return_PickStock_fit_model["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# println("maximum_drawdown_Short_Selling = ", return_PickStock_fit_model["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# println("profit_total = ", return_PickStock_fit_model["profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# println("Long_Position_profit_total = ", return_PickStock_fit_model["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# println("Short_Selling_profit_total = ", return_PickStock_fit_model["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# println("profit_Positive = ", return_PickStock_fit_model["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# println("Long_Position_profit_Positive = ", return_PickStock_fit_model["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# println("Short_Selling_profit_Positive = ", return_PickStock_fit_model["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# println("profit_Positive_probability = ", return_PickStock_fit_model["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# println("Long_Position_profit_Positive_probability = ", return_PickStock_fit_model["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# println("Short_Selling_profit_Positive_probability = ", return_PickStock_fit_model["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# println("profit_Negative = ", return_PickStock_fit_model["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# println("Long_Position_profit_Negative = ", return_PickStock_fit_model["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# println("Short_Selling_profit_Negative = ", return_PickStock_fit_model["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# println("profit_Negative_probability = ", return_PickStock_fit_model["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# println("Long_Position_profit_Negative_probability = ", return_PickStock_fit_model["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# println("Short_Selling_profit_Negative_probability = ", return_PickStock_fit_model["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# println("average_price_amplitude_date_transaction = ", return_PickStock_fit_model["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# println("Long_Position_average_price_amplitude_date_transaction = ", return_PickStock_fit_model["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# println("Short_Selling_average_price_amplitude_date_transaction = ", return_PickStock_fit_model["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# println("average_volume_turnover_date_transaction = ", return_PickStock_fit_model["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# println("Long_Position_average_volume_turnover_date_transaction = ", return_PickStock_fit_model["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# println("Short_Selling_average_volume_turnover_date_transaction = ", return_PickStock_fit_model["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# println("average_date_transaction_between = ", return_PickStock_fit_model["average_date_transaction_between"]);  # 兩次交易間隔日長，均值;
# println("Long_Position_average_date_transaction_between = ", return_PickStock_fit_model["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# println("Short_Selling_average_date_transaction_between = ", return_PickStock_fit_model["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# println("number_PickStock_transaction = ", return_PickStock_fit_model["number_PickStock_transaction"]);  # 交易過股票的總隻數;
# println("weight_PickStock = ", return_PickStock_fit_model["weight_PickStock"]);  # 選股權重，每隻股票的盈利概率占比;
# println(return_PickStock_fit_model["PickStock_sort"]);  # 依照選股規則排序篩選出的股票代碼字符串和得分存儲字典（Dict）;
# println(return_PickStock_fit_model["PickStock_sort"]["ticker_symbol"]);  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;
# println(return_PickStock_fit_model["PickStock_sort"]["score"]);  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]);
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]);
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
# println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;

# 匯入自定義的量化交易倉位模組脚本文檔「./Quantitative_SizePosition.jl」;
Base.MainInclude.include("./Quantitative_SizePosition.jl");
# return_SizePosition = SizePosition(
#     training_data = training_data,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("date_transaction" => ::Core.Array{Dates.Date, 1}[Dates.Date("2024-01-02")], "turnover_volume" => ::Core.Array{Core.Int64, 1}[Core.Int64()], "opening_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "close_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "low_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "high_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()])),
#     testing_data = training_data,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("date_transaction" => ::Core.Array{Dates.Date, 1}[Dates.Date("2024-01-02")], "turnover_volume" => ::Core.Array{Core.Int64, 1}[Core.Int64()], "opening_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "close_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "low_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "high_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()])),
#     Pdata_0 = [Base.Dict{Core.String, Core.Any}("ticker_symbol" => return_MarketTiming_fit_model["ticker_symbol"]["weight_MarketTiming"]), return_PickStock_fit_model["weight_PickStock"]],  # [weight_MarketTiming_Dict, weight_PickStock_Dict],  # training_data["002611"]["Pdata_0"],  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64())), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],
#     weight = Core.Array{Core.Float64, 1}(),  # training_data["002611"]["weight"],  # [Core.Float64(1.0) for i in 1:Base.length(training_data)],
#     Plower = Core.Array{Core.Any, 1}(),  # [Plower_weight_MarketTiming_Dict, Plower_weight_PickStock_Dict],  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(0.0), "Short_Selling" => ::Core.Float64 = Core.Float64(0.0))), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],  # [-Base.Inf, -Base.Inf, -Base.Inf, -Base.Inf, -Base.Inf],
#     Pupper = Core.Array{Core.Any, 1}(),  # [Pupper_weight_MarketTiming_Dict, Pupper_weight_PickStock_Dict],  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(1.0), "Short_Selling" => ::Core.Float64 = Core.Float64(1.0))), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],  # [+Base.Inf, +Base.Inf, +Base.Inf, +Base.Inf, +Base.Inf],
#     MarketTiming_Parameter = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("investment_method" => return_MarketTiming["ticker_symbol"]["Coefficient"])),  # 按照擇時規則優化之後的參數字典;  # MarketTiming_Parameter_Dict,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Array{Core.Union{Core.Int64, Core.Float64}, 1}[Core.Int64(), Core.Float64(), Core.Float64(), Core.Float64()], "Short_Selling" => ::Core.Array{Core.Union{Core.Int64, Core.Float64}, 1}[Core.Int64(), Core.Float64(), Core.Float64(), Core.Float64()])),
#     PickStock_Parameter = Base.Dict{Core.String, Core.Any}("investment_method" => return_PickStock["Coefficient"]),  # 按照選股規則優化之後的參數字典;  # PickStock_Parameter_Dict,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Array{Core.Int64, 1}[Core.Int64(), Core.Int64()], "Short_Selling" => ::Core.Array{Core.Int64, 1}[Core.Int64(), Core.Int64()])),
#     PickStock_ticker_symbol = return_PickStock_fit_model["PickStock_sort"]["ticker_symbol"],  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;  # ::Core.Array{Core.Array{Core.String, 1}, 1}[[Base.string()]],  # ::Core.Array{Core.Any, 1}[[Base.string()]],
#     SizePosition_fit_model = SizePosition_fit_model,
#     PickStock = PickStock,
#     PickStock_fit_model = PickStock_fit_model,
#     MarketTiming = MarketTiming,
#     MarketTiming_fit_model = MarketTiming_fit_model,
#     Quantitative_Indicators_Function = Intuitive_Momentum_KLine,
#     investment_method = "Long_Position"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
# );
# println("optimization - coefficient 1 - weight_MarketTiming :", "\n", return_SizePosition["Coefficient"][1], "optimization - coefficient 2 - weight_PickStock :", "\n", return_SizePosition["Coefficient"][2]);  # 最優化計算之後得到的參數;
# # println("optimization - coefficient StandardDeviation : ", return_SizePosition["Coefficient-StandardDeviation"]);  # 擬合得到的參數解的標準差;
# # println("optimization - coefficient Confidence Lower 95% : ", return_SizePosition["Coefficient-Confidence-Lower-95%"]);  # 擬合得到的參數解的區間估計下限;
# # println("optimization - coefficient Confidence Upper 95% : ", return_SizePosition["Coefficient-Confidence-Upper-95%"]);  # 擬合得到的參數解的區間估計上限;
# # println("y - fit : ", return_SizePosition["Yfit"]);  # 擬合 y 值;
# # println("y - fit Uncertainty Lower : ", return_SizePosition["Yfit-Uncertainty-Lower"]);  # 擬合的應變量 Yvals 誤差下限;
# # println("y - fit Uncertainty Upper : ", return_SizePosition["Yfit-Uncertainty-Upper"]);  # 擬合的應變量 Yvals 誤差上限;
# # println("residual : ", return_SizePosition["Residual"]);  # 擬合殘差;
# println("optimization - y_profit : ", return_SizePosition["y_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
# println("Long Position optimization - y_profit : ", return_SizePosition["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
# println("Short Selling optimization - y_profit : ", return_SizePosition["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
# println("optimization - y_loss : ", return_SizePosition["y_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
# println("Long Position optimization - y_loss : ", return_SizePosition["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
# println("Short Selling optimization - y_loss : ", return_SizePosition["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
# println("maximum_drawdown : ", return_SizePosition["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# println("maximum_drawdown_Long_Position : ", return_SizePosition["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# println("maximum_drawdown_Short_Selling : ", return_SizePosition["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# println("profit total per share : ", return_SizePosition["profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# println("Long Position profit total per share : ", return_SizePosition["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# println("Short Selling profit total per share : ", return_SizePosition["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# println("profit Positive : ", return_SizePosition["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# println("Long Position profit Positive : ", return_SizePosition["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# println("Short Selling_profit Positive : ", return_SizePosition["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# println("profit Positive probability : ", return_SizePosition["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# println("Long Position profit Positive probability : ", return_SizePosition["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# println("Short Selling profit Positive probability : ", return_SizePosition["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# println("profit Negative : ", return_SizePosition["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# println("Long Position profit Negative : ", return_SizePosition["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# println("Short Selling profit Negative : ", return_SizePosition["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# println("profit Negative probability : ", return_SizePosition["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# println("Long Position profit Negative probability : ", return_SizePosition["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# println("Short Selling profit Negative probability : ", return_SizePosition["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# println("average price amplitude date transaction : ", return_SizePosition["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# println("Long Position average price amplitude date transaction : ", return_SizePosition["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# println("Short Selling average price amplitude date transaction : ", return_SizePosition["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# println("average volume turnover date transaction : ", return_SizePosition["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# println("Long Position average volume turnover date transaction : ", return_SizePosition["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# println("Short Selling average volume turnover date transaction : ", return_SizePosition["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# println("average date transaction between : ", return_SizePosition["average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# println("Long Position average date transaction between : ", return_SizePosition["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# println("Short Selling average date transaction between : ", return_SizePosition["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# println("number SizePosition transaction : ", return_SizePosition["number_PickStock_transaction"]);  # 交易過股票的總隻數，函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
# println(return_SizePosition["SizePosition_transaction_sequence"]);  # 記錄按規則篩選股票按照擇時規則交易信息的序列字典（Dict）;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]);  # 記錄按規則篩選股票按照擇時規則交易信息的序列字典（Dict）;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
# println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
# println("test profit estimate : ", return_SizePosition["test_profit"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# println("test odds ratio estimate : ", return_SizePosition["test_odds_ratio"]);
# println("test date transaction between : ", return_SizePosition["test_date_transaction_between"]);
# # println(return_SizePosition["testData"]);;  # 傳入測試數據集的計算結果;
# println("test profit total per share : ", return_SizePosition["testData"]["profit_total"]);
# println("test Long Position profit total per share : ", return_SizePosition["testData"]["Long_Position_profit_total"]);
# println("test Short Selling profit total per share : ", return_SizePosition["testData"]["Short_Selling_profit_total"]);
# println("test profit positive per share : ", return_SizePosition["testData"]["profit_Positive"]);
# println("test Long Position profit positive per share : ", return_SizePosition["testData"]["Long_Position_profit_Positive"]);
# println("test Short Selling profit positive per share : ", return_SizePosition["testData"]["Short_Selling_profit_Positive"]);
# println("test profit positive probability : ", return_SizePosition["testData"]["profit_Positive_probability"]);
# println("test Long Position profit positive probability : ", return_SizePosition["testData"]["Long_Position_profit_Positive_probability"]);
# println("test Short Selling profit positive probability : ", return_SizePosition["testData"]["Short_Selling_profit_Positive_probability"]);
# println("test profit negative per share : ", return_SizePosition["testData"]["profit_Negative"]);
# println("test Long Position profit negative per share : ", return_SizePosition["testData"]["Long_Position_profit_Negative"]);
# println("test Short Selling profit negative per share : ", return_SizePosition["testData"]["Short_Selling_profit_Negative"]);
# println("test profit negative probability : ", return_SizePosition["testData"]["profit_Negative_probability"]);
# println("test Long Position profit negative probability : ", return_SizePosition["testData"]["Long_Position_profit_Negative_probability"]);
# println("test Short Selling profit negative probability : ", return_SizePosition["testData"]["Short_Selling_profit_Negative_probability"]);
# println("test average date transaction between : ", return_SizePosition["testData"]["average_date_transaction_between"]);
# println("test Long Position average date transaction between : ", return_SizePosition["testData"]["Long_Position_average_date_transaction_between"]);
# println("test Short Selling average date transaction between : ", return_SizePosition["testData"]["Short_Selling_average_date_transaction_between"]);
# println("test number SizePosition transaction : ", return_SizePosition["testData"]["number_PickStock_transaction"]);  # 交易過股票的總隻數;
# # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]["P1_Array"]);
# # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"]);
# # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"]);
# # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]);
# weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
# weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
# if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 1 && Base.isa(return_SizePosition["Coefficient"][1], Base.Dict)
#     for (key, value) in return_SizePosition["Coefficient"][1]
#         # println("Key: $key, Value: $value");
#         if Base.isa(value, Base.Dict) && Base.haskey(value, "Long_Position")
#             if Base.isa(weight_MarketTiming_Dict, Base.Dict) && Base.haskey(weight_MarketTiming_Dict, Base.string(key))
#                 if Base.isa(weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
#                     weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
#                 end
#             elseif Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
#                 weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
#                 weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
#             else
#             end
#         end
#     end
# end
# if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 2 && Base.isa(return_SizePosition["Coefficient"][2], Base.Dict)
#     for (key, value) in return_SizePosition["Coefficient"][2]
#         # println("Key: $key, Value: $value");
#         if Base.isa(value, Base.Dict) && Base.haskey(value, "Long_Position")
#             if Base.isa(weight_PickStock_Dict, Base.Dict) && Base.haskey(weight_PickStock_Dict, Base.string(key))
#                 if Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict)
#                     weight_PickStock_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
#                 end
#             elseif Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
#                 weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
#                 weight_PickStock_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
#             else
#             end
#         end
#     end
# end
# return_SizePosition = Core.nothing;  # 釋放内存;
# # investment_method = "Short_Selling"
# return_SizePosition = SizePosition(
#     training_data = training_data,  # ::Core.Array{Core.Float64, 2} = testing_data,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
#     testing_data = training_data,  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
#     Pdata_0 = [weight_MarketTiming_Dict, weight_PickStock_Dict],  #training_data["002611"]["Pdata_0"],
#     weight = Core.Array{Core.Float64, 1}(),  # training_data["002611"]["weight"],
#     Plower = [Plower_weight_MarketTiming_Dict, Plower_weight_PickStock_Dict],
#     Pupper = [Pupper_weight_MarketTiming_Dict, Pupper_weight_PickStock_Dict],
#     MarketTiming_Parameter = MarketTiming_Parameter_Dict,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
#     PickStock_Parameter = PickStock_Parameter_Dict,  # 按照選股規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
#     PickStock_ticker_symbol = return_PickStock_fit_model["PickStock_sort"]["ticker_symbol"],  # Core.Array{Core.Any, 1}(),  # ::Core.Array{Core.Array{Core.String, 1}, 1} = Core.Array{Core.Array{Core.String, 1}, 1}(),  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;
#     SizePosition_fit_model = SizePosition_fit_model,
#     PickStock = PickStock,
#     PickStock_fit_model = PickStock_fit_model,
#     MarketTiming = MarketTiming,
#     MarketTiming_fit_model = MarketTiming_fit_model,
#     Quantitative_Indicators_Function = Intuitive_Momentum_KLine,
#     investment_method = "Short_Selling"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
# );
# if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 1 && Base.isa(return_SizePosition["Coefficient"][1], Base.Dict)
#     for (key, value) in return_SizePosition["Coefficient"][1]
#         # println("Key: $key, Value: $value");
#         if Base.isa(value, Base.Dict) && Base.haskey(value, "Short_Selling")
#             if Base.isa(weight_MarketTiming_Dict, Base.Dict) && Base.haskey(weight_MarketTiming_Dict, Base.string(key))
#                 if Base.isa(weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
#                     weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
#                 end
#             elseif Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
#                 weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
#                 weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
#             else
#             end
#         end
#     end
# end
# if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 2 && Base.isa(return_SizePosition["Coefficient"][2], Base.Dict)
#     for (key, value) in return_SizePosition["Coefficient"][2]
#         # println("Key: $key, Value: $value");
#         if Base.isa(value, Base.Dict) && Base.haskey(value, "Short_Selling")
#             if Base.isa(weight_PickStock_Dict, Base.Dict) && Base.haskey(weight_PickStock_Dict, Base.string(key))
#                 if Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict)
#                     weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
#                 end
#             elseif Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
#                 weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
#                 weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
#             else
#             end
#         end
#     end
# end
# return_SizePosition = Core.nothing;  # 釋放内存;
# SizePosition_Parameter_Array = [weight_MarketTiming_Dict, weight_PickStock_Dict];  # 依照倉位規則優化之後得到的倉位數據存儲字典;
# return_SizePosition_fit_model = SizePosition_fit_model(
#     training_data,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("date_transaction" => ::Core.Array{Dates.Date, 1}[Dates.Date("2024-01-02")], "turnover_volume" => ::Core.Array{Core.Int64, 1}[Core.Int64()], "opening_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "close_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "low_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "high_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()])),
#     SizePosition_Parameter_Array[1],  # 股票擇時交易倉位占比;  # weight_MarketTiming_Dict,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64())),
#     SizePosition_Parameter_Array[2],  # 選股組合占比;  # weight_PickStock_Dict,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64())),
#     Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("investment_method" => return_MarketTiming["ticker_symbol"]["Coefficient"])),  # MarketTiming_Parameter_Dict,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Array{Core.Union{Core.Int64, Core.Float64}, 1}[Core.Int64(), Core.Float64(), Core.Float64(), Core.Float64()], "Short_Selling" => ::Core.Array{Core.Union{Core.Int64, Core.Float64}, 1}[Core.Int64(), Core.Float64(), Core.Float64(), Core.Float64()])),
#     Base.Dict{Core.String, Core.Any}("investment_method" => return_PickStock["Coefficient"]),  # PickStock_Parameter_Dict,  # 按照選股規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Array{Core.Int64, 1}[Core.Int64(), Core.Int64()], "Short_Selling" => ::Core.Array{Core.Int64, 1}[Core.Int64(), Core.Int64()])),
#     return_PickStock_fit_model["PickStock_sort"]["ticker_symbol"],  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;  # ::Core.Array{Core.Array{Core.String, 1}, 1}[[Base.string()]],  # ::Core.Array{Core.Any, 1}[[Base.string()]],
#     PickStock,
#     PickStock_fit_model,
#     MarketTiming,
#     MarketTiming_fit_model,
#     Intuitive_Momentum_KLine,
#     "Long_Position"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
# );
# println("y_profit = ", return_PickStock_fit_model["y_profit"]);  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
# println("y_Long_Position_profit = ", return_PickStock_fit_model["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
# println("y_Short_Selling_profit = ", return_PickStock_fit_model["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
# println("y_loss = ", return_PickStock_fit_model["y_loss"]);  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
# println("y_Long_Position_loss = ", return_PickStock_fit_model["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
# println("y_Short_Selling_loss = ", return_PickStock_fit_model["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
# println("maximum_drawdown = ", return_PickStock_fit_model["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# println("maximum_drawdown_Long_Position = ", return_PickStock_fit_model["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# println("maximum_drawdown_Short_Selling = ", return_PickStock_fit_model["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# println("profit_total = ", return_SizePosition_fit_model["profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
# println("Long_Position_profit_total = ", return_SizePosition_fit_model["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
# println("Short_Selling_profit_total = ", return_SizePosition_fit_model["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
# println("profit_Positive = ", return_SizePosition_fit_model["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# println("profit_Negative = ", return_SizePosition_fit_model["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# println("Long_Position_profit_Positive = ", return_SizePosition_fit_model["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# println("Long_Position_profit_Negative = ", return_SizePosition_fit_model["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# println("Short_Selling_profit_Positive = ", return_SizePosition_fit_model["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# println("Short_Selling_profit_Negative = ", return_SizePosition_fit_model["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# println("profit_Positive_probability = ", return_SizePosition_fit_model["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# println("profit_Negative_probability = ", return_SizePosition_fit_model["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# println("Long_Position_profit_Positive_probability = ", return_SizePosition_fit_model["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# println("Long_Position_profit_Negative_probability = ", return_SizePosition_fit_model["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# println("Short_Selling_profit_Positive_probability = ", return_SizePosition_fit_model["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# println("Short_Selling_profit_Negative_probability = ", return_SizePosition_fit_model["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# println("average_price_amplitude_date_transaction = ", return_SizePosition_fit_model["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# println("Long_Position_average_price_amplitude_date_transaction = ", return_SizePosition_fit_model["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# println("Short_Selling_average_price_amplitude_date_transaction = ", return_SizePosition_fit_model["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# println("average_volume_turnover_date_transaction = ", return_SizePosition_fit_model["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# println("Long_Position_average_volume_turnover_date_transaction = ", return_SizePosition_fit_model["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# println("Short_Selling_average_volume_turnover_date_transaction = ", return_SizePosition_fit_model["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# println("average_date_transaction_between = ", return_SizePosition_fit_model["average_date_transaction_between"]);  # 兩次交易間隔日長，均值;
# println("Long_Position_average_date_transaction_between = ", return_SizePosition_fit_model["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# println("Short_Selling_average_date_transaction_between = ", return_SizePosition_fit_model["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# println("number_SizePosition_transaction = ", return_SizePosition_fit_model["number_PickStock_transaction"]);  # 交易過股票的總隻數;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]);
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
# # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;



# 四、回測（back testing），推進分析（Stepper movement）（propulsion analysis）;

function BackTesting_Stepper(
    ;steppingData::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("date_transaction" => ::Core.Array{Dates.Date, 1}[Dates.Date("2024-01-02")], "turnover_volume" => ::Core.Array{Core.Int64, 1}[Core.Int64()], "opening_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "close_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "low_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()], "high_price" => ::Core.Array{Core.Float64, 1}[Core.Float64()])),
    # risk_threshold::Core.Float64 = Core.Float64(0.0),  # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
    training_sequence_length::Core.Int64 = Core.Int64(60),
    training_ticker_symbol::Core.Array{Core.String, 1} = [Base.string(item) for item in Base.keys(steppingData)],  # 函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
    testing_ticker_symbol::Core.Array{Core.String, 1} = [Base.string(item) for item in Base.keys(steppingData)],  # 函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
    testing_sequence_length::Core.Int64 = Core.Int64(1),
    SizePosition = (arguments) -> begin return arguments; end,
    SizePosition_fit_model = (arguments) -> begin return arguments; end,
    SizePosition_Pdata_0 = Core.Array{Core.Any, 1}(),  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64())), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],
    SizePosition_weight = Core.Array{Core.Any, 1}(),  # [Core.Float64(1.0) for i in 1:Base.length(steppingData)],
    SizePosition_Plower = Core.Array{Core.Any, 1}(),  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(0.0), "Short_Selling" => ::Core.Float64 = Core.Float64(0.0))), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],  # [-Base.Inf, -Base.Inf, -Base.Inf, -Base.Inf, -Base.Inf],
    SizePosition_Pupper = Core.Array{Core.Any, 1}(),  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(1.0), "Short_Selling" => ::Core.Float64 = Core.Float64(1.0))), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],  # [+Base.Inf, +Base.Inf, +Base.Inf, +Base.Inf, +Base.Inf],
    PickStock = (arguments) -> begin return arguments; end,
    PickStock_fit_model = (arguments) -> begin return arguments; end,
    PickStock_Pdata_0 = Core.Array{Core.Any, 1}(),  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64())), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],
    PickStock_weight = Core.Array{Core.Any, 1}(),  # [Core.Float64(1.0) for i in 1:Base.length(steppingData)],
    PickStock_Plower = Core.Array{Core.Any, 1}(),  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(0.0), "Short_Selling" => ::Core.Float64 = Core.Float64(0.0))), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],  # [-Base.Inf, -Base.Inf, -Base.Inf, -Base.Inf, -Base.Inf],
    PickStock_Pupper = Core.Array{Core.Any, 1}(),  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(1.0), "Short_Selling" => ::Core.Float64 = Core.Float64(1.0))), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],  # [+Base.Inf, +Base.Inf, +Base.Inf, +Base.Inf, +Base.Inf],
    MarketTiming = (arguments) -> begin return arguments; end,
    MarketTiming_fit_model = (arguments) -> begin return arguments; end,
    MarketTiming_Pdata_0 = Core.Array{Core.Any, 1}(),  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64())), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],
    MarketTiming_weight = Core.Array{Core.Any, 1}(),  # [Core.Float64(1.0) for i in 1:Base.length(steppingData)],
    MarketTiming_Plower = Core.Array{Core.Any, 1}(),  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(0.0), "Short_Selling" => ::Core.Float64 = Core.Float64(0.0))), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],  # [-Base.Inf, -Base.Inf, -Base.Inf, -Base.Inf, -Base.Inf],
    MarketTiming_Pupper = Core.Array{Core.Any, 1}(),  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(1.0), "Short_Selling" => ::Core.Float64 = Core.Float64(1.0))), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],  # [+Base.Inf, +Base.Inf, +Base.Inf, +Base.Inf, +Base.Inf],
    Quantitative_Indicators_Function = (arguments) -> begin return arguments; end,
    investment_method = "Long_Position_and_Short_Selling"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
) ::Base.Dict{Core.String, Core.Any}

    # risk_threshold_drawdown_loss::Core.Float64 = risk_threshold;  # ::Core.Float64 = Core.Float64(0.0);  # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
    training_data_sequence_length::Core.Int64 = training_sequence_length;  # ::Core.Int64 = Core.Int64(60);
    training_data_ticker_symbol_Array::Core.Array{Core.String, 1} = training_ticker_symbol;  # ::Core.Array{Core.String, 1} = [Base.string(item) for item in Base.keys(steppingData)];  # 函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
    testing_data_ticker_symbol_Array::Core.Array{Core.String, 1} = testing_ticker_symbol;  # ::Core.Array{Core.String, 1} = [Base.string(item) for item in Base.keys(steppingData)];  # 函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
    testing_data_sequence_length::Core.Int64 = testing_sequence_length;  # ::Core.Int64 = Core.Int64(1),

    # 交易過股票的總隻數，函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
    maximum_ticker_symbol_transaction = Core.Int64(0);  # Core.Int64(Base.length([key for key in Base.keys(steppingData)]));  # 交易過股票的總隻數;
    maximum_dates_transaction = Core.Int64(0);  # 各股票裏的最長交易天數;
    minimum_dates_transaction = Core.Int64(0);  # 各股票裏的最短交易天數;
    if Base.isa(steppingData, Base.Dict) && Core.Int64(Base.length(steppingData)) > Core.Int64(0)

        # 交易過股票的總隻數，函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
        maximum_ticker_symbol_transaction = Core.Int64(Base.length([key for key in Base.keys(steppingData)]));  # 交易過股票的總隻數;
        # println(maximum_ticker_symbol_transaction);
        maximum_dates_transaction = Core.Int64(0);  # 各股票裏的最長交易天數;
        minimum_dates_transaction = Core.Int64(0);  # 各股票裏的最短交易天數;
        dates_transaction_Array = Core.Array{Core.Int64, 1}();
        # 遍歷字典的鍵:值對;
        for (key, value) in steppingData
            # println("Key: $key, Value: $value");
            if Base.isa(value, Base.Dict)
                if Base.haskey(value, "date_transaction") && Base.typeof(value["date_transaction"]) <: Core.Array
                    # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                    Base.push!(dates_transaction_Array, Core.Int64(Base.length(value["date_transaction"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                    # 篩選最長交易天數;
                    if Core.Int64(Base.length(value["date_transaction"])) > Core.Int64(maximum_dates_transaction)
                        maximum_dates_transaction_2 = Core.Int64(Base.length(value["date_transaction"]));
                        # global maximum_dates_transaction *= Core.Int64(0);
                        maximum_dates_transaction *= Core.Int64(0);
                        # global maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
                        maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
                    end
                end
                if Base.haskey(value, "turnover_volume") && Base.typeof(value["turnover_volume"]) <: Core.Array
                    # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                    Base.push!(dates_transaction_Array, Core.Int64(Base.length(value["turnover_volume"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                    # 篩選最長交易天數;
                    if Core.Int64(Base.length(value["turnover_volume"])) > Core.Int64(maximum_dates_transaction)
                        maximum_dates_transaction_2 = Core.Int64(Base.length(value["turnover_volume"]));
                        # global maximum_dates_transaction *= Core.Int64(0);
                        maximum_dates_transaction *= Core.Int64(0);
                        # global maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
                        maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
                    end
                end
                if Base.haskey(value, "opening_price") && Base.typeof(value["opening_price"]) <: Core.Array
                    # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                    Base.push!(dates_transaction_Array, Core.Int64(Base.length(value["opening_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                    # 篩選最長交易天數;
                    if Core.Int64(Base.length(value["opening_price"])) > Core.Int64(maximum_dates_transaction)
                        maximum_dates_transaction_2 = Core.Int64(Base.length(value["opening_price"]));
                        # global maximum_dates_transaction *= Core.Int64(0);
                        maximum_dates_transaction *= Core.Int64(0);
                        # global maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
                        maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
                    end
                end
                if Base.haskey(value, "close_price") && Base.typeof(value["close_price"]) <: Core.Array
                    # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                    Base.push!(dates_transaction_Array, Core.Int64(Base.length(value["close_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                    # 篩選最長交易天數;
                    if Core.Int64(Base.length(value["close_price"])) > Core.Int64(maximum_dates_transaction)
                        maximum_dates_transaction_2 = Core.Int64(Base.length(value["close_price"]));
                        # global maximum_dates_transaction *= Core.Int64(0);
                        maximum_dates_transaction *= Core.Int64(0);
                        # global maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
                        maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
                    end
                end
                if Base.haskey(value, "low_price") && Base.typeof(value["low_price"]) <: Core.Array
                    # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                    Base.push!(dates_transaction_Array, Core.Int64(Base.length(value["low_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                    # 篩選最長交易天數;
                    if Core.Int64(Base.length(value["low_price"])) > Core.Int64(maximum_dates_transaction)
                        maximum_dates_transaction_2 = Core.Int64(Base.length(value["low_price"]));
                        # global maximum_dates_transaction *= Core.Int64(0);
                        maximum_dates_transaction *= Core.Int64(0);
                        # global maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
                        maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
                    end
                end
                if Base.haskey(value, "high_price") && Base.typeof(value["high_price"]) <: Core.Array
                    # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                    Base.push!(dates_transaction_Array, Core.Int64(Base.length(value["high_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                    # 篩選最長交易天數;
                    if Core.Int64(Base.length(value["high_price"])) > Core.Int64(maximum_dates_transaction)
                        maximum_dates_transaction_2 = Core.Int64(Base.length(value["high_price"]));
                        # global maximum_dates_transaction *= Core.Int64(0);
                        maximum_dates_transaction *= Core.Int64(0);
                        # global maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
                        maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
                    end
                end
            end
        end
        # println(maximum_dates_transaction);
        if Base.length(dates_transaction_Array) > 0
            minimum_dates_transaction_2 = Core.Int64(Base.findmin(dates_transaction_Array)[1]);
            minimum_dates_transaction *= Core.Int64(0);
            minimum_dates_transaction += Core.Int64(minimum_dates_transaction_2);
        end
        # println(minimum_dates_transaction);
        dates_transaction_Array = Core.nothing;
    end

    # 求解擇時優化參數迭代初始值的預設值;
    if (Base.typeof(MarketTiming_Pdata_0) <: Core.Array || Base.typeof(MarketTiming_Pdata_0) <: Base.Vector) && Core.Int64(Base.length(MarketTiming_Pdata_0)) === Core.Int64(0)
        # if Base.isa(steppingData, Base.Dict) && Core.Int64(Base.length(steppingData)) > Core.Int64(0)
        #     # 優化求解擇時參數;
        #     MarketTiming_Parameter = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則優化之後得到的擇時規則的輸入參數存儲字典;
        #     weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
        #     Plower_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();
        #     Pupper_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();

        #     for (key, value) in steppingData
        #         # println("Key: $key, Value: $value");
        #         if Base.isa(value, Base.Dict) && (Base.haskey(value, "date_transaction") && Base.typeof(value["date_transaction"]) <: Core.Array) && (Base.haskey(value, "turnover_volume") && Base.typeof(value["turnover_volume"]) <: Core.Array) && (Base.haskey(value, "opening_price") && Base.typeof(value["opening_price"]) <: Core.Array) && (Base.haskey(value, "close_price") && Base.typeof(value["close_price"]) <: Core.Array) && (Base.haskey(value, "low_price") && Base.typeof(value["low_price"]) <: Core.Array) && (Base.haskey(value, "high_price") && Base.typeof(value["high_price"]) <: Core.Array) && (Base.haskey(value, "focus") && Base.typeof(value["focus"]) <: Core.Array) && (Base.haskey(value, "amplitude") && Base.typeof(value["amplitude"]) <: Core.Array) && (Base.haskey(value, "amplitude_rate") && Base.typeof(value["amplitude_rate"]) <: Core.Array) && (Base.haskey(value, "opening_price_Standardization") && Base.typeof(value["opening_price_Standardization"]) <: Core.Array) && (Base.haskey(value, "closing_price_Standardization") && Base.typeof(value["closing_price_Standardization"]) <: Core.Array) && (Base.haskey(value, "low_price_Standardization") && Base.typeof(value["low_price_Standardization"]) <: Core.Array) && (Base.haskey(value, "high_price_Standardization") && Base.typeof(value["high_price_Standardization"]) <: Core.Array) && (Base.haskey(value, "turnover_volume_growth_rate") && Base.typeof(value["turnover_volume_growth_rate"]) <: Core.Array) && (Base.haskey(value, "opening_price_growth_rate") && Base.typeof(value["opening_price_growth_rate"]) <: Core.Array) && (Base.haskey(value, "closing_price_growth_rate") && Base.typeof(value["closing_price_growth_rate"]) <: Core.Array) && (Base.haskey(value, "closing_minus_opening_price_growth_rate") && Base.typeof(value["closing_minus_opening_price_growth_rate"]) <: Core.Array) && (Base.haskey(value, "high_price_proportion") && Base.typeof(value["high_price_proportion"]) <: Core.Array) && (Base.haskey(value, "low_price_proportion") && Base.typeof(value["low_price_proportion"]) <: Core.Array)

        #             x0 = value["date_transaction"];  # 交易日期;
        #             x1 = value["turnover_volume"];  # 成交量;
        #             # x2 = value["turnover_amount"];  # 成交總金額;
        #             x3 = value["opening_price"];  # 開盤成交價;
        #             x4 = value["close_price"];  # 收盤成交價;
        #             x5 = value["low_price"];  # 最低成交價;
        #             x6 = value["high_price"];  # 最高成交價;
        #             x7 = value["focus"];  # 當日成交價重心;
        #             x8 = value["amplitude"];  # 當日成交價絕對振幅;
        #             x9 = value["amplitude_rate"];  # 當日成交價相對振幅（%）;
        #             x10 = value["opening_price_Standardization"];  # 日棒缐（K Line Daily）數據交易日首筆成交價（開盤價）標準化值;
        #             x11 = value["closing_price_Standardization"];  # 日棒缐（K Line Daily）數據交易日尾筆成交價（收盤價）標準化值;
        #             x12 = value["low_price_Standardization"];  # 日棒缐（K Line Daily）數據交易日最低成交價標準化值;
        #             x13 = value["high_price_Standardization"];  # 日棒缐（K Line Daily）數據交易日最高成交價標準化值;
        #             x14 = value["turnover_volume_growth_rate"];  # 成交量的成長率;
        #             x15 = value["opening_price_growth_rate"];  # 開盤價的成長率;
        #             x16 = value["closing_price_growth_rate"];  # 收盤價的成長率;
        #             x17 = value["closing_minus_opening_price_growth_rate"];  # 收盤價減開盤價的成長率;
        #             x18 = value["high_price_proportion"];  # 收盤價和開盤價裏的最大值占最高價的比例;
        #             x19 = value["low_price_proportion"];  # 最低價占收盤價和開盤價裏的最小值的比例;
        #             # x20 = value["turnover_rate"];  # 成交量換手率;
        #             # x21 = value["price_earnings"];  # 每股收益（公司經營利潤率 ÷ 股本）;
        #             # x22 = value["book_value_per_share"];  # 每股净值（公司净資產 ÷ 股本）;
        #             # x23 = value["capitalization"];  # 總市值;
        #             # x24 = value["moving_average_5"];  # 收盤價 5 日滑動平均缐;
        #             # x25 = value["moving_average_10"];  # 收盤價 10 日滑動平均缐;
        #             # x26 = value["moving_average_20"];  # 收盤價 20 日滑動平均缐;
        #             # x27 = value["moving_average_30"];  # 收盤價 30 日滑動平均缐;
        #             Pdata_0 = value["Pdata_0"];
        #             Plower = value["Plower"];
        #             Pupper = value["Pupper"];
        #             weight = value["weight"];

        #             # investment_method = "Long_Position"
        #             return_MarketTiming = MarketTiming(
        #                 training_data = Base.Dict{Core.String, Core.Any}(
        #                     Base.string(key) => Base.Dict{Core.String, Core.Any}(
        #                         "date_transaction" => x0,
        #                         "turnover_volume" => x1,
        #                         "opening_price" => x3,
        #                         "close_price" => x4,
        #                         "low_price" => x5,
        #                         "high_price" => x6,
        #                         "focus" => x7,
        #                         "amplitude" => x8,
        #                         "amplitude_rate" => x9,
        #                         "opening_price_Standardization" => x10,
        #                         "closing_price_Standardization" => x11,
        #                         "low_price_Standardization" => x12,
        #                         "high_price_Standardization" => x13,
        #                         "turnover_volume_growth_rate" => x14,
        #                         "opening_price_growth_rate" => x15,
        #                         "closing_price_growth_rate" => x16,
        #                         "closing_minus_opening_price_growth_rate" => x17,
        #                         "high_price_proportion" => x18,
        #                         "low_price_proportion" => x19,
        #                         "Pdata_0" => Pdata_0,
        #                         "Plower" => Plower,
        #                         "Pupper" => Pupper,
        #                         "weight" => weight
        #                     )
        #                 ),  # ::Core.Array{Core.Float64, 2} = testing_data,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
        #                 # training_date_transaction = Core.Array{Dates.Date, 1}(),
        #                 # training_opening_price = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
        #                 # training_close_price = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
        #                 # training_low_price = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
        #                 # training_high_price = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
        #                 # training_turnover_volume = Core.Array{Core.Union{Core.UInt64, Core.String, Core.Nothing}, 1}(),
        #                 # training_turnover_rate = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
        #                 # training_price_earnings = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
        #                 testing_data = Base.Dict{Core.String, Core.Any}(
        #                     Base.string(key) => Base.Dict{Core.String, Core.Any}(
        #                         "date_transaction" => x0,
        #                         "turnover_volume" => x1,
        #                         "opening_price" => x3,
        #                         "close_price" => x4,
        #                         "low_price" => x5,
        #                         "high_price" => x6,
        #                         "focus" => x7,
        #                         "amplitude" => x8,
        #                         "amplitude_rate" => x9,
        #                         "opening_price_Standardization" => x10,
        #                         "closing_price_Standardization" => x11,
        #                         "low_price_Standardization" => x12,
        #                         "high_price_Standardization" => x13,
        #                         "turnover_volume_growth_rate" => x14,
        #                         "opening_price_growth_rate" => x15,
        #                         "closing_price_growth_rate" => x16,
        #                         "closing_minus_opening_price_growth_rate" => x17,
        #                         "high_price_proportion" => x18,
        #                         "low_price_proportion" => x19,
        #                         "Pdata_0" => Pdata_0,
        #                         "Plower" => Plower,
        #                         "Pupper" => Pupper,
        #                         "weight" => weight
        #                     )
        #                 ),  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
        #                 # testing_date_transaction = Core.Array{Dates.Date, 1}(),
        #                 # testing_opening_price = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
        #                 # testing_close_price = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
        #                 # testing_low_price = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
        #                 # testing_high_price = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
        #                 # testing_turnover_volume = Core.Array{Core.Union{Core.UInt64, Core.String, Core.Nothing}, 1}(),
        #                 # testing_turnover_rate = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
        #                 # testing_price_earnings = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
        #                 Pdata_0 = Core.Array{Core.Any, 1}(),  # [Core.Int64(5), Core.Float64(+0.1), Core.Float64(-0.1), Core.Float64(0.0)],  # [Pdata_0[1], Pdata_0[2], Pdata_0[3], Pdata_0[4]],  # Pdata_0, # value["Pdata_0"],
        #                 weight = Core.Array{Core.Any, 1}(),  # weight,  # value["weight"],
        #                 Plower = Core.Array{Core.Any, 1}(),  # [-Base.Inf, -Base.Inf, -Base.Inf, -Base.Inf],  # [Plower[1], Plower[2], Plower[3], Plower[4]],  # Plower, # value["Plower"],
        #                 Pupper = Core.Array{Core.Any, 1}(),  # [+Base.Inf, +Base.Inf, +Base.Inf, +Base.Inf],  # [Pupper[1], Pupper[2], Pupper[3], Pupper[4]],  # Pupper, # value["Pupper"],
        #                 MarketTiming_fit_model = MarketTiming_fit_model,
        #                 Quantitative_Indicators_Function = Quantitative_Indicators_Function,
        #                 investment_method = "Long_Position"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
        #             );
        #             # return_MarketTiming === Base.Dict{Core.String, Core.Any}(
        #             #     "ticker_symbol" => Base.Dict{Core.String, Core.Any}(
        #             #         "Coefficient" => coefficient_from_fit,  # 最優化計算之後得到的參數;
        #             #         "y_profit" => y_profit,  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
        #             #         "y_Long_Position_profit" => y_Long_Position_profit,  # 優化目標變量;
        #             #         "y_Short_Selling_profit" => y_Short_Selling_profit,  # 優化目標變量;
        #             #         "y_loss" => y_loss,  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
        #             #         "y_Long_Position_loss" => y_Long_Position_loss,  # 優化目標變量;
        #             #         "y_Short_Selling_loss" => y_Short_Selling_loss,  # 優化目標變量;
        #             #         "profit_total" => y_total,  # 每兩次對衝交易利潤 × 權重，纍加總計;
        #             #         "Long_Position_profit_total" => y_total_Long_Position,  # 每兩次對衝交易利潤 × 權重，纍加總計;
        #             #         "Short_Selling_profit_total" => y_total_Short_Selling,  # 每兩次對衝交易利潤 × 權重，纍加總計;
        #             #         "profit_Positive" => y_Positive,  # 每兩次對衝交易收益纍加總計;
        #             #         "Long_Position_profit_Positive" => y_Positive_Long_Position,  # 每兩次對衝交易收益纍加總計;
        #             #         "Short_Selling_profit_Positive" => y_Positive_Short_Selling,  # 每兩次對衝交易收益纍加總計;
        #             #         "profit_Positive_probability" => y_P_Positive,  # 每兩次對衝交易正利潤概率;
        #             #         "Long_Position_profit_Positive_probability" => y_P_Positive_Long_Position,  # 每兩次對衝交易正利潤概率;
        #             #         "Short_Selling_profit_Positive_probability" => y_P_Positive_Short_Selling,  # 每兩次對衝交易正利潤概率;
        #             #         "profit_Negative" => y_Negative,  # 每兩次對衝交易損失纍加總計;
        #             #         "Long_Position_profit_Negative" => y_Negative_Long_Position,  # 每兩次對衝交易損失纍加總計;
        #             #         "Short_Selling_profit_Negative" => y_Negative_Short_Selling,  # 每兩次對衝交易損失纍加總計;
        #             #         "profit_Negative_probability" => y_P_Negative,  # 每兩次對衝交易負利潤概率;
        #             #         "Long_Position_profit_Negative_probability" => y_P_Negative_Long_Position,  # 每兩次對衝交易負利潤概率;
        #             #         "Short_Selling_profit_Negative_probability" => y_P_Negative_Short_Selling,  # 每兩次對衝交易負利潤概率;
        #             #         "Long_Position_profit_date_transaction" => y_A_Long_Position,  # 每兩次對衝交易利潤，向量;
        #             #         "Short_Selling_profit_date_transaction" => y_A_Short_Selling,  # 每兩次對衝交易利潤，向量;
        #             #         "maximum_drawdown" => y_maximum_drawdown,  # 兩次對衝交易之間的最大回撤值，取極值統計;
        #             #         "maximum_drawdown_Long_Position" => y_maximum_drawdown_Long_Position,  # 兩次對衝交易之間的最大回撤值，取極值統計;
        #             #         "maximum_drawdown_Short_Selling" => y_maximum_drawdown_Short_Selling,  # 兩次對衝交易之間的最大回撤值，取極值統計;
        #             #         "Long_Position_drawdown_date_transaction" => y_H_Long_Position,  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
        #             #         "Short_Selling_drawdown_date_transaction" => y_H_Short_Selling,  # 向量，記錄做空模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
        #             #         "average_price_amplitude_date_transaction" => y_amplitude,  # 兩兩次對衝交易日成交價振幅平方和，均值;
        #             #         "Long_Position_average_price_amplitude_date_transaction" => y_amplitude_Long_Position,  # 兩兩次對衝交易日成交價振幅平方和，均值;
        #             #         "Short_Selling_average_price_amplitude_date_transaction" => y_amplitude_Short_Selling,  # 兩兩次對衝交易日成交價振幅平方和，均值;
        #             #         "Long_Position_price_amplitude_date_transaction" => y_D_Long_Position,  # 兩次對衝交易日成交價振幅平方和，向量;
        #             #         "Short_Selling_price_amplitude_date_transaction" => y_D_Short_Selling,  # 兩次對衝交易日成交價振幅平方和，向量;
        #             #         "average_volume_turnover_date_transaction" => y_turnover,  # 兩次對衝交易日成交量（換手率）均值;
        #             #         "Long_Position_average_volume_turnover_date_transaction" => y_turnover_Long_Position,  # 兩次對衝交易日成交量（換手率）均值;
        #             #         "Short_Selling_average_volume_turnover_date_transaction" => y_turnover_Short_Selling,  # 兩次對衝交易日成交量（換手率）均值;
        #             #         "Long_Position_volume_turnover_date_transaction" => y_E_Long_Position,  # 兩次對衝交易日成交量（換手率）向量;
        #             #         "Short_Selling_volume_turnover_date_transaction" => y_E_Short_Selling,  # 兩次對衝交易日成交量（換手率）向量;
        #             #         "average_date_transaction_between" => y_date_transaction_between,  # 兩次對衝交易間隔日長，均值;
        #             #         "Long_Position_average_date_transaction_between" => y_date_transaction_between_Long_Position,  # 兩次對衝交易間隔日長，均值;
        #             #         "Short_Selling_average_date_transaction_between" => y_date_transaction_between_Short_Selling,  # 兩次對衝交易間隔日長，均值;
        #             #         "Long_Position_date_transaction_between" => y_C_Long_Position,  # 兩次對衝交易間隔日長，向量;
        #             #         "Short_Selling_date_transaction_between" => y_C_Short_Selling,  # 兩次對衝交易間隔日長，向量;
        #             #         "Long_Position_date_transaction" => y_F_Long_Position,  # 按規則執行交易的日期，向量;
        #             #         "Short_Selling_date_transaction" => y_F_Short_Selling,  # 按規則執行交易的日期，向量;
        #             #         "P1_Array" => P1_Array,  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
        #             #         "revenue_and_expenditure_records_date_transaction" => y_G,  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
        #             #         "weight_MarketTiming" => weight_MarketTiming_Dict
        #             #     );
        #             # );
        #             # println(return_MarketTiming[key]["Coefficient"]);  # 最優化計算之後得到的參數;
        #             # println(return_MarketTiming[key]["y_profit"]);  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
        #             # println(return_MarketTiming[key]["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
        #             # println(return_MarketTiming[key]["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
        #             # println(return_MarketTiming[key]["y_loss"]);  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
        #             # println(return_MarketTiming[key]["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
        #             # println(return_MarketTiming[key]["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
        #             # println(return_MarketTiming[key]["profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
        #             # println(return_MarketTiming[key]["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
        #             # println(return_MarketTiming[key]["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
        #             # println(return_MarketTiming[key]["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
        #             # println(return_MarketTiming[key]["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
        #             # println(return_MarketTiming[key]["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
        #             # println(return_MarketTiming[key]["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
        #             # println(return_MarketTiming[key]["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
        #             # println(return_MarketTiming[key]["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
        #             # println(return_MarketTiming[key]["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
        #             # println(return_MarketTiming[key]["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
        #             # println(return_MarketTiming[key]["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
        #             # println(return_MarketTiming[key]["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
        #             # println(return_MarketTiming[key]["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
        #             # println(return_MarketTiming[key]["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
        #             # println(return_MarketTiming[key]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
        #             # println(return_MarketTiming[key]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
        #             # println(return_MarketTiming[key]["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
        #             # println(return_MarketTiming[key]["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
        #             # println(return_MarketTiming[key]["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
        #             # println(return_MarketTiming[key]["Long_Position_drawdown_date_transaction"]);  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
        #             # println(return_MarketTiming[key]["Short_Selling_drawdown_date_transaction"]);  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
        #             # println(return_MarketTiming[key]["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
        #             # println(return_MarketTiming[key]["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
        #             # println(return_MarketTiming[key]["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
        #             # println(return_MarketTiming[key]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
        #             # println(return_MarketTiming[key]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
        #             # println(return_MarketTiming[key]["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
        #             # println(return_MarketTiming[key]["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
        #             # println(return_MarketTiming[key]["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
        #             # println(return_MarketTiming[key]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
        #             # println(return_MarketTiming[key]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
        #             # println(return_MarketTiming[key]["average_date_transaction_between"]);  # 兩次交易間隔日長，均值;
        #             # println(return_MarketTiming[key]["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
        #             # println(return_MarketTiming[key]["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
        #             # println(return_MarketTiming[key]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
        #             # println(return_MarketTiming[key]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
        #             # println(return_MarketTiming[key]["weight_MarketTiming"]);  # 擇時權重，每兩次對衝交易的盈利概率占比;
        #             # println(return_MarketTiming[key]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
        #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
        #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
        #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
        #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
        #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
        #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
        #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
        #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
        #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
        #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
        #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
        #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
        #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
        #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
        #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
        #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
        #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
        #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
        #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
        #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
        #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
        #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
        #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
        #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
        #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
        #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
        #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
        #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
        #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
        #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
        #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
        #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
        #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
        #             # println(return_MarketTiming[key]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
        #             # println(return_MarketTiming[key]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
        #             # MarketTiming_Parameter[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #             if Base.isa(MarketTiming_Parameter, Base.Dict) && Base.haskey(MarketTiming_Parameter, Base.string(key))
        #                 if Base.isa(MarketTiming_Parameter[Base.string(key)], Base.Dict)
        #                     MarketTiming_Parameter[Base.string(key)]["Long_Position"] = return_MarketTiming[key]["Coefficient"];
        #                 end
        #             elseif Base.isa(MarketTiming_Parameter, Base.Dict) && (!Base.haskey(MarketTiming_Parameter, Base.string(key)))
        #                 MarketTiming_Parameter[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #                 MarketTiming_Parameter[Base.string(key)]["Long_Position"] = return_MarketTiming[key]["Coefficient"];
        #             else
        #             end
        #             if Base.isa(weight_MarketTiming_Dict, Base.Dict) && Base.haskey(weight_MarketTiming_Dict, Base.string(key))
        #                 if Base.isa(weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
        #                     weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = return_MarketTiming[key]["weight_MarketTiming"]["Long_Position"];  # 依照擇時規則交易倉位參數的存儲字典;
        #                 end
        #             elseif Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
        #                 weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #                 weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = return_MarketTiming[key]["weight_MarketTiming"]["Long_Position"];  # 依照擇時規則交易倉位參數的存儲字典;
        #             else
        #             end
        #             if Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key))
        #                 if Base.isa(Plower_weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
        #                     Plower_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
        #                 end
        #             elseif Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key)))
        #                 Plower_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #                 Plower_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
        #             else
        #             end
        #             if Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key))
        #                 if Base.isa(Pupper_weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
        #                     Pupper_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
        #                 end
        #             elseif Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key)))
        #                 Pupper_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #                 Pupper_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
        #             else
        #             end
        #             return_MarketTiming = Core.nothing;  # 釋放内存;

        #             # investment_method = "Short_Selling"
        #             return_MarketTiming = MarketTiming(
        #                 training_data = Base.Dict{Core.String, Core.Any}(Base.string(key) => Base.Dict{Core.String, Core.Any}(
        #                     "date_transaction" => x0,
        #                     "turnover_volume" => x1,
        #                     "opening_price" => x3,
        #                     "close_price" => x4,
        #                     "low_price" => x5,
        #                     "high_price" => x6,
        #                     "focus" => x7,
        #                     "amplitude" => x8,
        #                     "amplitude_rate" => x9,
        #                     "opening_price_Standardization" => x10,
        #                     "closing_price_Standardization" => x11,
        #                     "low_price_Standardization" => x12,
        #                     "high_price_Standardization" => x13,
        #                     "turnover_volume_growth_rate" => x14,
        #                     "opening_price_growth_rate" => x15,
        #                     "closing_price_growth_rate" => x16,
        #                     "closing_minus_opening_price_growth_rate" => x17,
        #                     "high_price_proportion" => x18,
        #                     "low_price_proportion" => x19,
        #                     "Pdata_0" => Pdata_0,
        #                     "Plower" => Plower,
        #                     "Pupper" => Pupper,
        #                     "weight" => weight
        #                     )
        #                 ),  # ::Core.Array{Core.Float64, 2} = testing_data,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
        #                 testing_data = Base.Dict{Core.String, Core.Any}(Base.string(key) => Base.Dict{Core.String, Core.Any}(
        #                     "date_transaction" => x0,
        #                     "turnover_volume" => x1,
        #                     "opening_price" => x3,
        #                     "close_price" => x4,
        #                     "low_price" => x5,
        #                     "high_price" => x6,
        #                     "focus" => x7,
        #                     "amplitude" => x8,
        #                     "amplitude_rate" => x9,
        #                     "opening_price_Standardization" => x10,
        #                     "closing_price_Standardization" => x11,
        #                     "low_price_Standardization" => x12,
        #                     "high_price_Standardization" => x13,
        #                     "turnover_volume_growth_rate" => x14,
        #                     "opening_price_growth_rate" => x15,
        #                     "closing_price_growth_rate" => x16,
        #                     "closing_minus_opening_price_growth_rate" => x17,
        #                     "high_price_proportion" => x18,
        #                     "low_price_proportion" => x19,
        #                     "Pdata_0" => Pdata_0,
        #                     "Plower" => Plower,
        #                     "Pupper" => Pupper,
        #                     "weight" => weight
        #                     )
        #                 ),  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
        #                 Pdata_0 = Core.Array{Core.Any, 1}(),  # [Core.Int64(5), Core.Float64(+0.1), Core.Float64(-0.1), Core.Float64(0.0)],  # [Pdata_0[1], Pdata_0[2], Pdata_0[3], Pdata_0[4]],  # Pdata_0, # value["Pdata_0"],
        #                 weight = Core.Array{Core.Any, 1}(),  # weight,  # value["weight"],
        #                 Plower = Core.Array{Core.Any, 1}(),  # [-Base.Inf, -Base.Inf, -Base.Inf, -Base.Inf],  # [Plower[1], Plower[2], Plower[3], Plower[4]],  # Plower, # value["Plower"],
        #                 Pupper = Core.Array{Core.Any, 1}(),  # [+Base.Inf, +Base.Inf, +Base.Inf, +Base.Inf],  # [Pupper[1], Pupper[2], Pupper[3], Pupper[4]],  # Pupper, # value["Pupper"],
        #                 MarketTiming_fit_model = MarketTiming_fit_model,
        #                 Quantitative_Indicators_Function = Quantitative_Indicators_Function,
        #                 investment_method = "Short_Selling"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
        #             );
        #             if Base.isa(MarketTiming_Parameter, Base.Dict) && Base.haskey(MarketTiming_Parameter, Base.string(key))
        #                 if Base.isa(MarketTiming_Parameter[Base.string(key)], Base.Dict)
        #                     MarketTiming_Parameter[Base.string(key)]["Short_Selling"] = return_MarketTiming[key]["Coefficient"];
        #                 end
        #             elseif Base.isa(MarketTiming_Parameter, Base.Dict) && (!Base.haskey(MarketTiming_Parameter, Base.string(key)))
        #                 MarketTiming_Parameter[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #                 MarketTiming_Parameter[Base.string(key)]["Short_Selling"] = return_MarketTiming[key]["Coefficient"];
        #             else
        #             end
        #             if Base.isa(weight_MarketTiming_Dict, Base.Dict) && Base.haskey(weight_MarketTiming_Dict, Base.string(key))
        #                 if Base.isa(weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
        #                     weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = return_MarketTiming[key]["weight_MarketTiming"]["Short_Selling"];  # 依照擇時規則交易倉位參數的存儲字典;
        #                 end
        #             elseif Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
        #                 weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #                 weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = return_MarketTiming[key]["weight_MarketTiming"]["Short_Selling"];  # 依照擇時規則交易倉位參數的存儲字典;
        #             else
        #             end
        #             if Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key))
        #                 if Base.isa(Plower_weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
        #                     Plower_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
        #                 end
        #             elseif Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key)))
        #                 Plower_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #                 Plower_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
        #             else
        #             end
        #             if Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key))
        #                 if Base.isa(Pupper_weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
        #                     Pupper_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
        #                 end
        #             elseif Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key)))
        #                 Pupper_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #                 Pupper_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
        #             else
        #             end
        #             return_MarketTiming = Core.nothing;  # 釋放内存;
        #         end
        #     end
        #     # println(MarketTiming_Parameter);
        #     # println(weight_MarketTiming_Dict);
        #     # println(Plower_weight_MarketTiming_Dict);
        #     # println(Pupper_weight_MarketTiming_Dict);
        #     MarketTiming_Pdata_0 = MarketTiming_Parameter;

        #     for (key, value) in steppingData
        #         if Base.isa(MarketTiming_Parameter, Base.Dict) && (!Base.haskey(MarketTiming_Parameter, Base.string(key)))
        #             MarketTiming_Parameter[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         if Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
        #             weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         if Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key)))
        #             Plower_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         if Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key)))
        #             Pupper_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         MarketTiming_Parameter[Base.string(key)]["Long_Position"] = [Core.Int64(5), Core.Float64(0.1), Core.Float64(-0.1), Core.Float64(0.0)];
        #         MarketTiming_Parameter[Base.string(key)]["Short_Selling"] = [Core.Int64(5), Core.Float64(0.1), Core.Float64(-0.1), Core.Float64(0.0)];
        #         weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
        #         weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
        #         Plower_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
        #         Plower_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
        #         Pupper_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
        #         Pupper_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
        #     end
        #     MarketTiming_Pdata_0 = MarketTiming_Parameter;

        #     MarketTiming_Parameter = Core.nothing;
        #     weight_MarketTiming_Dict = Core.nothing;
        #     Plower_weight_MarketTiming_Dict = Core.nothing;
        #     Pupper_weight_MarketTiming_Dict = Core.nothing;
        # end
        MarketTiming_Pdata_0 = [Core.Int64(5), Core.Float64(0.1), Core.Float64(-0.1), Core.Float64(0.0)];
    end

    # 求解擇時優化參數迭代下界的預設值;
    if (Base.typeof(MarketTiming_Plower) <: Core.Array || Base.typeof(MarketTiming_Plower) <: Base.Vector) && Core.Int64(Base.length(MarketTiming_Plower)) === Core.Int64(0)
        # if Base.isa(steppingData, Base.Dict) && Core.Int64(Base.length(steppingData)) > Core.Int64(0)
        #     # 優化求解擇時參數;
        #     MarketTiming_Parameter = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則優化之後得到的擇時規則的輸入參數存儲字典;
        #     weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
        #     Plower_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();
        #     Pupper_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();
        #     for (key, value) in steppingData
        #         if Base.isa(MarketTiming_Parameter, Base.Dict) && (!Base.haskey(MarketTiming_Parameter, Base.string(key)))
        #             MarketTiming_Parameter[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         if Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
        #             weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         if Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key)))
        #             Plower_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         if Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key)))
        #             Pupper_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         MarketTiming_Parameter[Base.string(key)]["Long_Position"] = [Core.Int64(5), Core.Float64(0.1), Core.Float64(-0.1), Core.Float64(0.0)];
        #         MarketTiming_Parameter[Base.string(key)]["Short_Selling"] = [Core.Int64(5), Core.Float64(0.1), Core.Float64(-0.1), Core.Float64(0.0)];
        #         weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
        #         weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
        #         Plower_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
        #         Plower_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
        #         Pupper_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
        #         Pupper_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
        #     end
        #     MarketTiming_Plower = Plower_weight_MarketTiming_Dict;
        #     MarketTiming_Parameter = Core.nothing;
        #     weight_MarketTiming_Dict = Core.nothing;
        #     Plower_weight_MarketTiming_Dict = Core.nothing;
        #     Pupper_weight_MarketTiming_Dict = Core.nothing;
        # end
        MarketTiming_Plower = [Core.Int64(1), -Base.Inf, -Base.Inf, -Base.Inf];
    end

    # 求解擇時優化參數迭代上界的預設值;
    if (Base.typeof(MarketTiming_Pupper) <: Core.Array || Base.typeof(MarketTiming_Pupper) <: Base.Vector) && Core.Int64(Base.length(MarketTiming_Pupper)) === Core.Int64(0)
        # if Base.isa(steppingData, Base.Dict) && Core.Int64(Base.length(steppingData)) > Core.Int64(0)
        #     # 優化求解擇時參數;
        #     MarketTiming_Parameter = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則優化之後得到的擇時規則的輸入參數存儲字典;
        #     weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
        #     Plower_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();
        #     Pupper_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();
        #     for (key, value) in steppingData
        #         if Base.isa(MarketTiming_Parameter, Base.Dict) && (!Base.haskey(MarketTiming_Parameter, Base.string(key)))
        #             MarketTiming_Parameter[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         if Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
        #             weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         if Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key)))
        #             Plower_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         if Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key)))
        #             Pupper_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         MarketTiming_Parameter[Base.string(key)]["Long_Position"] = [Core.Int64(5), Core.Float64(0.1), Core.Float64(-0.1), Core.Float64(0.0)];
        #         MarketTiming_Parameter[Base.string(key)]["Short_Selling"] = [Core.Int64(5), Core.Float64(0.1), Core.Float64(-0.1), Core.Float64(0.0)];
        #         weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
        #         weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
        #         Plower_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
        #         Plower_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
        #         Pupper_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
        #         Pupper_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
        #     end
        #     MarketTiming_Pupper = Pupper_weight_MarketTiming_Dict;
        #     MarketTiming_Parameter = Core.nothing;
        #     weight_MarketTiming_Dict = Core.nothing;
        #     Plower_weight_MarketTiming_Dict = Core.nothing;
        #     Pupper_weight_MarketTiming_Dict = Core.nothing;
        # end
        MarketTiming_Pupper = [Core.Int64([if (Core.Int64(maximum_dates_transaction) > Core.Int64(0)) Core.Int64(maximum_dates_transaction) else Core.Int64(1) end for i in Core.Int64(1):Core.Int64(1)][Core.Int64(1)]), +Base.Inf, +Base.Inf, +Base.Inf];
    end

    # 求解選股優化參數迭代初始值的預設值;
    if (Base.typeof(PickStock_Pdata_0) <: Core.Array || Base.typeof(PickStock_Pdata_0) <: Base.Vector) && Core.Int64(Base.length(PickStock_Pdata_0)) === Core.Int64(0)
        # if Base.isa(steppingData, Base.Dict) && Core.Int64(Base.length(steppingData)) > Core.Int64(0)
        #     # 優化求解選股參數;
        #     PickStock_Parameter = Base.Dict{Core.String, Core.Any}();  # 依照選股規則優化之後得到的選股規則的輸入參數存儲字典;
        #     PickStock_ticker_symbol = Core.Array{Core.Any, 1}();  # Core.Array{Core.Array{Core.String, 1}, 1}();
        #     weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
        #     Plower_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
        #     Pupper_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();

        #     # investment_method = "Long_Position"
        #     return_PickStock = PickStock(
        #         training_data = steppingData,  # ::Core.Array{Core.Float64, 2} = testing_data,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
        #         testing_data = steppingData,  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
        #         Pdata_0 = Core.Array{Core.Any, 1}(),  # [Core.Int64(5), Core.Int64(3)],  # [Pdata_0[1], Pdata_0[2]],  # Pdata_0, # value["Pdata_0"],
        #         weight = Core.Array{Core.Any, 1}(),  # weight,  # value["weight"],
        #         Plower = Core.Array{Core.Any, 1}(),  # [-Base.Inf, -Base.Inf],  # [Plower[1], Plower[2]],  # Plower, # value["Plower"],
        #         Pupper = Core.Array{Core.Any, 1}(),  # [+Base.Inf, +Base.Inf],  # [Pupper[1], Pupper[2]],  # Pupper, # value["Pupper"],
        #         MarketTiming_Parameter = Base.Dict{Core.String, Core.Any}(),  # weight_MarketTiming_Dict,  # MarketTiming_Pdata_0,  # MarketTiming_Parameter,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
        #         PickStock_fit_model = PickStock_fit_model,
        #         MarketTiming = MarketTiming,
        #         MarketTiming_fit_model = MarketTiming_fit_model,
        #         Quantitative_Indicators_Function = Quantitative_Indicators_Function,
        #         investment_method = "Long_Position"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
        #     );
        #     # println("optimization - coefficient : ", return_PickStock["Coefficient"]);  # 最優化計算之後得到的參數;
        #     # println("optimization - coefficient StandardDeviation : ", return_PickStock["Coefficient-StandardDeviation"]);  # 擬合得到的參數解的標準差;
        #     # println("optimization - coefficient Confidence Lower 95% : ", return_PickStock["Coefficient-Confidence-Lower-95%"]);  # 擬合得到的參數解的區間估計下限;
        #     # println("optimization - coefficient Confidence Upper 95% : ", return_PickStock["Coefficient-Confidence-Upper-95%"]);  # 擬合得到的參數解的區間估計上限;
        #     # println("y - fit : ", return_PickStock["Yfit"]);  # 擬合 y 值;
        #     # println("y - fit Uncertainty Lower : ", return_PickStock["Yfit-Uncertainty-Lower"]);  # 擬合的應變量 Yvals 誤差下限;
        #     # println("y - fit Uncertainty Upper : ", return_PickStock["Yfit-Uncertainty-Upper"]);  # 擬合的應變量 Yvals 誤差上限;
        #     # println("residual : ", return_PickStock["Residual"]);  # 擬合殘差;
        #     # println("optimization - y_profit : ", return_PickStock["y_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
        #     # println("Long Position optimization - y_profit : ", return_PickStock["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
        #     # println("Short Selling optimization - y_profit : ", return_PickStock["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
        #     # println("optimization - y_loss : ", return_PickStock["y_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
        #     # println("Long Position optimization - y_loss : ", return_PickStock["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
        #     # println("Short Selling optimization - y_loss : ", return_PickStock["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
        #     # println("maximum_drawdown : ", return_PickStock["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
        #     # println("maximum_drawdown_Long_Position : ", return_PickStock["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
        #     # println("maximum_drawdown_Short_Selling : ", return_PickStock["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
        #     # println("profit total per share : ", return_PickStock["profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
        #     # println("Long Position profit total per share : ", return_PickStock["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
        #     # println("Short Selling profit total per share : ", return_PickStock["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
        #     # println("profit Positive : ", return_PickStock["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
        #     # println("Long Position profit Positive : ", return_PickStock["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
        #     # println("Short Selling_profit Positive : ", return_PickStock["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
        #     # println("profit Positive probability : ", return_PickStock["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
        #     # println("Long Position profit Positive probability : ", return_PickStock["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
        #     # println("Short Selling profit Positive probability : ", return_PickStock["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
        #     # println("profit Negative : ", return_PickStock["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
        #     # println("Long Position profit Negative : ", return_PickStock["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
        #     # println("Short Selling profit Negative : ", return_PickStock["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
        #     # println("profit Negative probability : ", return_PickStock["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
        #     # println("Long Position profit Negative probability : ", return_PickStock["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
        #     # println("Short Selling profit Negative probability : ", return_PickStock["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
        #     # println("average price amplitude date transaction : ", return_PickStock["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
        #     # println("Long Position average price amplitude date transaction : ", return_PickStock["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
        #     # println("Short Selling average price amplitude date transaction : ", return_PickStock["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
        #     # println("average volume turnover date transaction : ", return_PickStock["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
        #     # println("Long Position average volume turnover date transaction : ", return_PickStock["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
        #     # println("Short Selling average volume turnover date transaction : ", return_PickStock["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
        #     # println("average date transaction between : ", return_PickStock["average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
        #     # println("Long Position average date transaction between : ", return_PickStock["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
        #     # println("Short Selling average date transaction between : ", return_PickStock["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
        #     # println("number PickStock transaction : ", return_PickStock["number_PickStock_transaction"]);  # 交易過股票的總隻數，函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
        #     # println("weight_PickStock : ", return_PickStock["weight_PickStock"]);  # 選股權重，每隻股票的盈利概率占比;
        #     # println("pick stock sort ticker symbol : ", return_PickStock["PickStock_sort"]["ticker_symbol"]);  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;
        #     # println("pick stock sort score : ", return_PickStock["PickStock_sort"]["score"]);  # 依照選股規則排序篩選出的股票得分值存儲數組;
        #     # println(return_PickStock["PickStock_transaction_sequence"]);  # 記錄按規則篩選股票按照擇時規則交易信息的序列字典（Dict）;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]);  # 記錄按規則篩選股票按照擇時規則交易信息的序列字典（Dict）;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
        #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
        #     # println("test profit estimate : ", return_PickStock["test_profit"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
        #     # println("test odds ratio estimate : ", return_PickStock["test_odds_ratio"]);
        #     # println("test date transaction between : ", return_PickStock["test_date_transaction_between"]);
        #     # # println(return_PickStock["testData"]);;  # 傳入測試數據集的計算結果;
        #     # println("test profit total per share : ", return_PickStock["testData"]["profit_total"]);
        #     # println("test Long Position profit total per share : ", return_PickStock["testData"]["Long_Position_profit_total"]);
        #     # println("test Short Selling profit total per share : ", return_PickStock["testData"]["Short_Selling_profit_total"]);
        #     # println("test profit positive per share : ", return_PickStock["testData"]["profit_Positive"]);
        #     # println("test Long Position profit positive per share : ", return_PickStock["testData"]["Long_Position_profit_Positive"]);
        #     # println("test Short Selling profit positive per share : ", return_PickStock["testData"]["Short_Selling_profit_Positive"]);
        #     # println("test profit positive probability : ", return_PickStock["testData"]["profit_Positive_probability"]);
        #     # println("test Long Position profit positive probability : ", return_PickStock["testData"]["Long_Position_profit_Positive_probability"]);
        #     # println("test Short Selling profit positive probability : ", return_PickStock["testData"]["Short_Selling_profit_Positive_probability"]);
        #     # println("test profit negative per share : ", return_PickStock["testData"]["profit_Negative"]);
        #     # println("test Long Position profit negative per share : ", return_PickStock["testData"]["Long_Position_profit_Negative"]);
        #     # println("test Short Selling profit negative per share : ", return_PickStock["testData"]["Short_Selling_profit_Negative"]);
        #     # println("test profit negative probability : ", return_PickStock["testData"]["profit_Negative_probability"]);
        #     # println("test Long Position profit negative probability : ", return_PickStock["testData"]["Long_Position_profit_Negative_probability"]);
        #     # println("test Short Selling profit negative probability : ", return_PickStock["testData"]["Short_Selling_profit_Negative_probability"]);
        #     # println("test average date transaction between : ", return_PickStock["testData"]["average_date_transaction_between"]);
        #     # println("test Long Position average date transaction between : ", return_PickStock["testData"]["Long_Position_average_date_transaction_between"]);
        #     # println("test Short Selling average date transaction between : ", return_PickStock["testData"]["Short_Selling_average_date_transaction_between"]);
        #     # println("test number_PickStock_transaction : ", return_PickStock["testData"]["number_PickStock_transaction"]);  # 交易過股票的總隻數;
        #     # # println(return_PickStock["testData"]["PickStock_transaction_sequence"]["002611"]["P1_Array"]);
        #     # # println(return_PickStock["testData"]["PickStock_transaction_sequence"]["002611"]["Long_Position_date_transaction"]);
        #     # # println(return_PickStock["testData"]["PickStock_transaction_sequence"]["002611"]["Short_Selling_date_transaction"]);
        #     # # println(return_PickStock["testData"]["PickStock_transaction_sequence"]["002611"]);
        #     # PickStock_Parameter = Base.Dict{Core.String, Core.Any}();
        #     PickStock_Parameter["Long_Position"] = return_PickStock["Coefficient"];
        #     PickStock_ticker_symbol = return_PickStock["PickStock_sort"]["ticker_symbol"];  # Core.Array{Core.Any, 1}();  # Core.Array{Core.Array{Core.String, 1}, 1}();
        #     for (key, value) in return_PickStock["weight_PickStock"]
        #         # println("Key: $key, Value: $value");
        #         if Base.isa(value, Base.Dict) && Base.haskey(value, "Long_Position")
        #             if Base.isa(weight_PickStock_Dict, Base.Dict) && Base.haskey(weight_PickStock_Dict, Base.string(key))
        #                 if Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict)
        #                     weight_PickStock_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
        #                 end
        #             elseif Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
        #                 weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #                 weight_PickStock_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
        #             else
        #             end
        #             if Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && Base.haskey(Plower_weight_PickStock_Dict, Base.string(key))
        #                 if Base.isa(Plower_weight_PickStock_Dict[Base.string(key)], Base.Dict)
        #                     Plower_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
        #                 end
        #             elseif Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Plower_weight_PickStock_Dict, Base.string(key)))
        #                 Plower_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #                 Plower_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
        #             else
        #             end
        #             if Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key))
        #                 if Base.isa(Pupper_weight_PickStock_Dict[Base.string(key)], Base.Dict)
        #                     Pupper_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
        #                 end
        #             elseif Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key)))
        #                 Pupper_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #                 Pupper_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
        #             else
        #             end
        #         end
        #     end
        #     return_PickStock = Core.nothing;  # 釋放内存;
        #     # investment_method = "Short_Selling"
        #     return_PickStock = PickStock(
        #         training_data = steppingData,  # ::Core.Array{Core.Float64, 2} = testing_data,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
        #         testing_data = steppingData,  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
        #         Pdata_0 = Core.Array{Core.Any, 1}(),  # [Core.Int64(5), Core.Int64(3)],  # [Pdata_0[1], Pdata_0[2]],  # Pdata_0, # value["Pdata_0"],
        #         weight = Core.Array{Core.Any, 1}(),  # weight,  # value["weight"],
        #         Plower = Core.Array{Core.Any, 1}(),  # [-Base.Inf, -Base.Inf],  # [Plower[1], Plower[2]],  # Plower, # value["Plower"],
        #         Pupper = Core.Array{Core.Any, 1}(),  # [+Base.Inf, +Base.Inf],  # [Pupper[1], Pupper[2]],  # Pupper, # value["Pupper"],
        #         MarketTiming_Parameter = Base.Dict{Core.String, Core.Any}(),  # weight_MarketTiming_Dict,  # MarketTiming_Pdata_0,  # MarketTiming_Parameter,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
        #         PickStock_fit_model = PickStock_fit_model,
        #         MarketTiming = MarketTiming,
        #         MarketTiming_fit_model = MarketTiming_fit_model,
        #         Quantitative_Indicators_Function = Quantitative_Indicators_Function,
        #         investment_method = "Short_Selling"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
        #     );
        #     PickStock_Parameter["Short_Selling"] = return_PickStock["Coefficient"];
        #     PickStock_ticker_symbol = return_PickStock["PickStock_sort"]["ticker_symbol"];
        #     for (key, value) in return_PickStock["weight_PickStock"]
        #         # println("Key: $key, Value: $value");
        #         if Base.isa(value, Base.Dict) && Base.haskey(value, "Short_Selling")
        #             if Base.isa(weight_PickStock_Dict, Base.Dict) && Base.haskey(weight_PickStock_Dict, Base.string(key))
        #                 if Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict)
        #                     weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
        #                 end
        #             elseif Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
        #                 weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #                 weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
        #             else
        #             end
        #             if Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && Base.haskey(Plower_weight_PickStock_Dict, Base.string(key))
        #                 if Base.isa(Plower_weight_PickStock_Dict[Base.string(key)], Base.Dict)
        #                     Plower_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
        #                 end
        #             elseif Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Plower_weight_PickStock_Dict, Base.string(key)))
        #                 Plower_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #                 Plower_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
        #             else
        #             end
        #             if Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key))
        #                 if Base.isa(Pupper_weight_PickStock_Dict[Base.string(key)], Base.Dict)
        #                     Pupper_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
        #                 end
        #             elseif Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key)))
        #                 Pupper_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #                 Pupper_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
        #             else
        #             end
        #         end
        #     end
        #     return_PickStock = Core.nothing;  # 釋放内存;
        #     # println(PickStock_Parameter);
        #     # println(PickStock_ticker_symbol);
        #     # println(weight_PickStock_Dict);
        #     # println(Plower_weight_PickStock_Dict);
        #     # println(Pupper_weight_PickStock_Dict);
        #     PickStock_Pdata_0 = PickStock_Parameter;

        #     PickStock_Parameter["Long_Position"] = [Core.Int64(5), Core.Int64(3)];
        #     PickStock_Parameter["Short_Selling"] = [Core.Int64(5), Core.Int64(3)];
        #     PickStock_ticker_symbol = [[Base.string(item) for item in Base.keys(steppingData)] for i = Core.Int64(1):Core.Int64(maximum_dates_transaction)];
        #     for (key, value) in steppingData
        #         if Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
        #             weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         if Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Plower_weight_PickStock_Dict, Base.string(key)))
        #             Plower_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         if Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key)))
        #             Pupper_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(Core.Int64(1) / Core.Int64(Base.length(Base.keys(steppingData))));
        #         Plower_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
        #         Pupper_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
        #         weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(Core.Int64(1) / Core.Int64(Base.length(Base.keys(steppingData))));
        #         Plower_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
        #         Pupper_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
        #     end
        #     PickStock_Pdata_0 = PickStock_Parameter;

        #     PickStock_Parameter = Core.nothing;
        #     PickStock_ticker_symbol = Core.nothing;
        #     weight_PickStock_Dict = Core.nothing;
        #     Plower_weight_PickStock_Dict = Core.nothing;
        #     Pupper_weight_PickStock_Dict = Core.nothing;
        # end
        PickStock_Pdata_0 = [Core.Int64(5), Core.Int64(3)];
    end

    # 求解選股優化參數迭代下界的預設值;
    if (Base.typeof(PickStock_Plower) <: Core.Array || Base.typeof(PickStock_Plower) <: Base.Vector) && Core.Int64(Base.length(PickStock_Plower)) === Core.Int64(0)
        # if Base.isa(steppingData, Base.Dict) && Core.Int64(Base.length(steppingData)) > Core.Int64(0)
        #     # 優化求解選股參數;
        #     PickStock_Parameter = Base.Dict{Core.String, Core.Any}();  # 依照選股規則優化之後得到的選股規則的輸入參數存儲字典;
        #     PickStock_ticker_symbol = Core.Array{Core.Any, 1}();  # Core.Array{Core.Array{Core.String, 1}, 1}();
        #     weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
        #     Plower_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
        #     Pupper_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
        #     PickStock_Parameter["Long_Position"] = [Core.Int64(5), Core.Int64(3)];
        #     PickStock_Parameter["Short_Selling"] = [Core.Int64(5), Core.Int64(3)];
        #     PickStock_ticker_symbol = [[Base.string(item) for item in Base.keys(steppingData)] for i = Core.Int64(1):Core.Int64(maximum_dates_transaction)];
        #     for (key, value) in steppingData
        #         if Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
        #             weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         if Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Plower_weight_PickStock_Dict, Base.string(key)))
        #             Plower_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         if Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key)))
        #             Pupper_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(Core.Int64(1) / Core.Int64(Base.length(Base.keys(steppingData))));
        #         Plower_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
        #         Pupper_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
        #         weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(Core.Int64(1) / Core.Int64(Base.length(Base.keys(steppingData))));
        #         Plower_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
        #         Pupper_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
        #     end
        #     PickStock_Plower = Plower_weight_PickStock_Dict;
        #     PickStock_Parameter = Core.nothing;
        #     PickStock_ticker_symbol = Core.nothing;
        #     weight_PickStock_Dict = Core.nothing;
        #     Plower_weight_PickStock_Dict = Core.nothing;
        #     Pupper_weight_PickStock_Dict = Core.nothing;
        # end
        PickStock_Plower = [Core.Int64(1), Core.Int64(1)];
    end

    # 求解選股優化參數迭代上界的預設值;
    if (Base.typeof(PickStock_Pupper) <: Core.Array || Base.typeof(PickStock_Pupper) <: Base.Vector) && Core.Int64(Base.length(PickStock_Pupper)) === Core.Int64(0)
        # if Base.isa(steppingData, Base.Dict) && Core.Int64(Base.length(steppingData)) > Core.Int64(0)
        #     # 優化求解選股參數;
        #     PickStock_Parameter = Base.Dict{Core.String, Core.Any}();  # 依照選股規則優化之後得到的選股規則的輸入參數存儲字典;
        #     PickStock_ticker_symbol = Core.Array{Core.Any, 1}();  # Core.Array{Core.Array{Core.String, 1}, 1}();
        #     weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
        #     Plower_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
        #     Pupper_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
        #     PickStock_Parameter["Long_Position"] = [Core.Int64(5), Core.Int64(3)];
        #     PickStock_Parameter["Short_Selling"] = [Core.Int64(5), Core.Int64(3)];
        #     PickStock_ticker_symbol = [[Base.string(item) for item in Base.keys(steppingData)] for i = Core.Int64(1):Core.Int64(maximum_dates_transaction)];
        #     for (key, value) in steppingData
        #         if Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
        #             weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         if Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Plower_weight_PickStock_Dict, Base.string(key)))
        #             Plower_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         if Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key)))
        #             Pupper_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
        #         end
        #         weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(Core.Int64(1) / Core.Int64(Base.length(Base.keys(steppingData))));
        #         Plower_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
        #         Pupper_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
        #         weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(Core.Int64(1) / Core.Int64(Base.length(Base.keys(steppingData))));
        #         Plower_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
        #         Pupper_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
        #     end
        #     PickStock_Pupper = Pupper_weight_PickStock_Dict;
        #     PickStock_Parameter = Core.nothing;
        #     PickStock_ticker_symbol = Core.nothing;
        #     weight_PickStock_Dict = Core.nothing;
        #     Plower_weight_PickStock_Dict = Core.nothing;
        #     Pupper_weight_PickStock_Dict = Core.nothing;
        # end
        PickStock_Pupper = [Core.Int64([if (Core.Int64(maximum_dates_transaction) > Core.Int64(0)) Core.Int64(maximum_dates_transaction) else Core.Int64(1) end for i in Core.Int64(1):Core.Int64(1)][Core.Int64(1)]), Core.Int64([if (Core.Int64(maximum_ticker_symbol_transaction) > Core.Int64(0)) Core.Int64(maximum_ticker_symbol_transaction) else Core.Int64(1) end for i in Core.Int64(1):Core.Int64(1)][Core.Int64(1)])];
    end

    # 求解倉位優化參數迭代初始值的預設值;
    if (Base.typeof(SizePosition_Pdata_0) <: Core.Array || Base.typeof(SizePosition_Pdata_0) <: Base.Vector) && Core.Int64(Base.length(SizePosition_Pdata_0)) === Core.Int64(0)
        if Base.isa(steppingData, Base.Dict) && Core.Int64(Base.length(steppingData)) > Core.Int64(0)

            SizePosition_Parameter_Array = Core.Array{Core.Any, 1}();  # 依照倉位規則優化之後得到的倉位數據存儲字典;
            weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
            weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;

            # # investment_method = "Long_Position"
            # return_SizePosition = SizePosition(
            #     training_data = steppingData,  # ::Core.Array{Core.Float64, 2} = testing_data,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
            #     testing_data = steppingData,  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
            #     Pdata_0 = Core.Array{Core.Any, 1}(),  # [MarketTiming_Pdata_0, PickStock_Pdata_0],  # [weight_MarketTiming_Dict, weight_PickStock_Dict],  # training_data["002611"]["Pdata_0"],
            #     weight = Core.Array{Core.Any, 1}(),  # training_data["002611"]["weight"],
            #     Plower = Core.Array{Core.Any, 1}(),  # [MarketTiming_Plower, PickStock_Plower],  # [Plower_weight_MarketTiming_Dict, Plower_weight_PickStock_Dict],
            #     Pupper = Core.Array{Core.Any, 1}(),  # [MarketTiming_Pupper, PickStock_Pupper],  # [Pupper_weight_MarketTiming_Dict, Pupper_weight_PickStock_Dict],
            #     MarketTiming_Parameter = Base.Dict{Core.String, Core.Any}(),  # weight_MarketTiming_Dict,  # MarketTiming_Parameter,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
            #     PickStock_Parameter = Base.Dict{Core.String, Core.Any}(),  # weight_PickStock_Dict,  # PickStock_Parameter,  # 按照選股規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
            #     PickStock_ticker_symbol = [[Base.string(item) for item in Base.keys(steppingData)] for i = Core.Int64(1):Core.Int64(maximum_dates_transaction)],  # PickStock_ticker_symbol,  # Core.Array{Core.Any, 1}(),  # ::Core.Array{Core.Array{Core.String, 1}, 1} = Core.Array{Core.Array{Core.String, 1}, 1}(),  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;
            #     SizePosition_fit_model = SizePosition_fit_model,
            #     PickStock = PickStock,
            #     PickStock_fit_model = PickStock_fit_model,
            #     MarketTiming = MarketTiming,
            #     MarketTiming_fit_model = MarketTiming_fit_model,
            #     Quantitative_Indicators_Function = Quantitative_Indicators_Function,
            #     investment_method = "Long_Position"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
            # );
            # # println("optimization - coefficient 1 - weight_MarketTiming :", "\n", return_SizePosition["Coefficient"][1], "\n", "optimization - coefficient 2 - weight_PickStock :", "\n", return_SizePosition["Coefficient"][2]);  # 最優化計算之後得到的參數;
            # # # println("optimization - coefficient StandardDeviation : ", return_SizePosition["Coefficient-StandardDeviation"]);  # 擬合得到的參數解的標準差;
            # # # println("optimization - coefficient Confidence Lower 95% : ", return_SizePosition["Coefficient-Confidence-Lower-95%"]);  # 擬合得到的參數解的區間估計下限;
            # # # println("optimization - coefficient Confidence Upper 95% : ", return_SizePosition["Coefficient-Confidence-Upper-95%"]);  # 擬合得到的參數解的區間估計上限;
            # # # println("y - fit : ", return_SizePosition["Yfit"]);  # 擬合 y 值;
            # # # println("y - fit Uncertainty Lower : ", return_SizePosition["Yfit-Uncertainty-Lower"]);  # 擬合的應變量 Yvals 誤差下限;
            # # # println("y - fit Uncertainty Upper : ", return_SizePosition["Yfit-Uncertainty-Upper"]);  # 擬合的應變量 Yvals 誤差上限;
            # # # println("residual : ", return_SizePosition["Residual"]);  # 擬合殘差;
            # # println("optimization - y_profit : ", return_SizePosition["y_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
            # # println("Long Position optimization - y_profit : ", return_SizePosition["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
            # # println("Short Selling optimization - y_profit : ", return_SizePosition["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
            # # println("optimization - y_loss : ", return_SizePosition["y_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
            # # println("Long Position optimization - y_loss : ", return_SizePosition["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
            # # println("Short Selling optimization - y_loss : ", return_SizePosition["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
            # # println("maximum_drawdown : ", return_SizePosition["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
            # # println("maximum_drawdown_Long_Position : ", return_SizePosition["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
            # # println("maximum_drawdown_Short_Selling : ", return_SizePosition["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
            # # println("profit total per share : ", return_SizePosition["profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
            # # println("Long Position profit total per share : ", return_SizePosition["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
            # # println("Short Selling profit total per share : ", return_SizePosition["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
            # # println("profit Positive : ", return_SizePosition["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
            # # println("Long Position profit Positive : ", return_SizePosition["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
            # # println("Short Selling_profit Positive : ", return_SizePosition["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
            # # println("profit Positive probability : ", return_SizePosition["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
            # # println("Long Position profit Positive probability : ", return_SizePosition["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
            # # println("Short Selling profit Positive probability : ", return_SizePosition["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
            # # println("profit Negative : ", return_SizePosition["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
            # # println("Long Position profit Negative : ", return_SizePosition["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
            # # println("Short Selling profit Negative : ", return_SizePosition["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
            # # println("profit Negative probability : ", return_SizePosition["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
            # # println("Long Position profit Negative probability : ", return_SizePosition["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
            # # println("Short Selling profit Negative probability : ", return_SizePosition["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
            # # println("average price amplitude date transaction : ", return_SizePosition["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
            # # println("Long Position average price amplitude date transaction : ", return_SizePosition["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
            # # println("Short Selling average price amplitude date transaction : ", return_SizePosition["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
            # # println("average volume turnover date transaction : ", return_SizePosition["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
            # # println("Long Position average volume turnover date transaction : ", return_SizePosition["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
            # # println("Short Selling average volume turnover date transaction : ", return_SizePosition["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
            # # println("average date transaction between : ", return_SizePosition["average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
            # # println("Long Position average date transaction between : ", return_SizePosition["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
            # # println("Short Selling average date transaction between : ", return_SizePosition["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
            # # println("number SizePosition transaction : ", return_SizePosition["number_PickStock_transaction"]);  # 交易過股票的總隻數，函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]);  # 記錄按規則篩選股票按照擇時規則交易信息的序列字典（Dict）;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]);  # 記錄按規則篩選股票按照擇時規則交易信息的序列字典（Dict）;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
            # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
            # # println("test profit estimate : ", return_SizePosition["test_profit"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
            # # println("test odds ratio estimate : ", return_SizePosition["test_odds_ratio"]);
            # # println("test date transaction between : ", return_SizePosition["test_date_transaction_between"]);
            # # # println(return_SizePosition["testData"]);;  # 傳入測試數據集的計算結果;
            # # println("test profit total per share : ", return_SizePosition["testData"]["profit_total"]);
            # # println("test Long Position profit total per share : ", return_SizePosition["testData"]["Long_Position_profit_total"]);
            # # println("test Short Selling profit total per share : ", return_SizePosition["testData"]["Short_Selling_profit_total"]);
            # # println("test profit positive per share : ", return_SizePosition["testData"]["profit_Positive"]);
            # # println("test Long Position profit positive per share : ", return_SizePosition["testData"]["Long_Position_profit_Positive"]);
            # # println("test Short Selling profit positive per share : ", return_SizePosition["testData"]["Short_Selling_profit_Positive"]);
            # # println("test profit positive probability : ", return_SizePosition["testData"]["profit_Positive_probability"]);
            # # println("test Long Position profit positive probability : ", return_SizePosition["testData"]["Long_Position_profit_Positive_probability"]);
            # # println("test Short Selling profit positive probability : ", return_SizePosition["testData"]["Short_Selling_profit_Positive_probability"]);
            # # println("test profit negative per share : ", return_SizePosition["testData"]["profit_Negative"]);
            # # println("test Long Position profit negative per share : ", return_SizePosition["testData"]["Long_Position_profit_Negative"]);
            # # println("test Short Selling profit negative per share : ", return_SizePosition["testData"]["Short_Selling_profit_Negative"]);
            # # println("test profit negative probability : ", return_SizePosition["testData"]["profit_Negative_probability"]);
            # # println("test Long Position profit negative probability : ", return_SizePosition["testData"]["Long_Position_profit_Negative_probability"]);
            # # println("test Short Selling profit negative probability : ", return_SizePosition["testData"]["Short_Selling_profit_Negative_probability"]);
            # # println("test average date transaction between : ", return_SizePosition["testData"]["average_date_transaction_between"]);
            # # println("test Long Position average date transaction between : ", return_SizePosition["testData"]["Long_Position_average_date_transaction_between"]);
            # # println("test Short Selling average date transaction between : ", return_SizePosition["testData"]["Short_Selling_average_date_transaction_between"]);
            # # println("test number SizePosition transaction : ", return_SizePosition["testData"]["number_PickStock_transaction"]);  # 交易過股票的總隻數;
            # # # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]["P1_Array"]);
            # # # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"]);
            # # # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"]);
            # # # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]);
            # # weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
            # # weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
            # if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 1 && Base.isa(return_SizePosition["Coefficient"][1], Base.Dict)
            #     for (key, value) in return_SizePosition["Coefficient"][1]
            #         # println("Key: $key, Value: $value");
            #         if Base.isa(value, Base.Dict) && Base.haskey(value, "Long_Position")
            #             if Base.isa(weight_MarketTiming_Dict, Base.Dict) && Base.haskey(weight_MarketTiming_Dict, Base.string(key))
            #                 if Base.isa(weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
            #                     weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
            #                 end
            #             elseif Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
            #                 weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
            #                 weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
            #             else
            #             end
            #         end
            #     end
            # end
            # if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 2 && Base.isa(return_SizePosition["Coefficient"][2], Base.Dict)
            #     for (key, value) in return_SizePosition["Coefficient"][2]
            #         # println("Key: $key, Value: $value");
            #         if Base.isa(value, Base.Dict) && Base.haskey(value, "Long_Position")
            #             if Base.isa(weight_PickStock_Dict, Base.Dict) && Base.haskey(weight_PickStock_Dict, Base.string(key))
            #                 if Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict)
            #                     weight_PickStock_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
            #                 end
            #             elseif Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
            #                 weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
            #                 weight_PickStock_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
            #             else
            #             end
            #         end
            #     end
            # end
            # return_SizePosition = Core.nothing;  # 釋放内存;
            # # investment_method = "Short_Selling"
            # return_SizePosition = SizePosition(
            #     training_data = steppingData,  # ::Core.Array{Core.Float64, 2} = testing_data,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
            #     testing_data = steppingData,  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
            #     Pdata_0 = Core.Array{Core.Any, 1}(),  # [MarketTiming_Pdata_0, PickStock_Pdata_0],  # [weight_MarketTiming_Dict, weight_PickStock_Dict],  # training_data["002611"]["Pdata_0"],
            #     weight = Core.Array{Core.Any, 1}(),  # training_data["002611"]["weight"],
            #     Plower = Core.Array{Core.Any, 1}(),  # [MarketTiming_Plower, PickStock_Plower],  # [Plower_weight_MarketTiming_Dict, Plower_weight_PickStock_Dict],
            #     Pupper = Core.Array{Core.Any, 1}(),  # [MarketTiming_Pupper, PickStock_Pupper],  # [Pupper_weight_MarketTiming_Dict, Pupper_weight_PickStock_Dict],
            #     MarketTiming_Parameter = Base.Dict{Core.String, Core.Any}(),  # weight_MarketTiming_Dict,  # MarketTiming_Parameter,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
            #     PickStock_Parameter = Base.Dict{Core.String, Core.Any}(),  # weight_PickStock_Dict,  # PickStock_Parameter,  # 按照選股規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
            #     PickStock_ticker_symbol = PickStock_ticker_symbol,  # Core.Array{Core.Any, 1}(),  # ::Core.Array{Core.Array{Core.String, 1}, 1} = Core.Array{Core.Array{Core.String, 1}, 1}(),  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;
            #     SizePosition_fit_model = SizePosition_fit_model,
            #     PickStock = PickStock,
            #     PickStock_fit_model = PickStock_fit_model,
            #     MarketTiming = MarketTiming,
            #     MarketTiming_fit_model = MarketTiming_fit_model,
            #     Quantitative_Indicators_Function = Quantitative_Indicators_Function,
            #     investment_method = "Short_Selling"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
            # );
            # if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 1 && Base.isa(return_SizePosition["Coefficient"][1], Base.Dict)
            #     for (key, value) in return_SizePosition["Coefficient"][1]
            #         # println("Key: $key, Value: $value");
            #         if Base.isa(value, Base.Dict) && Base.haskey(value, "Short_Selling")
            #             if Base.isa(weight_MarketTiming_Dict, Base.Dict) && Base.haskey(weight_MarketTiming_Dict, Base.string(key))
            #                 if Base.isa(weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
            #                     weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
            #                 end
            #             elseif Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
            #                 weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
            #                 weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
            #             else
            #             end
            #         end
            #     end
            # end
            # if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 2 && Base.isa(return_SizePosition["Coefficient"][2], Base.Dict)
            #     for (key, value) in return_SizePosition["Coefficient"][2]
            #         # println("Key: $key, Value: $value");
            #         if Base.isa(value, Base.Dict) && Base.haskey(value, "Short_Selling")
            #             if Base.isa(weight_PickStock_Dict, Base.Dict) && Base.haskey(weight_PickStock_Dict, Base.string(key))
            #                 if Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict)
            #                     weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
            #                 end
            #             elseif Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
            #                 weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
            #                 weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
            #             else
            #             end
            #         end
            #     end
            # end
            # return_SizePosition = Core.nothing;  # 釋放内存;
            # SizePosition_Parameter_Array = [weight_MarketTiming_Dict, weight_PickStock_Dict];
            # # println(SizePosition_Parameter_Array);
            # # println("optimization - coefficient 1 - weight_MarketTiming :", "\n", SizePosition_Parameter_Array[1]);  # 最優化計算之後得到的參數;
            # # println("optimization - coefficient 2 - weight_PickStock :", "\n", SizePosition_Parameter_Array[2]);  # 最優化計算之後得到的參數;
            # SizePosition_Pdata_0 = SizePosition_Parameter_Array;

            MarketTiming_Parameter = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則優化之後得到的擇時規則的輸入參數存儲字典;
            # weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
            Plower_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();
            Pupper_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();
            for (key, value) in steppingData
                if Base.isa(MarketTiming_Parameter, Base.Dict) && (!Base.haskey(MarketTiming_Parameter, Base.string(key)))
                    MarketTiming_Parameter[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                if Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
                    weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                if Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key)))
                    Plower_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                if Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key)))
                    Pupper_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                MarketTiming_Parameter[Base.string(key)]["Long_Position"] = [Core.Int64(5), Core.Float64(0.1), Core.Float64(-0.1), Core.Float64(0.0)];
                MarketTiming_Parameter[Base.string(key)]["Short_Selling"] = [Core.Int64(5), Core.Float64(0.1), Core.Float64(-0.1), Core.Float64(0.0)];
                weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
                weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
                Plower_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
                Plower_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
                Pupper_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
                Pupper_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
            end
            PickStock_Parameter = Base.Dict{Core.String, Core.Any}();  # 依照選股規則優化之後得到的選股規則的輸入參數存儲字典;
            PickStock_ticker_symbol = Core.Array{Core.Any, 1}();  # Core.Array{Core.Array{Core.String, 1}, 1}();
            # weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
            Plower_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
            Pupper_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
            PickStock_Parameter["Long_Position"] = [Core.Int64(5), Core.Int64(3)];
            PickStock_Parameter["Short_Selling"] = [Core.Int64(5), Core.Int64(3)];
            PickStock_ticker_symbol = [[Base.string(item) for item in Base.keys(steppingData)] for i = Core.Int64(1):Core.Int64(maximum_dates_transaction)];
            for (key, value) in steppingData
                if Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
                    weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                if Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Plower_weight_PickStock_Dict, Base.string(key)))
                    Plower_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                if Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key)))
                    Pupper_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(Core.Int64(1) / Core.Int64(Base.length(Base.keys(steppingData))));
                Plower_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
                Pupper_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
                weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(Core.Int64(1) / Core.Int64(Base.length(Base.keys(steppingData))));
                Plower_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
                Pupper_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
            end
            SizePosition_Parameter_Array = [weight_MarketTiming_Dict, weight_PickStock_Dict];
            SizePosition_Pdata_0 = SizePosition_Parameter_Array;
            SizePosition_Parameter_Array = Core.nothing;
            MarketTiming_Parameter = Core.nothing;
            weight_MarketTiming_Dict = Core.nothing;
            Plower_weight_MarketTiming_Dict = Core.nothing;
            Pupper_weight_MarketTiming_Dict = Core.nothing;
            PickStock_Parameter = Core.nothing;
            PickStock_ticker_symbol = Core.nothing;
            weight_PickStock_Dict = Core.nothing;
            Plower_weight_PickStock_Dict = Core.nothing;
            Pupper_weight_PickStock_Dict = Core.nothing;
        end
    end

    # 求解倉位優化參數迭代下界的預設值;
    if (Base.typeof(SizePosition_Plower) <: Core.Array || Base.typeof(SizePosition_Plower) <: Base.Vector) && Core.Int64(Base.length(SizePosition_Plower)) === Core.Int64(0)
        if Base.isa(steppingData, Base.Dict) && Core.Int64(Base.length(steppingData)) > Core.Int64(0)
            MarketTiming_Parameter = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則優化之後得到的擇時規則的輸入參數存儲字典;
            weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
            Plower_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();
            Pupper_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();
            for (key, value) in steppingData
                if Base.isa(MarketTiming_Parameter, Base.Dict) && (!Base.haskey(MarketTiming_Parameter, Base.string(key)))
                    MarketTiming_Parameter[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                if Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
                    weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                if Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key)))
                    Plower_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                if Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key)))
                    Pupper_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                MarketTiming_Parameter[Base.string(key)]["Long_Position"] = [Core.Int64(5), Core.Float64(0.1), Core.Float64(-0.1), Core.Float64(0.0)];
                MarketTiming_Parameter[Base.string(key)]["Short_Selling"] = [Core.Int64(5), Core.Float64(0.1), Core.Float64(-0.1), Core.Float64(0.0)];
                weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
                weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
                Plower_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
                Plower_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
                Pupper_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
                Pupper_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
            end
            PickStock_Parameter = Base.Dict{Core.String, Core.Any}();  # 依照選股規則優化之後得到的選股規則的輸入參數存儲字典;
            PickStock_ticker_symbol = Core.Array{Core.Any, 1}();  # Core.Array{Core.Array{Core.String, 1}, 1}();
            weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
            Plower_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
            Pupper_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
            PickStock_Parameter["Long_Position"] = [Core.Int64(5), Core.Int64(3)];
            PickStock_Parameter["Short_Selling"] = [Core.Int64(5), Core.Int64(3)];
            PickStock_ticker_symbol = [[Base.string(item) for item in Base.keys(steppingData)] for i = Core.Int64(1):Core.Int64(maximum_dates_transaction)];
            for (key, value) in steppingData
                if Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
                    weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                if Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Plower_weight_PickStock_Dict, Base.string(key)))
                    Plower_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                if Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key)))
                    Pupper_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(Core.Int64(1) / Core.Int64(Base.length(Base.keys(steppingData))));
                Plower_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
                Pupper_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
                weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(Core.Int64(1) / Core.Int64(Base.length(Base.keys(steppingData))));
                Plower_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
                Pupper_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
            end
            # SizePosition_Parameter_Array = Core.Array{Core.Any, 1}();  # 依照倉位規則優化之後得到的倉位數據存儲字典;
            SizePosition_Parameter_Array = [weight_MarketTiming_Dict, weight_PickStock_Dict];
            SizePosition_Plower = [Plower_weight_MarketTiming_Dict, Plower_weight_PickStock_Dict];
            SizePosition_Parameter_Array = Core.nothing;
            MarketTiming_Parameter = Core.nothing;
            weight_MarketTiming_Dict = Core.nothing;
            Plower_weight_MarketTiming_Dict = Core.nothing;
            Pupper_weight_MarketTiming_Dict = Core.nothing;
            PickStock_Parameter = Core.nothing;
            PickStock_ticker_symbol = Core.nothing;
            weight_PickStock_Dict = Core.nothing;
            Plower_weight_PickStock_Dict = Core.nothing;
            Pupper_weight_PickStock_Dict = Core.nothing;
        end
    end

    # 求解倉位優化參數迭代上界的預設值;
    if (Base.typeof(SizePosition_Pupper) <: Core.Array || Base.typeof(SizePosition_Pupper) <: Base.Vector) && Core.Int64(Base.length(SizePosition_Pupper)) === Core.Int64(0)
        if Base.isa(steppingData, Base.Dict) && Core.Int64(Base.length(steppingData)) > Core.Int64(0)
            MarketTiming_Parameter = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則優化之後得到的擇時規則的輸入參數存儲字典;
            weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
            Plower_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();
            Pupper_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();
            for (key, value) in steppingData
                if Base.isa(MarketTiming_Parameter, Base.Dict) && (!Base.haskey(MarketTiming_Parameter, Base.string(key)))
                    MarketTiming_Parameter[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                if Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
                    weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                if Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key)))
                    Plower_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                if Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key)))
                    Pupper_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                MarketTiming_Parameter[Base.string(key)]["Long_Position"] = [Core.Int64(5), Core.Float64(0.1), Core.Float64(-0.1), Core.Float64(0.0)];
                MarketTiming_Parameter[Base.string(key)]["Short_Selling"] = [Core.Int64(5), Core.Float64(0.1), Core.Float64(-0.1), Core.Float64(0.0)];
                weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
                weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
                Plower_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
                Plower_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
                Pupper_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
                Pupper_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
            end
            PickStock_Parameter = Base.Dict{Core.String, Core.Any}();  # 依照選股規則優化之後得到的選股規則的輸入參數存儲字典;
            PickStock_ticker_symbol = Core.Array{Core.Any, 1}();  # Core.Array{Core.Array{Core.String, 1}, 1}();
            weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
            Plower_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
            Pupper_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
            PickStock_Parameter["Long_Position"] = [Core.Int64(5), Core.Int64(3)];
            PickStock_Parameter["Short_Selling"] = [Core.Int64(5), Core.Int64(3)];
            PickStock_ticker_symbol = [[Base.string(item) for item in Base.keys(steppingData)] for i = Core.Int64(1):Core.Int64(maximum_dates_transaction)];
            for (key, value) in steppingData
                if Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
                    weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                if Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Plower_weight_PickStock_Dict, Base.string(key)))
                    Plower_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                if Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key)))
                    Pupper_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                end
                weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(Core.Int64(1) / Core.Int64(Base.length(Base.keys(steppingData))));
                Plower_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
                Pupper_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
                weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(Core.Int64(1) / Core.Int64(Base.length(Base.keys(steppingData))));
                Plower_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
                Pupper_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
            end
            # SizePosition_Parameter_Array = Core.Array{Core.Any, 1}();  # 依照倉位規則優化之後得到的倉位數據存儲字典;
            SizePosition_Parameter_Array = [weight_MarketTiming_Dict, weight_PickStock_Dict];
            SizePosition_Pupper = [Pupper_weight_MarketTiming_Dict, Pupper_weight_PickStock_Dict];
            SizePosition_Parameter_Array = Core.nothing;
            MarketTiming_Parameter = Core.nothing;
            weight_MarketTiming_Dict = Core.nothing;
            Plower_weight_MarketTiming_Dict = Core.nothing;
            Pupper_weight_MarketTiming_Dict = Core.nothing;
            PickStock_Parameter = Core.nothing;
            PickStock_ticker_symbol = Core.nothing;
            weight_PickStock_Dict = Core.nothing;
            Plower_weight_PickStock_Dict = Core.nothing;
            Pupper_weight_PickStock_Dict = Core.nothing;
        end
    end

    # 記錄推進分析交易信息的序列;
    return_stepping_Dict = Base.Dict{Core.String, Core.Any}();  # 推進分析信息和結果的存儲字典;

    # println(steppingData);
    if !(Base.isa(steppingData, Base.Dict) && Core.Int64(Base.length(steppingData)) > Core.Int64(0))
        Base.write(Base.stdout, Base.string("Error : stepping test data sequence Dictionary unrecognize .") * "\n" * Base.string("steppingData::Base.Dict{Core.String, Core.Any} .") * "\n");
        # Base.exit(0);
        return return_stepping_Dict;
    end

    # 推進分析;
    if Base.isa(steppingData, Base.Dict) && Core.Int64(Base.length(steppingData)) > Core.Int64(0)

        # # 交易過股票的總隻數，函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
        # maximum_ticker_symbol_transaction = Core.Int64(Base.length([key for key in Base.keys(steppingData)]));  # 交易過股票的總隻數;
        # # println(maximum_ticker_symbol_transaction);
        # maximum_dates_transaction = Core.Int64(0);  # 各股票裏的最長交易天數;
        # minimum_dates_transaction = Core.Int64(0);  # 各股票裏的最短交易天數;
        # dates_transaction_Array = Core.Array{Core.Int64, 1}();
        # # 遍歷字典的鍵:值對;
        # for (key, value) in steppingData
        #     # println("Key: $key, Value: $value");
        #     if Base.isa(value, Base.Dict)
        #         if Base.haskey(value, "date_transaction") && Base.typeof(value["date_transaction"]) <: Core.Array
        #             # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
        #             Base.push!(dates_transaction_Array, Core.Int64(Base.length(value["date_transaction"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

        #             # 篩選最長交易天數;
        #             if Core.Int64(Base.length(value["date_transaction"])) > Core.Int64(maximum_dates_transaction)
        #                 maximum_dates_transaction_2 = Core.Int64(Base.length(value["date_transaction"]));
        #                 # global maximum_dates_transaction *= Core.Int64(0);
        #                 maximum_dates_transaction *= Core.Int64(0);
        #                 # global maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
        #                 maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
        #             end
        #         end
        #         if Base.haskey(value, "turnover_volume") && Base.typeof(value["turnover_volume"]) <: Core.Array
        #             # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
        #             Base.push!(dates_transaction_Array, Core.Int64(Base.length(value["turnover_volume"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

        #             # 篩選最長交易天數;
        #             if Core.Int64(Base.length(value["turnover_volume"])) > Core.Int64(maximum_dates_transaction)
        #                 maximum_dates_transaction_2 = Core.Int64(Base.length(value["turnover_volume"]));
        #                 # global maximum_dates_transaction *= Core.Int64(0);
        #                 maximum_dates_transaction *= Core.Int64(0);
        #                 # global maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
        #                 maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
        #             end
        #         end
        #         if Base.haskey(value, "opening_price") && Base.typeof(value["opening_price"]) <: Core.Array
        #             # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
        #             Base.push!(dates_transaction_Array, Core.Int64(Base.length(value["opening_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

        #             # 篩選最長交易天數;
        #             if Core.Int64(Base.length(value["opening_price"])) > Core.Int64(maximum_dates_transaction)
        #                 maximum_dates_transaction_2 = Core.Int64(Base.length(value["opening_price"]));
        #                 # global maximum_dates_transaction *= Core.Int64(0);
        #                 maximum_dates_transaction *= Core.Int64(0);
        #                 # global maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
        #                 maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
        #             end
        #         end
        #         if Base.haskey(value, "close_price") && Base.typeof(value["close_price"]) <: Core.Array
        #             # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
        #             Base.push!(dates_transaction_Array, Core.Int64(Base.length(value["close_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

        #             # 篩選最長交易天數;
        #             if Core.Int64(Base.length(value["close_price"])) > Core.Int64(maximum_dates_transaction)
        #                 maximum_dates_transaction_2 = Core.Int64(Base.length(value["close_price"]));
        #                 # global maximum_dates_transaction *= Core.Int64(0);
        #                 maximum_dates_transaction *= Core.Int64(0);
        #                 # global maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
        #                 maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
        #             end
        #         end
        #         if Base.haskey(value, "low_price") && Base.typeof(value["low_price"]) <: Core.Array
        #             # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
        #             Base.push!(dates_transaction_Array, Core.Int64(Base.length(value["low_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

        #             # 篩選最長交易天數;
        #             if Core.Int64(Base.length(value["low_price"])) > Core.Int64(maximum_dates_transaction)
        #                 maximum_dates_transaction_2 = Core.Int64(Base.length(value["low_price"]));
        #                 # global maximum_dates_transaction *= Core.Int64(0);
        #                 maximum_dates_transaction *= Core.Int64(0);
        #                 # global maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
        #                 maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
        #             end
        #         end
        #         if Base.haskey(value, "high_price") && Base.typeof(value["high_price"]) <: Core.Array
        #             # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
        #             Base.push!(dates_transaction_Array, Core.Int64(Base.length(value["high_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

        #             # 篩選最長交易天數;
        #             if Core.Int64(Base.length(value["high_price"])) > Core.Int64(maximum_dates_transaction)
        #                 maximum_dates_transaction_2 = Core.Int64(Base.length(value["high_price"]));
        #                 # global maximum_dates_transaction *= Core.Int64(0);
        #                 maximum_dates_transaction *= Core.Int64(0);
        #                 # global maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
        #                 maximum_dates_transaction += Core.Int64(maximum_dates_transaction_2);
        #             end
        #         end
        #     end
        # end
        # # println(maximum_dates_transaction);
        # if Base.length(dates_transaction_Array) > 0
        #     minimum_dates_transaction_2 = Core.Int64(Base.findmin(dates_transaction_Array)[1]);
        #     minimum_dates_transaction *= Core.Int64(0);
        #     minimum_dates_transaction += Core.Int64(minimum_dates_transaction_2);
        # end
        # # println(minimum_dates_transaction);
        # dates_transaction_Array = Core.nothing;

        # 記錄每個交易日的回撤值序列;
        drawdown_Array_Long_Position = Core.Array{Core.Float64, 1}();  # 記錄做多模式每個交易日的回撤值序列;
        drawdown_Array_Short_Selling = Core.Array{Core.Float64, 1}();  # 記錄做空模式每個交易日的回撤值序列;

        # 伸縮框滑動式遍歷;
        stepping_sequence_Array = Core.Array{Core.Any, 1}();  # 記錄推進分析股票交易信息的序列;
        for i = Core.Int64(1):Core.Int64(minimum_dates_transaction)

            if Core.Int64(i) >= Core.Int64(training_data_sequence_length)

                stepping_transaction_Dict = Base.Dict{Core.String, Core.Any}();  # 記錄推進分析股票交易信息的字典;

                if Base.length(training_data_ticker_symbol_Array) > 0

                    # 截取數據序列目標區段;
                    trainingData = Base.Dict{Core.String, Core.Any}();
                    for j = Core.Int64(1):Core.Int64(Base.length(training_data_ticker_symbol_Array))
                        # 判斷當前股票代碼字符串（ticker_symbol）是否在指定數組内
                        if Base.haskey(steppingData, Base.string(training_data_ticker_symbol_Array[j])) && Base.isa(steppingData[Base.string(training_data_ticker_symbol_Array[j])], Base.Dict) && Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]) > 0
                            if (Base.haskey(steppingData[Base.string(training_data_ticker_symbol_Array[j])], "date_transaction") && Base.typeof(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["date_transaction"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(training_data_ticker_symbol_Array[j])], "turnover_volume") && Base.typeof(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["turnover_volume"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(training_data_ticker_symbol_Array[j])], "opening_price") && Base.typeof(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["opening_price"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(training_data_ticker_symbol_Array[j])], "close_price") && Base.typeof(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["close_price"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(training_data_ticker_symbol_Array[j])], "low_price") && Base.typeof(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["low_price"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(training_data_ticker_symbol_Array[j])], "high_price") && Base.typeof(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["high_price"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(training_data_ticker_symbol_Array[j])], "focus") && Base.typeof(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["focus"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(training_data_ticker_symbol_Array[j])], "amplitude") && Base.typeof(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["amplitude"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(training_data_ticker_symbol_Array[j])], "amplitude_rate") && Base.typeof(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["amplitude_rate"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(training_data_ticker_symbol_Array[j])], "opening_price_Standardization") && Base.typeof(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["opening_price_Standardization"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(training_data_ticker_symbol_Array[j])], "closing_price_Standardization") && Base.typeof(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["closing_price_Standardization"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(training_data_ticker_symbol_Array[j])], "low_price_Standardization") && Base.typeof(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["low_price_Standardization"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(training_data_ticker_symbol_Array[j])], "high_price_Standardization") && Base.typeof(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["high_price_Standardization"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(training_data_ticker_symbol_Array[j])], "turnover_volume_growth_rate") && Base.typeof(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["turnover_volume_growth_rate"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(training_data_ticker_symbol_Array[j])], "opening_price_growth_rate") && Base.typeof(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["opening_price_growth_rate"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(training_data_ticker_symbol_Array[j])], "closing_price_growth_rate") && Base.typeof(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["closing_price_growth_rate"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(training_data_ticker_symbol_Array[j])], "closing_minus_opening_price_growth_rate") && Base.typeof(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["closing_minus_opening_price_growth_rate"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(training_data_ticker_symbol_Array[j])], "high_price_proportion") && Base.typeof(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["high_price_proportion"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(training_data_ticker_symbol_Array[j])], "low_price_proportion") && Base.typeof(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["low_price_proportion"]) <: Core.Array)

                                # 判斷訓練集數據滑框尾界是否在數據序列範圍内;
                                if Core.Int64(i) <= Core.Int64(Base.findmin([Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["date_transaction"]), Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["turnover_volume"]), Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["opening_price"]), Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["close_price"]), Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["low_price"]), Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["high_price"]), Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["focus"]), Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["amplitude"]), Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["amplitude_rate"]), Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["opening_price_Standardization"]), Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["closing_price_Standardization"]), Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["low_price_Standardization"]), Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["high_price_Standardization"]), Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["turnover_volume_growth_rate"]), Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["opening_price_growth_rate"]), Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["closing_price_growth_rate"]), Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["closing_minus_opening_price_growth_rate"]), Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["high_price_proportion"]), Base.length(steppingData[Base.string(training_data_ticker_symbol_Array[j])]["low_price_proportion"])])[1])
                                    # 判斷訓練集數據滑框頭界是否在數據序列範圍内;
                                    if Core.Int64(i) >= Core.Int64(training_data_sequence_length)

                                        x0 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["date_transaction"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 交易日期;
                                        x1 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["turnover_volume"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 成交量;
                                        # x2 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["turnover_amount"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 成交總金額;
                                        x3 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["opening_price"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 開盤成交價;
                                        x4 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["close_price"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 收盤成交價;
                                        x5 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["low_price"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 最低成交價;
                                        x6 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["high_price"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 最高成交價;
                                        x7 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["focus"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 當日成交價重心;
                                        x8 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["amplitude"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 當日成交價絕對振幅;
                                        x9 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["amplitude_rate"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 當日成交價相對振幅（%）;
                                        x10 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["opening_price_Standardization"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 日棒缐（K Line Daily）數據交易日首筆成交價（開盤價）標準化值;
                                        x11 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["closing_price_Standardization"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 日棒缐（K Line Daily）數據交易日尾筆成交價（收盤價）標準化值;
                                        x12 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["low_price_Standardization"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 日棒缐（K Line Daily）數據交易日最低成交價標準化值;
                                        x13 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["high_price_Standardization"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 日棒缐（K Line Daily）數據交易日最高成交價標準化值;
                                        x14 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["turnover_volume_growth_rate"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 成交量的成長率;
                                        x15 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["opening_price_growth_rate"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 開盤價的成長率;
                                        x16 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["closing_price_growth_rate"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 收盤價的成長率;
                                        x17 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["closing_minus_opening_price_growth_rate"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 收盤價減開盤價的成長率;
                                        x18 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["high_price_proportion"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 收盤價和開盤價裏的最大值占最高價的比例;
                                        x19 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["low_price_proportion"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 最低價占收盤價和開盤價裏的最小值的比例;
                                        # x20 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["turnover_rate"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 成交量換手率;
                                        # x21 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["price_earnings"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 每股收益（公司經營利潤率 ÷ 股本）;
                                        # x22 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["book_value_per_share"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 每股净值（公司净資產 ÷ 股本）;
                                        # x23 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["capitalization"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 總市值;
                                        # x24 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["moving_average_5"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 收盤價 5 日滑動平均缐;
                                        # x25 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["moving_average_10"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 收盤價 10 日滑動平均缐;
                                        # x26 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["moving_average_20"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 收盤價 20 日滑動平均缐;
                                        # x27 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["moving_average_30"][Core.Int64(Core.Int64(i) - Core.Int64(training_data_sequence_length) + Core.Int64(1)):Core.Int64(1):Core.Int64(i)];  # 收盤價 30 日滑動平均缐;
                                        Pdata_0 = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["Pdata_0"];
                                        Plower = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["Plower"];
                                        Pupper = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["Pupper"];
                                        weight = steppingData[Base.string(training_data_ticker_symbol_Array[j])]["weight"];

                                        trainingData[Base.string(training_data_ticker_symbol_Array[j])] = Base.Dict{Core.String, Core.Any}(
                                            "date_transaction" => x0,  # 交易日期;
                                            "turnover_volume" => x1,  # 成交量;
                                            # "turnover_amount" => x2,  # 成交總金額;
                                            "opening_price" => x3,  # 開盤成交價;
                                            "close_price" => x4,  # 收盤成交價;
                                            "low_price" => x5,  # 最低成交價;
                                            "high_price" => x6,  # 最高成交價;
                                            "focus" => x7,  # 當日成交價重心;
                                            "amplitude" => x8,  # 當日成交價絕對振幅;
                                            "amplitude_rate" => x9,  # 當日成交價相對振幅（%）;
                                            "opening_price_Standardization" => x10,  # 日棒缐（K Line Daily）數據交易日首筆成交價（開盤價）標準化值;
                                            "closing_price_Standardization" => x11,  # 日棒缐（K Line Daily）數據交易日尾筆成交價（收盤價）標準化值;
                                            "low_price_Standardization" => x12,  # 日棒缐（K Line Daily）數據交易日最低成交價標準化值;
                                            "high_price_Standardization" => x13,  # 日棒缐（K Line Daily）數據交易日最高成交價標準化值;
                                            "turnover_volume_growth_rate" => x14,  # 成交量的成長率;
                                            "opening_price_growth_rate" => x15,  # 開盤價的成長率;
                                            "closing_price_growth_rate" => x16,  # 收盤價的成長率;
                                            "closing_minus_opening_price_growth_rate" => x17,  # 收盤價減開盤價的成長率;
                                            "high_price_proportion" => x18,  # 收盤價和開盤價裏的最大值占最高價的比例;
                                            "low_price_proportion" => x19,  # 最低價占收盤價和開盤價裏的最小值的比例;
                                            # "turnover_rate" => x20,  # 成交量換手率;
                                            # "price_earnings" => x21,  # 每股收益（公司經營利潤率 ÷ 股本）;
                                            # "book_value_per_share" => x22,  # 每股净值（公司净資產 ÷ 股本）;
                                            # "capitalization" => x23,  # 總市值;
                                            # "moving_average_5" => x24,  # 收盤價 5 日滑動平均缐;
                                            # "moving_average_10" => x25,  # 收盤價 10 日滑動平均缐;
                                            # "moving_average_20" => x26,  # 收盤價 20 日滑動平均缐;
                                            # "moving_average_30" => x27,  # 收盤價 30 日滑動平均缐;
                                            "Pdata_0" => Pdata_0,
                                            "Plower" => Plower,
                                            "Pupper" => Pupper,
                                            "weight" => weight
                                        );

                                        # 釋放内存;
                                        x0 = Core.nothing;
                                        x1 = Core.nothing;
                                        # x2 = Core.nothing;
                                        x3 = Core.nothing;
                                        x4 = Core.nothing;
                                        x5 = Core.nothing;
                                        x6 = Core.nothing;
                                        x7 = Core.nothing;
                                        x8 = Core.nothing;
                                        x9 = Core.nothing;
                                        x10 = Core.nothing;
                                        x11 = Core.nothing;
                                        x12 = Core.nothing;
                                        x13 = Core.nothing;
                                        x14 = Core.nothing;
                                        x15 = Core.nothing;
                                        x16 = Core.nothing;
                                        x17 = Core.nothing;
                                        x18 = Core.nothing;
                                        x19 = Core.nothing;
                                        # x20 = Core.nothing;
                                        # x21 = Core.nothing;
                                        # x22 = Core.nothing;
                                        # x23 = Core.nothing;
                                        # x24 = Core.nothing;
                                        # x25 = Core.nothing;
                                        # x26 = Core.nothing;
                                        # x27 = Core.nothing;
                                        Pdata_0 = Core.nothing;
                                        Plower = Core.nothing;
                                        Pupper = Core.nothing;
                                        weight = Core.nothing;
                                    end
                                end
                            end
                        end
                    end

                    # 依照擇時規則優化之後得到的擇時規則的輸入參數存儲字典，優化求解擇時參數;
                    MarketTiming_Parameter_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則優化之後得到的擇時規則的輸入參數存儲字典;
                    weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
                    Plower_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();
                    Pupper_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();
                    if Base.isa(trainingData, Base.Dict) && Base.length(trainingData) > 0
                        for (key, value) in trainingData
                            # println("Key: $key, Value: $value");
                            if Base.isa(value, Base.Dict) && (Base.haskey(value, "date_transaction") && Base.typeof(value["date_transaction"]) <: Core.Array) && (Base.haskey(value, "turnover_volume") && Base.typeof(value["turnover_volume"]) <: Core.Array) && (Base.haskey(value, "opening_price") && Base.typeof(value["opening_price"]) <: Core.Array) && (Base.haskey(value, "close_price") && Base.typeof(value["close_price"]) <: Core.Array) && (Base.haskey(value, "low_price") && Base.typeof(value["low_price"]) <: Core.Array) && (Base.haskey(value, "high_price") && Base.typeof(value["high_price"]) <: Core.Array) && (Base.haskey(value, "focus") && Base.typeof(value["focus"]) <: Core.Array) && (Base.haskey(value, "amplitude") && Base.typeof(value["amplitude"]) <: Core.Array) && (Base.haskey(value, "amplitude_rate") && Base.typeof(value["amplitude_rate"]) <: Core.Array) && (Base.haskey(value, "opening_price_Standardization") && Base.typeof(value["opening_price_Standardization"]) <: Core.Array) && (Base.haskey(value, "closing_price_Standardization") && Base.typeof(value["closing_price_Standardization"]) <: Core.Array) && (Base.haskey(value, "low_price_Standardization") && Base.typeof(value["low_price_Standardization"]) <: Core.Array) && (Base.haskey(value, "high_price_Standardization") && Base.typeof(value["high_price_Standardization"]) <: Core.Array) && (Base.haskey(value, "turnover_volume_growth_rate") && Base.typeof(value["turnover_volume_growth_rate"]) <: Core.Array) && (Base.haskey(value, "opening_price_growth_rate") && Base.typeof(value["opening_price_growth_rate"]) <: Core.Array) && (Base.haskey(value, "closing_price_growth_rate") && Base.typeof(value["closing_price_growth_rate"]) <: Core.Array) && (Base.haskey(value, "closing_minus_opening_price_growth_rate") && Base.typeof(value["closing_minus_opening_price_growth_rate"]) <: Core.Array) && (Base.haskey(value, "high_price_proportion") && Base.typeof(value["high_price_proportion"]) <: Core.Array) && (Base.haskey(value, "low_price_proportion") && Base.typeof(value["low_price_proportion"]) <: Core.Array)

                                # investment_method = "Long_Position"
                                return_MarketTiming = MarketTiming(
                                    training_data = Base.Dict{Core.String, Core.Any}(
                                        Base.string(key) => Base.Dict{Core.String, Core.Any}(
                                            "date_transaction" => value["date_transaction"],
                                            "turnover_volume" => value["turnover_volume"],
                                            # "turnover_amount" => value["turnover_amount"],
                                            "opening_price" => value["opening_price"],
                                            "close_price" => value["close_price"],
                                            "low_price" => value["low_price"],
                                            "high_price" => value["high_price"],
                                            "focus" => value["focus"],
                                            "amplitude" => value["amplitude"],
                                            "amplitude_rate" => value["amplitude_rate"],
                                            "opening_price_Standardization" => value["opening_price_Standardization"],
                                            "closing_price_Standardization" => value["closing_price_Standardization"],
                                            "low_price_Standardization" => value["low_price_Standardization"],
                                            "high_price_Standardization" => value["high_price_Standardization"],
                                            "turnover_volume_growth_rate" => value["turnover_volume_growth_rate"],
                                            "opening_price_growth_rate" => value["opening_price_growth_rate"],
                                            "closing_price_growth_rate" => value["closing_price_growth_rate"],
                                            "closing_minus_opening_price_growth_rate" => value["closing_minus_opening_price_growth_rate"],
                                            "high_price_proportion" => value["high_price_proportion"],
                                            "low_price_proportion" => value["low_price_proportion"],
                                            "Pdata_0" => value["Pdata_0"],
                                            "Plower" => value["Plower"],
                                            "Pupper" => value["Pupper"],
                                            "weight" => value["weight"]
                                        )
                                    ),  # ::Core.Array{Core.Float64, 2} = testingData,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
                                    # training_date_transaction = Core.Array{Dates.Date, 1}(),
                                    # training_opening_price = Core.Array{Core.Union{Core.Float64, Core.String, Core.Nothing}, 1}(),
                                    # training_close_price = Core.Array{Core.Union{Core.Float64, Core.String, Core.Nothing}, 1}(),
                                    # training_low_price = Core.Array{Core.Union{Core.Float64, Core.String, Core.Nothing}, 1}(),
                                    # training_high_price = Core.Array{Core.Union{Core.Float64, Core.String, Core.Nothing}, 1}(),
                                    # training_turnover_volume = Core.Array{Core.Union{Core.UInt64, Core.String, Core.Nothing}, 1}(),
                                    # training_turnover_rate = Core.Array{Core.Union{Core.Float64, Core.String, Core.Nothing}, 1}(),
                                    # training_price_earnings = Core.Array{Core.Union{Core.Float64, Core.String, Core.Nothing}, 1}(),
                                    testing_data = Base.Dict{Core.String, Core.Any}(
                                        Base.string(key) => Base.Dict{Core.String, Core.Any}(
                                            "date_transaction" => value["date_transaction"],
                                            "turnover_volume" => value["turnover_volume"],
                                            "opening_price" => value["opening_price"],
                                            "close_price" => value["close_price"],
                                            "low_price" => value["low_price"],
                                            "high_price" => value["high_price"],
                                            "focus" => value["focus"],
                                            "amplitude" => value["amplitude"],
                                            "amplitude_rate" => value["amplitude_rate"],
                                            "opening_price_Standardization" => value["opening_price_Standardization"],
                                            "closing_price_Standardization" => value["closing_price_Standardization"],
                                            "low_price_Standardization" => value["low_price_Standardization"],
                                            "high_price_Standardization" => value["high_price_Standardization"],
                                            "turnover_volume_growth_rate" => value["turnover_volume_growth_rate"],
                                            "opening_price_growth_rate" => value["opening_price_growth_rate"],
                                            "closing_price_growth_rate" => value["closing_price_growth_rate"],
                                            "closing_minus_opening_price_growth_rate" => value["closing_minus_opening_price_growth_rate"],
                                            "high_price_proportion" => value["high_price_proportion"],
                                            "low_price_proportion" => value["low_price_proportion"],
                                            "Pdata_0" => value["Pdata_0"],
                                            "Plower" => value["Plower"],
                                            "Pupper" => value["Pupper"],
                                            "weight" => value["weight"]
                                        )
                                    ),  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
                                    # testing_date_transaction = Core.Array{Dates.Date, 1}(),
                                    # testing_opening_price = Core.Array{Core.Union{Core.Float64, Core.String, Core.Nothing}, 1}(),
                                    # testing_close_price = Core.Array{Core.Union{Core.Float64, Core.String, Core.Nothing}, 1}(),
                                    # testing_low_price = Core.Array{Core.Union{Core.Float64, Core.String, Core.Nothing}, 1}(),
                                    # testing_high_price = Core.Array{Core.Union{Core.Float64, Core.String, Core.Nothing}, 1}(),
                                    # testing_turnover_volume = Core.Array{Core.Union{Core.UInt64, Core.String, Core.Nothing}, 1}(),
                                    # testing_turnover_rate = Core.Array{Core.Union{Core.Float64, Core.String, Core.Nothing}, 1}(),
                                    # testing_price_earnings = Core.Array{Core.Union{Core.Float64, Core.String, Core.Nothing}, 1}(),
                                    Pdata_0 = MarketTiming_Pdata_0,  # [Core.Int64(3), Core.Float64(+0.1), Core.Float64(-0.1), Core.Float64(0.0)],  # [Pdata_0[1], Pdata_0[2], Pdata_0[3], Pdata_0[4]],  # Pdata_0, # value["Pdata_0"],
                                    weight = MarketTiming_weight,  # Core.Array{Core.Float64, 1}(),  # weight,  # value["weight"],
                                    Plower = MarketTiming_Plower,  # [-Base.Inf, -Base.Inf, -Base.Inf, -Base.Inf],  # [Plower[1], Plower[2], Plower[3], Plower[4]],  # Plower, # value["Plower"],
                                    Pupper = MarketTiming_Pupper,  # [+Base.Inf, +Base.Inf, +Base.Inf, +Base.Inf],  # [Pupper[1], Pupper[2], Pupper[3], Pupper[4]],  # Pupper, # value["Pupper"],
                                    MarketTiming_fit_model = MarketTiming_fit_model,
                                    Quantitative_Indicators_Function = Quantitative_Indicators_Function,
                                    investment_method = "Long_Position"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
                                );
                                # return_MarketTiming === Base.Dict{Core.String, Core.Any}(
                                #     "ticker_symbol" => Base.Dict{Core.String, Core.Any}(
                                #         "Coefficient" => coefficient_from_fit,  # 最優化計算之後得到的參數;
                                #         "y_profit" => y_profit,  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
                                #         "y_Long_Position_profit" => y_Long_Position_profit,  # 優化目標變量;
                                #         "y_Short_Selling_profit" => y_Short_Selling_profit,  # 優化目標變量;
                                #         "y_loss" => y_loss,  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
                                #         "y_Long_Position_loss" => y_Long_Position_loss,  # 優化目標變量;
                                #         "y_Short_Selling_loss" => y_Short_Selling_loss,  # 優化目標變量;
                                #         "profit_total" => y_total,  # 每兩次對衝交易利潤 × 權重，纍加總計;
                                #         "Long_Position_profit_total" => y_total_Long_Position,  # 每兩次對衝交易利潤 × 權重，纍加總計;
                                #         "Short_Selling_profit_total" => y_total_Short_Selling,  # 每兩次對衝交易利潤 × 權重，纍加總計;
                                #         "profit_Positive" => y_Positive,  # 每兩次對衝交易收益纍加總計;
                                #         "Long_Position_profit_Positive" => y_Positive_Long_Position,  # 每兩次對衝交易收益纍加總計;
                                #         "Short_Selling_profit_Positive" => y_Positive_Short_Selling,  # 每兩次對衝交易收益纍加總計;
                                #         "profit_Positive_probability" => y_P_Positive,  # 每兩次對衝交易正利潤概率;
                                #         "Long_Position_profit_Positive_probability" => y_P_Positive_Long_Position,  # 每兩次對衝交易正利潤概率;
                                #         "Short_Selling_profit_Positive_probability" => y_P_Positive_Short_Selling,  # 每兩次對衝交易正利潤概率;
                                #         "profit_Negative" => y_Negative,  # 每兩次對衝交易損失纍加總計;
                                #         "Long_Position_profit_Negative" => y_Negative_Long_Position,  # 每兩次對衝交易損失纍加總計;
                                #         "Short_Selling_profit_Negative" => y_Negative_Short_Selling,  # 每兩次對衝交易損失纍加總計;
                                #         "profit_Negative_probability" => y_P_Negative,  # 每兩次對衝交易負利潤概率;
                                #         "Long_Position_profit_Negative_probability" => y_P_Negative_Long_Position,  # 每兩次對衝交易負利潤概率;
                                #         "Short_Selling_profit_Negative_probability" => y_P_Negative_Short_Selling,  # 每兩次對衝交易負利潤概率;
                                #         "Long_Position_profit_date_transaction" => y_A_Long_Position,  # 每兩次對衝交易利潤，向量;
                                #         "Short_Selling_profit_date_transaction" => y_A_Short_Selling,  # 每兩次對衝交易利潤，向量;
                                #         "maximum_drawdown" => y_maximum_drawdown,  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                #         "maximum_drawdown_Long_Position" => y_maximum_drawdown_Long_Position,  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                #         "maximum_drawdown_Short_Selling" => y_maximum_drawdown_Short_Selling,  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                #         "Long_Position_drawdown_date_transaction" => y_H_Long_Position,  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                #         "Short_Selling_drawdown_date_transaction" => y_H_Short_Selling,  # 向量，記錄做空模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                #         "average_price_amplitude_date_transaction" => y_amplitude,  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                #         "Long_Position_average_price_amplitude_date_transaction" => y_amplitude_Long_Position,  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                #         "Short_Selling_average_price_amplitude_date_transaction" => y_amplitude_Short_Selling,  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                #         "Long_Position_price_amplitude_date_transaction" => y_D_Long_Position,  # 兩次對衝交易日成交價振幅平方和，向量;
                                #         "Short_Selling_price_amplitude_date_transaction" => y_D_Short_Selling,  # 兩次對衝交易日成交價振幅平方和，向量;
                                #         "average_volume_turnover_date_transaction" => y_turnover,  # 兩次對衝交易日成交量（換手率）均值;
                                #         "Long_Position_average_volume_turnover_date_transaction" => y_turnover_Long_Position,  # 兩次對衝交易日成交量（換手率）均值;
                                #         "Short_Selling_average_volume_turnover_date_transaction" => y_turnover_Short_Selling,  # 兩次對衝交易日成交量（換手率）均值;
                                #         "Long_Position_volume_turnover_date_transaction" => y_E_Long_Position,  # 兩次對衝交易日成交量（換手率）向量;
                                #         "Short_Selling_volume_turnover_date_transaction" => y_E_Short_Selling,  # 兩次對衝交易日成交量（換手率）向量;
                                #         "average_date_transaction_between" => y_date_transaction_between,  # 兩次對衝交易間隔日長，均值;
                                #         "Long_Position_average_date_transaction_between" => y_date_transaction_between_Long_Position,  # 兩次對衝交易間隔日長，均值;
                                #         "Short_Selling_average_date_transaction_between" => y_date_transaction_between_Short_Selling,  # 兩次對衝交易間隔日長，均值;
                                #         "Long_Position_date_transaction_between" => y_C_Long_Position,  # 兩次對衝交易間隔日長，向量;
                                #         "Short_Selling_date_transaction_between" => y_C_Short_Selling,  # 兩次對衝交易間隔日長，向量;
                                #         "Long_Position_date_transaction" => y_F_Long_Position,  # 按規則執行交易的日期，向量;
                                #         "Short_Selling_date_transaction" => y_F_Short_Selling,  # 按規則執行交易的日期，向量;
                                #         "P1_Array" => P1_Array,  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
                                #         "revenue_and_expenditure_records_date_transaction" => y_G,  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
                                #         "weight_MarketTiming" => weight_MarketTiming_Dict
                                #     );
                                # );
                                # println(return_MarketTiming[key]["Coefficient"]);  # 最優化計算之後得到的參數;
                                # println(return_MarketTiming[key]["y_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                # println(return_MarketTiming[key]["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                # println(return_MarketTiming[key]["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                # println(return_MarketTiming[key]["y_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                # println(return_MarketTiming[key]["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                # println(return_MarketTiming[key]["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                # println(return_MarketTiming[key]["profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                # println(return_MarketTiming[key]["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                # println(return_MarketTiming[key]["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                # println(return_MarketTiming[key]["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                # println(return_MarketTiming[key]["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                # println(return_MarketTiming[key]["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                # println(return_MarketTiming[key]["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                # println(return_MarketTiming[key]["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                # println(return_MarketTiming[key]["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                # println(return_MarketTiming[key]["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                # println(return_MarketTiming[key]["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                # println(return_MarketTiming[key]["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                # println(return_MarketTiming[key]["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                # println(return_MarketTiming[key]["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                # println(return_MarketTiming[key]["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                # println(return_MarketTiming[key]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                                # println(return_MarketTiming[key]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                                # println(return_MarketTiming[key]["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                # println(return_MarketTiming[key]["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                # println(return_MarketTiming[key]["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                # println(return_MarketTiming[key]["Long_Position_drawdown_date_transaction"]);  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                # println(return_MarketTiming[key]["Short_Selling_drawdown_date_transaction"]);  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                # println(return_MarketTiming[key]["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                # println(return_MarketTiming[key]["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                # println(return_MarketTiming[key]["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                # println(return_MarketTiming[key]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                                # println(return_MarketTiming[key]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                                # println(return_MarketTiming[key]["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                # println(return_MarketTiming[key]["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                # println(return_MarketTiming[key]["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                # println(return_MarketTiming[key]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                                # println(return_MarketTiming[key]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                                # println(return_MarketTiming[key]["average_date_transaction_between"]);  # 兩次交易間隔日長，均值;
                                # println(return_MarketTiming[key]["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                                # println(return_MarketTiming[key]["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                                # println(return_MarketTiming[key]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                                # println(return_MarketTiming[key]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                                # println(return_MarketTiming[key]["weight_MarketTiming"]);  # 擇時權重，每兩次對衝交易的盈利概率占比;
                                # println(return_MarketTiming[key]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
                                # println(return_MarketTiming[key]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                                # println(return_MarketTiming[key]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                                # println(return_MarketTiming[key]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
                                # println(return_MarketTiming[key]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
                                # println(return_MarketTiming[key]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                                # println(return_MarketTiming[key]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                                # println(return_MarketTiming[key]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                                # println(return_MarketTiming[key]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                                # println(return_MarketTiming[key]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
                                # println(return_MarketTiming[key]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
                                # println(return_MarketTiming[key]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
                                # println(return_MarketTiming[key]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
                                # println(return_MarketTiming[key]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                                # println(return_MarketTiming[key]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                                # println(return_MarketTiming[key]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
                                # println(return_MarketTiming[key]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
                                # println(return_MarketTiming[key]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
                                # println(return_MarketTiming[key]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                                # println(return_MarketTiming[key]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                                # println(return_MarketTiming[key]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
                                # println(return_MarketTiming[key]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
                                # println(return_MarketTiming[key]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                                # println(return_MarketTiming[key]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                                # println(return_MarketTiming[key]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                                # println(return_MarketTiming[key]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                                # println(return_MarketTiming[key]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
                                # println(return_MarketTiming[key]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
                                # println(return_MarketTiming[key]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
                                # println(return_MarketTiming[key]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
                                # println(return_MarketTiming[key]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                                # println(return_MarketTiming[key]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                                # println(return_MarketTiming[key]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
                                # println(return_MarketTiming[key]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
                                # println(return_MarketTiming[key]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
                                # println(return_MarketTiming[key]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
                                # MarketTiming_Parameter_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                if Base.isa(MarketTiming_Parameter_Dict, Base.Dict) && Base.haskey(MarketTiming_Parameter_Dict, Base.string(key))
                                    if Base.isa(MarketTiming_Parameter_Dict[Base.string(key)], Base.Dict)
                                        MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"] = return_MarketTiming[key]["Coefficient"];
                                    end
                                elseif Base.isa(MarketTiming_Parameter_Dict, Base.Dict) && (!Base.haskey(MarketTiming_Parameter_Dict, Base.string(key)))
                                    MarketTiming_Parameter_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                    MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"] = return_MarketTiming[key]["Coefficient"];
                                else
                                end
                                if Base.isa(return_MarketTiming[key], Base.Dict) && Base.haskey(return_MarketTiming[key], "weight_MarketTiming") && Base.isa(return_MarketTiming[key]["weight_MarketTiming"], Base.Dict) && Base.haskey(return_MarketTiming[key]["weight_MarketTiming"], "Long_Position")
                                    if Base.isa(weight_MarketTiming_Dict, Base.Dict) && Base.haskey(weight_MarketTiming_Dict, Base.string(key))
                                        if Base.isa(weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
                                            weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = return_MarketTiming[key]["weight_MarketTiming"]["Long_Position"];  # 依照擇時規則交易倉位參數的存儲字典;
                                        end
                                    elseif Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
                                        weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                        weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = return_MarketTiming[key]["weight_MarketTiming"]["Long_Position"];  # 依照擇時規則交易倉位參數的存儲字典;
                                    else
                                    end
                                end
                                if Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key))
                                    if Base.isa(Plower_weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
                                        Plower_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
                                    end
                                elseif Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key)))
                                    Plower_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                    Plower_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
                                else
                                end
                                if Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key))
                                    if Base.isa(Pupper_weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
                                        Pupper_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
                                    end
                                elseif Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key)))
                                    Pupper_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                    Pupper_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
                                else
                                end
                                return_MarketTiming = Core.nothing;  # 釋放内存;

                                # investment_method = "Short_Selling"
                                return_MarketTiming = MarketTiming(
                                    training_data = Base.Dict{Core.String, Core.Any}(
                                        Base.string(key) => Base.Dict{Core.String, Core.Any}(
                                            "date_transaction" => value["date_transaction"],
                                            "turnover_volume" => value["turnover_volume"],
                                            # "turnover_amount" => value["turnover_amount"],
                                            "opening_price" => value["opening_price"],
                                            "close_price" => value["close_price"],
                                            "low_price" => value["low_price"],
                                            "high_price" => value["high_price"],
                                            "focus" => value["focus"],
                                            "amplitude" => value["amplitude"],
                                            "amplitude_rate" => value["amplitude_rate"],
                                            "opening_price_Standardization" => value["opening_price_Standardization"],
                                            "closing_price_Standardization" => value["closing_price_Standardization"],
                                            "low_price_Standardization" => value["low_price_Standardization"],
                                            "high_price_Standardization" => value["high_price_Standardization"],
                                            "turnover_volume_growth_rate" => value["turnover_volume_growth_rate"],
                                            "opening_price_growth_rate" => value["opening_price_growth_rate"],
                                            "closing_price_growth_rate" => value["closing_price_growth_rate"],
                                            "closing_minus_opening_price_growth_rate" => value["closing_minus_opening_price_growth_rate"],
                                            "high_price_proportion" => value["high_price_proportion"],
                                            "low_price_proportion" => value["low_price_proportion"],
                                            "Pdata_0" => value["Pdata_0"],
                                            "Plower" => value["Plower"],
                                            "Pupper" => value["Pupper"],
                                            "weight" => value["weight"]
                                        )
                                    ),  # ::Core.Array{Core.Float64, 2} = testingData,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
                                    testing_data = Base.Dict{Core.String, Core.Any}(
                                        Base.string(key) => Base.Dict{Core.String, Core.Any}(
                                            "date_transaction" => value["date_transaction"],
                                            "turnover_volume" => value["turnover_volume"],
                                            "opening_price" => value["opening_price"],
                                            "close_price" => value["close_price"],
                                            "low_price" => value["low_price"],
                                            "high_price" => value["high_price"],
                                            "focus" => value["focus"],
                                            "amplitude" => value["amplitude"],
                                            "amplitude_rate" => value["amplitude_rate"],
                                            "opening_price_Standardization" => value["opening_price_Standardization"],
                                            "closing_price_Standardization" => value["closing_price_Standardization"],
                                            "low_price_Standardization" => value["low_price_Standardization"],
                                            "high_price_Standardization" => value["high_price_Standardization"],
                                            "turnover_volume_growth_rate" => value["turnover_volume_growth_rate"],
                                            "opening_price_growth_rate" => value["opening_price_growth_rate"],
                                            "closing_price_growth_rate" => value["closing_price_growth_rate"],
                                            "closing_minus_opening_price_growth_rate" => value["closing_minus_opening_price_growth_rate"],
                                            "high_price_proportion" => value["high_price_proportion"],
                                            "low_price_proportion" => value["low_price_proportion"],
                                            "Pdata_0" => value["Pdata_0"],
                                            "Plower" => value["Plower"],
                                            "Pupper" => value["Pupper"],
                                            "weight" => value["weight"]
                                        )
                                    ),  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
                                    Pdata_0 = MarketTiming_Pdata_0,  # [Core.Int64(3), Core.Float64(+1.0), Core.Float64(-1.0), Core.Float64(0.0)],  # [Pdata_0[1], Pdata_0[2], Pdata_0[3], Pdata_0[4]],  # Pdata_0, # value["Pdata_0"],
                                    weight = MarketTiming_weight,  # Core.Array{Core.Float64, 1}(),  # weight,  # value["weight"],
                                    Plower = MarketTiming_Plower,  # [-Base.Inf, -Base.Inf, -Base.Inf, -Base.Inf],  # [Plower[1], Plower[2], Plower[3], Plower[4]],  # Plower, # value["Plower"],
                                    Pupper = MarketTiming_Pupper,  # [+Base.Inf, +Base.Inf, +Base.Inf, +Base.Inf],  # [Pupper[1], Pupper[2], Pupper[3], Pupper[4]],  # Pupper, # value["Pupper"],
                                    MarketTiming_fit_model = MarketTiming_fit_model,
                                    Quantitative_Indicators_Function = Quantitative_Indicators_Function,
                                    investment_method = "Short_Selling"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
                                );
                                if Base.isa(MarketTiming_Parameter_Dict, Base.Dict) && Base.haskey(MarketTiming_Parameter_Dict, Base.string(key))
                                    if Base.isa(MarketTiming_Parameter_Dict[Base.string(key)], Base.Dict)
                                        MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"] = return_MarketTiming[key]["Coefficient"];
                                    end
                                elseif Base.isa(MarketTiming_Parameter_Dict, Base.Dict) && (!Base.haskey(MarketTiming_Parameter_Dict, Base.string(key)))
                                    MarketTiming_Parameter_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                    MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"] = return_MarketTiming[key]["Coefficient"];
                                else
                                end
                                if Base.isa(return_MarketTiming[key], Base.Dict) && Base.haskey(return_MarketTiming[key], "weight_MarketTiming") && Base.isa(return_MarketTiming[key]["weight_MarketTiming"], Base.Dict) && Base.haskey(return_MarketTiming[key]["weight_MarketTiming"], "Short_Selling")
                                    if Base.isa(weight_MarketTiming_Dict, Base.Dict) && Base.haskey(weight_MarketTiming_Dict, Base.string(key))
                                        if Base.isa(weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
                                            weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = return_MarketTiming[key]["weight_MarketTiming"]["Short_Selling"];  # 依照擇時規則交易倉位參數的存儲字典;
                                        end
                                    elseif Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
                                        weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                        weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = return_MarketTiming[key]["weight_MarketTiming"]["Short_Selling"];  # 依照擇時規則交易倉位參數的存儲字典;
                                    else
                                    end
                                end
                                if Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key))
                                    if Base.isa(Plower_weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
                                        Plower_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
                                    end
                                elseif Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key)))
                                    Plower_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                    Plower_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
                                else
                                end
                                if Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key))
                                    if Base.isa(Pupper_weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
                                        Pupper_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
                                    end
                                elseif Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key)))
                                    Pupper_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                    Pupper_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
                                else
                                end
                                return_MarketTiming = Core.nothing;  # 釋放内存;
                            end
                        end
                    end
                    # println(MarketTiming_Parameter_Dict);
                    # println(weight_MarketTiming_Dict);
                    # println(Plower_weight_MarketTiming_Dict);
                    # println(Pupper_weight_MarketTiming_Dict);

                    # # 調試時使用，人爲指定擇時規則（MarketTiming）參數，注釋掉擇時規則（MarketTiming）優化過程的代碼，以提高運行速度;
                    # MarketTiming_Parameter_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則優化之後得到的擇時規則的輸入參數存儲字典;
                    # weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
                    # Plower_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();
                    # Pupper_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();
                    # if Base.isa(trainingData, Base.Dict) && Base.length(trainingData) > 0
                    #     for (key, value) in trainingData
                    #         if Base.isa(MarketTiming_Parameter_Dict, Base.Dict) && (!Base.haskey(MarketTiming_Parameter_Dict, Base.string(key)))
                    #             MarketTiming_Parameter_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                    #         end
                    #         if Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
                    #             weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                    #         end
                    #         if Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key)))
                    #             Plower_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                    #         end
                    #         if Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key)))
                    #             Pupper_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                    #         end
                    #         MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"] = [Core.Int64(5), Core.Float64(0.1), Core.Float64(-0.1), Core.Float64(0.0)];
                    #         MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"] = [Core.Int64(5), Core.Float64(0.1), Core.Float64(-0.1), Core.Float64(0.0)];
                    #         weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
                    #         Plower_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
                    #         Pupper_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
                    #         weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
                    #         Plower_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
                    #         Pupper_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
                    #     end
                    # end

                    # 依照選股規則優化之後得到的選股規則的輸入參數存儲字典，優化求解選股參數;
                    PickStock_Parameter_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則優化之後得到的選股規則的輸入參數存儲字典;
                    PickStock_ticker_symbol_Array = Core.Array{Core.Any, 1}();  # Core.Array{Core.Array{Core.String, 1}, 1}();
                    weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
                    Plower_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
                    Pupper_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
                    if Base.isa(trainingData, Base.Dict) && Base.length(trainingData) > 0

                        # investment_method = "Long_Position"
                        return_PickStock = PickStock(
                            training_data = trainingData,  # ::Core.Array{Core.Float64, 2} = testingData,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
                            testing_data = trainingData,  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
                            Pdata_0 = PickStock_Pdata_0,  # [Core.Int64(3), Core.Int64(10)],  # [Pdata_0[1], Pdata_0[2]],  # Pdata_0, # value["Pdata_0"],
                            weight = PickStock_weight,  # Core.Array{Core.Float64, 1}(),  # weight,  # value["weight"],
                            Plower = PickStock_Plower,  # [-Base.Inf, -Base.Inf],  # [Plower[1], Plower[2]],  # Plower, # value["Plower"],
                            Pupper = PickStock_Pupper,  # [+Base.Inf, +Base.Inf],  # [Pupper[1], Pupper[2]],  # Pupper, # value["Pupper"],
                            MarketTiming_Parameter = MarketTiming_Parameter_Dict,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
                            PickStock_fit_model = PickStock_fit_model,
                            MarketTiming = MarketTiming,
                            MarketTiming_fit_model = MarketTiming_fit_model,
                            Quantitative_Indicators_Function = Quantitative_Indicators_Function,
                            investment_method = "Long_Position"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
                        );
                        # println("optimization - coefficient : ", return_PickStock["Coefficient"]);  # 最優化計算之後得到的參數;
                        # println("optimization - coefficient StandardDeviation : ", return_PickStock["Coefficient-StandardDeviation"]);  # 擬合得到的參數解的標準差;
                        # println("optimization - coefficient Confidence Lower 95% : ", return_PickStock["Coefficient-Confidence-Lower-95%"]);  # 擬合得到的參數解的區間估計下限;
                        # println("optimization - coefficient Confidence Upper 95% : ", return_PickStock["Coefficient-Confidence-Upper-95%"]);  # 擬合得到的參數解的區間估計上限;
                        # println("y - fit : ", return_PickStock["Yfit"]);  # 擬合 y 值;
                        # println("y - fit Uncertainty Lower : ", return_PickStock["Yfit-Uncertainty-Lower"]);  # 擬合的應變量 Yvals 誤差下限;
                        # println("y - fit Uncertainty Upper : ", return_PickStock["Yfit-Uncertainty-Upper"]);  # 擬合的應變量 Yvals 誤差上限;
                        # println("residual : ", return_PickStock["Residual"]);  # 擬合殘差;
                        # println("optimization - y_profit : ", return_PickStock["y_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                        # println("Long Position optimization - y_profit : ", return_PickStock["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                        # println("Short Selling optimization - y_profit : ", return_PickStock["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                        # println("optimization - y_loss : ", return_PickStock["y_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                        # println("Long Position optimization - y_loss : ", return_PickStock["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                        # println("Short Selling optimization - y_loss : ", return_PickStock["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                        # println("maximum_drawdown : ", return_PickStock["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                        # println("maximum_drawdown_Long_Position : ", return_PickStock["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                        # println("maximum_drawdown_Short_Selling : ", return_PickStock["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                        # println("profit total per share : ", return_PickStock["profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
                        # println("Long Position profit total per share : ", return_PickStock["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
                        # println("Short Selling profit total per share : ", return_PickStock["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
                        # println("profit Positive : ", return_PickStock["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                        # println("Long Position profit Positive : ", return_PickStock["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                        # println("Short Selling_profit Positive : ", return_PickStock["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                        # println("profit Positive probability : ", return_PickStock["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                        # println("Long Position profit Positive probability : ", return_PickStock["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                        # println("Short Selling profit Positive probability : ", return_PickStock["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                        # println("profit Negative : ", return_PickStock["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                        # println("Long Position profit Negative : ", return_PickStock["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                        # println("Short Selling profit Negative : ", return_PickStock["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                        # println("profit Negative probability : ", return_PickStock["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                        # println("Long Position profit Negative probability : ", return_PickStock["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                        # println("Short Selling profit Negative probability : ", return_PickStock["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                        # println("average price amplitude date transaction : ", return_PickStock["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                        # println("Long Position average price amplitude date transaction : ", return_PickStock["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                        # println("Short Selling average price amplitude date transaction : ", return_PickStock["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                        # println("average volume turnover date transaction : ", return_PickStock["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                        # println("Long Position average volume turnover date transaction : ", return_PickStock["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                        # println("Short Selling average volume turnover date transaction : ", return_PickStock["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                        # println("average date transaction between : ", return_PickStock["average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                        # println("Long Position average date transaction between : ", return_PickStock["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                        # println("Short Selling average date transaction between : ", return_PickStock["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                        # println("number PickStock transaction : ", return_PickStock["number_PickStock_transaction"]);  # 交易過股票的總隻數，函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
                        # println("weight_PickStock : ", return_PickStock["weight_PickStock"]);  # 選股權重，每隻股票的盈利概率占比;
                        # println("pick stock sort ticker symbol : ", return_PickStock["PickStock_sort"]["ticker_symbol"]);  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;
                        # println("pick stock sort score : ", return_PickStock["PickStock_sort"]["score"]);  # 依照選股規則排序篩選出的股票得分值存儲數組;
                        # println(return_PickStock["PickStock_transaction_sequence"]);  # 記錄按規則篩選股票按照擇時規則交易信息的序列字典（Dict）;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]);  # 記錄按規則篩選股票按照擇時規則交易信息的序列字典（Dict）;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
                        # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
                        # println("test profit estimate : ", return_PickStock["test_profit"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
                        # println("test odds ratio estimate : ", return_PickStock["test_odds_ratio"]);
                        # println("test date transaction between : ", return_PickStock["test_date_transaction_between"]);
                        # # println(return_PickStock["testData"]);;  # 傳入測試數據集的計算結果;
                        # println("test profit total per share : ", return_PickStock["testData"]["profit_total"]);
                        # println("test Long Position profit total per share : ", return_PickStock["testData"]["Long_Position_profit_total"]);
                        # println("test Short Selling profit total per share : ", return_PickStock["testData"]["Short_Selling_profit_total"]);
                        # println("test profit positive per share : ", return_PickStock["testData"]["profit_Positive"]);
                        # println("test Long Position profit positive per share : ", return_PickStock["testData"]["Long_Position_profit_Positive"]);
                        # println("test Short Selling profit positive per share : ", return_PickStock["testData"]["Short_Selling_profit_Positive"]);
                        # println("test profit positive probability : ", return_PickStock["testData"]["profit_Positive_probability"]);
                        # println("test Long Position profit positive probability : ", return_PickStock["testData"]["Long_Position_profit_Positive_probability"]);
                        # println("test Short Selling profit positive probability : ", return_PickStock["testData"]["Short_Selling_profit_Positive_probability"]);
                        # println("test profit negative per share : ", return_PickStock["testData"]["profit_Negative"]);
                        # println("test Long Position profit negative per share : ", return_PickStock["testData"]["Long_Position_profit_Negative"]);
                        # println("test Short Selling profit negative per share : ", return_PickStock["testData"]["Short_Selling_profit_Negative"]);
                        # println("test profit negative probability : ", return_PickStock["testData"]["profit_Negative_probability"]);
                        # println("test Long Position profit negative probability : ", return_PickStock["testData"]["Long_Position_profit_Negative_probability"]);
                        # println("test Short Selling profit negative probability : ", return_PickStock["testData"]["Short_Selling_profit_Negative_probability"]);
                        # println("test average date transaction between : ", return_PickStock["testData"]["average_date_transaction_between"]);
                        # println("test Long Position average date transaction between : ", return_PickStock["testData"]["Long_Position_average_date_transaction_between"]);
                        # println("test Short Selling average date transaction between : ", return_PickStock["testData"]["Short_Selling_average_date_transaction_between"]);
                        # println("test number_PickStock_transaction : ", return_PickStock["testData"]["number_PickStock_transaction"]);  # 交易過股票的總隻數;
                        # # println(return_PickStock["testData"]["PickStock_transaction_sequence"]["002611"]["P1_Array"]);
                        # # println(return_PickStock["testData"]["PickStock_transaction_sequence"]["002611"]["Long_Position_date_transaction"]);
                        # # println(return_PickStock["testData"]["PickStock_transaction_sequence"]["002611"]["Short_Selling_date_transaction"]);
                        # # println(return_PickStock["testData"]["PickStock_transaction_sequence"]["002611"]);
                        # PickStock_Parameter_Dict = Base.Dict{Core.String, Core.Any}();
                        PickStock_Parameter_Dict["Long_Position"] = return_PickStock["Coefficient"];
                        PickStock_ticker_symbol_Array = return_PickStock["PickStock_sort"]["ticker_symbol"];  # Core.Array{Core.Any, 1}();  # Core.Array{Core.Array{Core.String, 1}, 1}();
                        for (key, value) in return_PickStock["weight_PickStock"]
                            # println("Key: $key, Value: $value");
                            if Base.isa(value, Base.Dict) && Base.haskey(value, "Long_Position")
                                if Base.isa(weight_PickStock_Dict, Base.Dict) && Base.haskey(weight_PickStock_Dict, Base.string(key))
                                    if Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict)
                                        weight_PickStock_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
                                    end
                                elseif Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
                                    weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                    weight_PickStock_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
                                else
                                end
                                if Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && Base.haskey(Plower_weight_PickStock_Dict, Base.string(key))
                                    if Base.isa(Plower_weight_PickStock_Dict[Base.string(key)], Base.Dict)
                                        Plower_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
                                    end
                                elseif Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Plower_weight_PickStock_Dict, Base.string(key)))
                                    Plower_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                    Plower_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
                                else
                                end
                                if Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key))
                                    if Base.isa(Pupper_weight_PickStock_Dict[Base.string(key)], Base.Dict)
                                        Pupper_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
                                    end
                                elseif Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key)))
                                    Pupper_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                    Pupper_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
                                else
                                end
                            end
                        end
                        return_PickStock = Core.nothing;  # 釋放内存;

                        # investment_method = "Short_Selling"
                        return_PickStock = PickStock(
                            training_data = trainingData,  # ::Core.Array{Core.Float64, 2} = testingData,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
                            testing_data = trainingData,  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
                            Pdata_0 = PickStock_Pdata_0,  # [Core.Int64(3), Core.Int64(10)],  # [Pdata_0[1], Pdata_0[2]],  # Pdata_0, # value["Pdata_0"],
                            weight = PickStock_weight,  # Core.Array{Core.Float64, 1}(),  # weight,  # value["weight"],
                            Plower = PickStock_Plower,  # [-Base.Inf, -Base.Inf],  # [Plower[1], Plower[2]],  # Plower, # value["Plower"],
                            Pupper = PickStock_Pupper,  # [+Base.Inf, +Base.Inf],  # [Pupper[1], Pupper[2]],  # Pupper, # value["Pupper"],
                            MarketTiming_Parameter = MarketTiming_Parameter_Dict,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
                            PickStock_fit_model = PickStock_fit_model,
                            MarketTiming = MarketTiming,
                            MarketTiming_fit_model = MarketTiming_fit_model,
                            Quantitative_Indicators_Function = Quantitative_Indicators_Function,
                            investment_method = "Short_Selling"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
                        );
                        PickStock_Parameter_Dict["Short_Selling"] = return_PickStock["Coefficient"];
                        PickStock_ticker_symbol_Array = return_PickStock["PickStock_sort"]["ticker_symbol"];
                        for (key, value) in return_PickStock["weight_PickStock"]
                            # println("Key: $key, Value: $value");
                            if Base.isa(value, Base.Dict) && Base.haskey(value, "Short_Selling")
                                if Base.isa(weight_PickStock_Dict, Base.Dict) && Base.haskey(weight_PickStock_Dict, Base.string(key))
                                    if Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict)
                                        weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
                                    end
                                elseif Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
                                    weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                    weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
                                else
                                end
                                if Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && Base.haskey(Plower_weight_PickStock_Dict, Base.string(key))
                                    if Base.isa(Plower_weight_PickStock_Dict[Base.string(key)], Base.Dict)
                                        Plower_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
                                    end
                                elseif Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Plower_weight_PickStock_Dict, Base.string(key)))
                                    Plower_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                    Plower_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
                                else
                                end
                                if Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key))
                                    if Base.isa(Pupper_weight_PickStock_Dict[Base.string(key)], Base.Dict)
                                        Pupper_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
                                    end
                                elseif Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key)))
                                    Pupper_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                    Pupper_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
                                else
                                end
                            end
                        end
                        return_PickStock = Core.nothing;  # 釋放内存;
                    end
                    # println(PickStock_Parameter_Dict);
                    # println(PickStock_ticker_symbol_Array);
                    # println(weight_PickStock_Dict);
                    # println(Plower_weight_PickStock_Dict);
                    # println(Pupper_weight_PickStock_Dict);

                    # # 調試時使用，人爲指定選股規則（PickStock）參數，注釋掉選股規則（PickStock）優化過程的代碼，以提高運行速度;
                    # PickStock_Parameter_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則優化之後得到的選股規則的輸入參數存儲字典;
                    # PickStock_ticker_symbol_Array = Core.Array{Core.Any, 1}();  # Core.Array{Core.Array{Core.String, 1}, 1}();
                    # weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
                    # Plower_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
                    # Pupper_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
                    # PickStock_Parameter_Dict["Long_Position"] = [Core.Int64(5), Core.Int64(3)];
                    # PickStock_Parameter_Dict["Short_Selling"] = [Core.Int64(5), Core.Int64(3)];
                    # PickStock_ticker_symbol_Array = [Base.string(item) for item in Base.keys(trainingData)];  # Core.Array{Core.Any, 1}();  # Core.Array{Core.String, 1}();
                    # PickStock_ticker_symbol_Array = [PickStock_ticker_symbol_Array for i = Core.Int64(1):Core.Int64(training_data_sequence_length)];  # Core.Array{Core.Any, 1}();  # Core.Array{Core.Array{Core.String, 1}, 1}();
                    # if Base.isa(trainingData, Base.Dict) && Base.length(trainingData) > 0
                    #     for (key, value) in trainingData
                    #         if Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
                    #             weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                    #         end
                    #         if Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Plower_weight_PickStock_Dict, Base.string(key)))
                    #             Plower_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                    #         end
                    #         if Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key)))
                    #             Pupper_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                    #         end
                    #         weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(Core.Int64(1) / Core.Int64(Base.length(Base.keys(trainingData))));
                    #         Plower_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
                    #         Pupper_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
                    #         weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(Core.Int64(1) / Core.Int64(Base.length(Base.keys(trainingData))));
                    #         Plower_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
                    #         Pupper_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
                    #     end
                    # end

                    PickStock_ticker_symbol_Array_testing_data_Long_Position = Core.Array{Core.Any, 1}();
                    PickStock_ticker_symbol_Array_testing_data_Short_Selling = Core.Array{Core.Any, 1}();
                    if Base.typeof(PickStock_ticker_symbol_Array) <: Core.Array && Base.length(PickStock_ticker_symbol_Array) > 0
                        PickStock_ticker_symbol_Array_testing_data_Long_Position = PickStock_ticker_symbol_Array[Core.Int64(Base.length(PickStock_ticker_symbol_Array))];
                        PickStock_ticker_symbol_Array_testing_data_Short_Selling = PickStock_ticker_symbol_Array[Core.Int64(Base.length(PickStock_ticker_symbol_Array))];
                    end
                    # println(PickStock_ticker_symbol_Array_testing_data_Long_Position);
                    # println(PickStock_ticker_symbol_Array_testing_data_Short_Selling);

                    # # 倉位優化;
                    # SizePosition_Parameter_Array = Core.Array{Core.Any, 1}();  # 依照倉位規則優化之後得到的倉位數據存儲字典;
                    # # weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
                    # # weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
                    # if Base.isa(trainingData, Base.Dict) && Base.length(trainingData) > 0

                    #     # investment_method = "Long_Position"
                    #     return_SizePosition = SizePosition(
                    #         training_data = trainingData,  # ::Core.Array{Core.Float64, 2} = testingData,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
                    #         testing_data = trainingData,  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
                    #         Pdata_0 = SizePosition_Pdata_0,  # [weight_MarketTiming_Dict, weight_PickStock_Dict],  # trainingData["002611"]["Pdata_0"],
                    #         weight = SizePosition_weight,  # Core.Array{Core.Float64, 1}(),  # trainingData["002611"]["weight"],
                    #         Plower = SizePosition_Plower,  # [Plower_weight_MarketTiming_Dict, Plower_weight_PickStock_Dict],
                    #         Pupper = SizePosition_Pupper,  # [Pupper_weight_MarketTiming_Dict, Pupper_weight_PickStock_Dict],
                    #         MarketTiming_Parameter = MarketTiming_Parameter_Dict,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
                    #         PickStock_Parameter = PickStock_Parameter_Dict,  # 按照選股規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
                    #         PickStock_ticker_symbol = PickStock_ticker_symbol_Array,  # Core.Array{Core.Any, 1}(),  # ::Core.Array{Core.Array{Core.String, 1}, 1} = Core.Array{Core.Array{Core.String, 1}, 1}(),  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;
                    #         SizePosition_fit_model = SizePosition_fit_model,
                    #         PickStock = PickStock,
                    #         PickStock_fit_model = PickStock_fit_model,
                    #         MarketTiming = MarketTiming,
                    #         MarketTiming_fit_model = MarketTiming_fit_model,
                    #         Quantitative_Indicators_Function = Quantitative_Indicators_Function,
                    #         investment_method = "Long_Position"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
                    #     );
                    #     # println("optimization - coefficient 1 - weight_MarketTiming :", "\n", return_SizePosition["Coefficient"][1], "optimization - coefficient 2 - weight_PickStock :", "\n", return_SizePosition["Coefficient"][2]);  # 最優化計算之後得到的參數;
                    #     # # println("optimization - coefficient StandardDeviation : ", return_SizePosition["Coefficient-StandardDeviation"]);  # 擬合得到的參數解的標準差;
                    #     # # println("optimization - coefficient Confidence Lower 95% : ", return_SizePosition["Coefficient-Confidence-Lower-95%"]);  # 擬合得到的參數解的區間估計下限;
                    #     # # println("optimization - coefficient Confidence Upper 95% : ", return_SizePosition["Coefficient-Confidence-Upper-95%"]);  # 擬合得到的參數解的區間估計上限;
                    #     # # println("y - fit : ", return_SizePosition["Yfit"]);  # 擬合 y 值;
                    #     # # println("y - fit Uncertainty Lower : ", return_SizePosition["Yfit-Uncertainty-Lower"]);  # 擬合的應變量 Yvals 誤差下限;
                    #     # # println("y - fit Uncertainty Upper : ", return_SizePosition["Yfit-Uncertainty-Upper"]);  # 擬合的應變量 Yvals 誤差上限;
                    #     # # println("residual : ", return_SizePosition["Residual"]);  # 擬合殘差;
                    #     # println("y_profit : ", return_SizePosition["y_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                    #     # println("y_Long_Position_profit : ", return_SizePosition["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                    #     # println("y_Short_Selling_profit : ", return_SizePosition["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                    #     # println("y_loss : ", return_SizePosition["y_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                    #     # println("y_Long_Position_loss : ", return_SizePosition["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                    #     # println("y_Short_Selling_loss : ", return_SizePosition["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                    #     # println("maximum_drawdown : ", return_SizePosition["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                    #     # println("maximum_drawdown_Long_Position : ", return_SizePosition["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                    #     # println("maximum_drawdown_Short_Selling : ", return_SizePosition["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                    #     # println("profit total per share : ", return_SizePosition["profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
                    #     # println("Long Position profit total per share : ", return_SizePosition["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
                    #     # println("Short Selling profit total per share : ", return_SizePosition["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
                    #     # println("profit Positive : ", return_SizePosition["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                    #     # println("Long Position profit Positive : ", return_SizePosition["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                    #     # println("Short Selling_profit Positive : ", return_SizePosition["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                    #     # println("profit Positive probability : ", return_SizePosition["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                    #     # println("Long Position profit Positive probability : ", return_SizePosition["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                    #     # println("Short Selling profit Positive probability : ", return_SizePosition["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                    #     # println("profit Negative : ", return_SizePosition["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                    #     # println("Long Position profit Negative : ", return_SizePosition["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                    #     # println("Short Selling profit Negative : ", return_SizePosition["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                    #     # println("profit Negative probability : ", return_SizePosition["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                    #     # println("Long Position profit Negative probability : ", return_SizePosition["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                    #     # println("Short Selling profit Negative probability : ", return_SizePosition["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                    #     # println("average price amplitude date transaction : ", return_SizePosition["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                    #     # println("Long Position average price amplitude date transaction : ", return_SizePosition["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                    #     # println("Short Selling average price amplitude date transaction : ", return_SizePosition["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                    #     # println("average volume turnover date transaction : ", return_SizePosition["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                    #     # println("Long Position average volume turnover date transaction : ", return_SizePosition["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                    #     # println("Short Selling average volume turnover date transaction : ", return_SizePosition["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                    #     # println("average date transaction between : ", return_SizePosition["average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                    #     # println("Long Position average date transaction between : ", return_SizePosition["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                    #     # println("Short Selling average date transaction between : ", return_SizePosition["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                    #     # println("number SizePosition transaction : ", return_SizePosition["number_PickStock_transaction"]);  # 交易過股票的總隻數，函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]);  # 記錄按規則篩選股票按照擇時規則交易信息的序列字典（Dict）;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]);  # 記錄按規則篩選股票按照擇時規則交易信息的序列字典（Dict）;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
                    #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
                    #     # println("test profit estimate : ", return_SizePosition["test_profit"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
                    #     # println("test odds ratio estimate : ", return_SizePosition["test_odds_ratio"]);
                    #     # println("test date transaction between : ", return_SizePosition["test_date_transaction_between"]);
                    #     # # println(return_SizePosition["testData"]);;  # 傳入測試數據集的計算結果;
                    #     # println("test profit total per share : ", return_SizePosition["testData"]["profit_total"]);
                    #     # println("test Long Position profit total per share : ", return_SizePosition["testData"]["Long_Position_profit_total"]);
                    #     # println("test Short Selling profit total per share : ", return_SizePosition["testData"]["Short_Selling_profit_total"]);
                    #     # println("test profit positive per share : ", return_SizePosition["testData"]["profit_Positive"]);
                    #     # println("test Long Position profit positive per share : ", return_SizePosition["testData"]["Long_Position_profit_Positive"]);
                    #     # println("test Short Selling profit positive per share : ", return_SizePosition["testData"]["Short_Selling_profit_Positive"]);
                    #     # println("test profit positive probability : ", return_SizePosition["testData"]["profit_Positive_probability"]);
                    #     # println("test Long Position profit positive probability : ", return_SizePosition["testData"]["Long_Position_profit_Positive_probability"]);
                    #     # println("test Short Selling profit positive probability : ", return_SizePosition["testData"]["Short_Selling_profit_Positive_probability"]);
                    #     # println("test profit negative per share : ", return_SizePosition["testData"]["profit_Negative"]);
                    #     # println("test Long Position profit negative per share : ", return_SizePosition["testData"]["Long_Position_profit_Negative"]);
                    #     # println("test Short Selling profit negative per share : ", return_SizePosition["testData"]["Short_Selling_profit_Negative"]);
                    #     # println("test profit negative probability : ", return_SizePosition["testData"]["profit_Negative_probability"]);
                    #     # println("test Long Position profit negative probability : ", return_SizePosition["testData"]["Long_Position_profit_Negative_probability"]);
                    #     # println("test Short Selling profit negative probability : ", return_SizePosition["testData"]["Short_Selling_profit_Negative_probability"]);
                    #     # println("test average date transaction between : ", return_SizePosition["testData"]["average_date_transaction_between"]);
                    #     # println("test Long Position average date transaction between : ", return_SizePosition["testData"]["Long_Position_average_date_transaction_between"]);
                    #     # println("test Short Selling average date transaction between : ", return_SizePosition["testData"]["Short_Selling_average_date_transaction_between"]);
                    #     # println("test number SizePosition transaction : ", return_SizePosition["testData"]["number_PickStock_transaction"]);  # 交易過股票的總隻數;
                    #     # # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]["P1_Array"]);
                    #     # # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"]);
                    #     # # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"]);
                    #     # # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]);
                    #     # weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
                    #     # weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
                    #     if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 1 && Base.isa(return_SizePosition["Coefficient"][1], Base.Dict)
                    #         for (key, value) in return_SizePosition["Coefficient"][1]
                    #             # println("Key: $key, Value: $value");
                    #             if Base.isa(value, Base.Dict) && Base.haskey(value, "Long_Position")
                    #                 if Base.isa(weight_MarketTiming_Dict, Base.Dict) && Base.haskey(weight_MarketTiming_Dict, Base.string(key))
                    #                     if Base.isa(weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
                    #                         weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
                    #                     end
                    #                 elseif Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
                    #                     weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                    #                     weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
                    #                 else
                    #                 end
                    #             end
                    #         end
                    #     end
                    #     if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 2 && Base.isa(return_SizePosition["Coefficient"][2], Base.Dict)
                    #         for (key, value) in return_SizePosition["Coefficient"][2]
                    #             # println("Key: $key, Value: $value");
                    #             if Base.isa(value, Base.Dict) && Base.haskey(value, "Long_Position")
                    #                 if Base.isa(weight_PickStock_Dict, Base.Dict) && Base.haskey(weight_PickStock_Dict, Base.string(key))
                    #                     if Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict)
                    #                         weight_PickStock_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
                    #                     end
                    #                 elseif Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
                    #                     weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                    #                     weight_PickStock_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
                    #                 else
                    #                 end
                    #             end
                    #         end
                    #     end
                    #     return_SizePosition = Core.nothing;  # 釋放内存;

                    #     # investment_method = "Short_Selling"
                    #     return_SizePosition = SizePosition(
                    #         training_data = trainingData,  # ::Core.Array{Core.Float64, 2} = testingData,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
                    #         testing_data = trainingData,  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
                    #         Pdata_0 = SizePosition_Pdata_0,  # [weight_MarketTiming_Dict, weight_PickStock_Dict],  # trainingData["002611"]["Pdata_0"],
                    #         weight = SizePosition_weight,  # Core.Array{Core.Float64, 1}(),  # trainingData["002611"]["weight"],
                    #         Plower = SizePosition_Plower,  # [Plower_weight_MarketTiming_Dict, Plower_weight_PickStock_Dict],
                    #         Pupper = SizePosition_Pupper,  # [Pupper_weight_MarketTiming_Dict, Pupper_weight_PickStock_Dict],
                    #         MarketTiming_Parameter = MarketTiming_Parameter_Dict,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
                    #         PickStock_Parameter = PickStock_Parameter_Dict,  # 按照選股規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
                    #         PickStock_ticker_symbol = PickStock_ticker_symbol_Array,  # Core.Array{Core.Any, 1}(),  # ::Core.Array{Core.Array{Core.String, 1}, 1} = Core.Array{Core.Array{Core.String, 1}, 1}(),  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;
                    #         SizePosition_fit_model = SizePosition_fit_model,
                    #         PickStock = PickStock,
                    #         PickStock_fit_model = PickStock_fit_model,
                    #         MarketTiming = MarketTiming,
                    #         MarketTiming_fit_model = MarketTiming_fit_model,
                    #         Quantitative_Indicators_Function = Quantitative_Indicators_Function,
                    #         investment_method = "Short_Selling"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
                    #     );
                    #     # weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
                    #     # weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
                    #     if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 1 && Base.isa(return_SizePosition["Coefficient"][1], Base.Dict)
                    #         for (key, value) in return_SizePosition["Coefficient"][1]
                    #             # println("Key: $key, Value: $value");
                    #             if Base.isa(value, Base.Dict) && Base.haskey(value, "Short_Selling")
                    #                 if Base.isa(weight_MarketTiming_Dict, Base.Dict) && Base.haskey(weight_MarketTiming_Dict, Base.string(key))
                    #                     if Base.isa(weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
                    #                         weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
                    #                     end
                    #                 elseif Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
                    #                     weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                    #                     weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
                    #                 else
                    #                 end
                    #             end
                    #         end
                    #     end
                    #     if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 2 && Base.isa(return_SizePosition["Coefficient"][2], Base.Dict)
                    #         for (key, value) in return_SizePosition["Coefficient"][2]
                    #             # println("Key: $key, Value: $value");
                    #             if Base.isa(value, Base.Dict) && Base.haskey(value, "Short_Selling")
                    #                 if Base.isa(weight_PickStock_Dict, Base.Dict) && Base.haskey(weight_PickStock_Dict, Base.string(key))
                    #                     if Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict)
                    #                         weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
                    #                     end
                    #                 elseif Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
                    #                     weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                    #                     weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
                    #                 else
                    #                 end
                    #             end
                    #         end
                    #     end
                    #     return_SizePosition = Core.nothing;  # 釋放内存;
                    # end
                    SizePosition_Parameter_Array = [weight_MarketTiming_Dict, weight_PickStock_Dict];
                    # # println(SizePosition_Parameter_Array);
                    # println("optimization - coefficient 1 - weight_MarketTiming :", "\n", SizePosition_Parameter_Array[1]);  # 最優化計算之後得到的參數;
                    # println("optimization - coefficient 2 - weight_PickStock :", "\n", SizePosition_Parameter_Array[2]);  # 最優化計算之後得到的參數;

                    stepping_transaction_Dict["training_data"] = trainingData;
                    stepping_transaction_Dict["training_MarketTiming_Parameter"] = MarketTiming_Parameter_Dict;
                    stepping_transaction_Dict["training_PickStock_Parameter"] = PickStock_Parameter_Dict;
                    stepping_transaction_Dict["training_PickStock_ticker_symbol"] = PickStock_ticker_symbol_Array;
                    stepping_transaction_Dict["training_SizePosition_Parameter"] = SizePosition_Parameter_Array;

                    # 求解擇時規則和選股規則優化參數中向前回溯的交易天數極值;
                    maximum_MarketTiming_and_PickStock_P1 = Core.Int64(0);  # 擇時規則和選股規則優化參數中向前回溯的最長交易天數;
                    minimum_MarketTiming_and_PickStock_P1 = Core.Int64(0);  # 擇時規則和選股規則優化參數中向前回溯的最短交易天數;
                    MarketTiming_and_PickStock_P1_Array = Core.Array{Core.Int64, 1}();
                    # 遍歷字典的鍵:值對;
                    for (key, value) in PickStock_Parameter_Dict
                        # println("Key: $key, Value: $value");
                        if Base.typeof(value) <: Core.Array && Core.Int64(Base.length(value)) > Core.Int64(0)
                            # 記錄選股規則向前回溯的天數，使用 push! 函數在數組末尾追加推入新元;
                            Base.push!(MarketTiming_and_PickStock_P1_Array, Core.Int64(value[1]));  # 記錄選股規則向前回溯的天數，使用 push! 函數在數組末尾追加推入新元;
                            # 篩選選股規則最長向前回溯的天數;
                            if Core.Int64(value[1]) > Core.Int64(maximum_MarketTiming_and_PickStock_P1)
                                maximum_MarketTiming_and_PickStock_P1_2 = Core.Int64(value[1]);
                                maximum_MarketTiming_and_PickStock_P1 *= Core.Int64(0);
                                maximum_MarketTiming_and_PickStock_P1 += Core.Int64(maximum_MarketTiming_and_PickStock_P1_2);
                            end
                        end
                    end
                    for (key, value) in MarketTiming_Parameter_Dict
                        # println("Key: $key, Value: $value");
                        if Base.isa(value, Base.Dict)
                            # investment_method === "Long_Position_and_Short_Selling";
                            if Base.haskey(value, "Long_Position_and_Short_Selling") && Base.typeof(value["Long_Position_and_Short_Selling"]) <: Core.Array && Core.Int64(Base.length(value["Long_Position_and_Short_Selling"])) > Core.Int64(0)
                                # 記錄擇時規則向前回溯的天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(MarketTiming_and_PickStock_P1_Array, Core.Int64(value["Long_Position_and_Short_Selling"][1]));  # 記錄擇時規則向前回溯的天數，使用 push! 函數在數組末尾追加推入新元;
                                # 篩選擇時規則最長向前回溯的天數;
                                if Core.Int64(value["Long_Position_and_Short_Selling"][1]) > Core.Int64(maximum_MarketTiming_and_PickStock_P1)
                                    maximum_MarketTiming_and_PickStock_P1_2 = Core.Int64(value["Long_Position_and_Short_Selling"][1]);
                                    maximum_MarketTiming_and_PickStock_P1 *= Core.Int64(0);
                                    maximum_MarketTiming_and_PickStock_P1 += Core.Int64(maximum_MarketTiming_and_PickStock_P1_2);
                                end
                            end
                            # investment_method === "Long_Position";
                            if Base.haskey(value, "Long_Position") && Base.typeof(value["Long_Position"]) <: Core.Array && Core.Int64(Base.length(value["Long_Position"])) > Core.Int64(0)
                                # 記錄擇時規則向前回溯的天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(MarketTiming_and_PickStock_P1_Array, Core.Int64(value["Long_Position"][1]));  # 記錄擇時規則向前回溯的天數，使用 push! 函數在數組末尾追加推入新元;
                                # 篩選擇時規則最長向前回溯的天數;
                                if Core.Int64(value["Long_Position"][1]) > Core.Int64(maximum_MarketTiming_and_PickStock_P1)
                                    maximum_MarketTiming_and_PickStock_P1_2 = Core.Int64(value["Long_Position"][1]);
                                    maximum_MarketTiming_and_PickStock_P1 *= Core.Int64(0);
                                    maximum_MarketTiming_and_PickStock_P1 += Core.Int64(maximum_MarketTiming_and_PickStock_P1_2);
                                end
                            end
                            # investment_method === "Short_Selling";
                            if Base.haskey(value, "Short_Selling") && Base.typeof(value["Short_Selling"]) <: Core.Array && Core.Int64(Base.length(value["Short_Selling"])) > Core.Int64(0)
                                # 記錄擇時規則向前回溯的天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(MarketTiming_and_PickStock_P1_Array, Core.Int64(value["Short_Selling"][1]));  # 記錄擇時規則向前回溯的天數，使用 push! 函數在數組末尾追加推入新元;
                                # 篩選擇時規則最長向前回溯的天數;
                                if Core.Int64(value["Short_Selling"][1]) > Core.Int64(maximum_MarketTiming_and_PickStock_P1)
                                    maximum_MarketTiming_and_PickStock_P1_2 = Core.Int64(value["Short_Selling"][1]);
                                    maximum_MarketTiming_and_PickStock_P1 *= Core.Int64(0);
                                    maximum_MarketTiming_and_PickStock_P1 += Core.Int64(maximum_MarketTiming_and_PickStock_P1_2);
                                end
                            end
                        end
                    end
                    # println(maximum_MarketTiming_and_PickStock_P1);
                    if Base.length(MarketTiming_and_PickStock_P1_Array) > 0
                        minimum_MarketTiming_and_PickStock_P1_2 = Core.Int64(Base.findmin(MarketTiming_and_PickStock_P1_Array)[1]);
                        minimum_MarketTiming_and_PickStock_P1 *= Core.Int64(0);
                        minimum_MarketTiming_and_PickStock_P1 += Core.Int64(minimum_MarketTiming_and_PickStock_P1_2);
                    end
                    # println(minimum_MarketTiming_and_PickStock_P1);
                    MarketTiming_and_PickStock_P1_Array = Core.nothing;  # 釋放内存;

                    # 判斷滑框步進一步之後是否仍在數據序列範圍内;
                    # k = Core.Int64(Core.Int64(i) + Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)));
                    k = Core.Int64(Core.Int64(i) + Core.Int64(testing_data_sequence_length));
                    if Core.Int64(k) <= Core.Int64(minimum_dates_transaction)
                        if Core.Int64(k) >= Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2))
                            if Base.length(testing_data_ticker_symbol_Array) > 0

                                # 推進分析測試集數據序列截取;
                                testingData = Base.Dict{Core.String, Core.Any}();
                                for h = Core.Int64(1):Core.Int64(Base.length(testing_data_ticker_symbol_Array))
                                    # 判斷當前股票代碼字符串（ticker_symbol）是否在指定數組内
                                    if Base.haskey(steppingData, Base.string(testing_data_ticker_symbol_Array[h])) && Base.isa(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], Base.Dict) && Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]) > 0
                                        if (Base.haskey(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], "date_transaction") && Base.typeof(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["date_transaction"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], "turnover_volume") && Base.typeof(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["turnover_volume"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], "opening_price") && Base.typeof(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["opening_price"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], "close_price") && Base.typeof(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["close_price"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], "low_price") && Base.typeof(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["low_price"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], "high_price") && Base.typeof(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["high_price"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], "focus") && Base.typeof(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["focus"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], "amplitude") && Base.typeof(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["amplitude"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], "amplitude_rate") && Base.typeof(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["amplitude_rate"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], "opening_price_Standardization") && Base.typeof(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["opening_price_Standardization"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], "closing_price_Standardization") && Base.typeof(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["closing_price_Standardization"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], "low_price_Standardization") && Base.typeof(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["low_price_Standardization"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], "high_price_Standardization") && Base.typeof(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["high_price_Standardization"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], "turnover_volume_growth_rate") && Base.typeof(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["turnover_volume_growth_rate"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], "opening_price_growth_rate") && Base.typeof(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["opening_price_growth_rate"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], "closing_price_growth_rate") && Base.typeof(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["closing_price_growth_rate"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], "closing_minus_opening_price_growth_rate") && Base.typeof(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["closing_minus_opening_price_growth_rate"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], "high_price_proportion") && Base.typeof(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["high_price_proportion"]) <: Core.Array) && (Base.haskey(steppingData[Base.string(testing_data_ticker_symbol_Array[h])], "low_price_proportion") && Base.typeof(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["low_price_proportion"]) <: Core.Array)

                                            # 判斷測試集數據滑框尾界是否在數據序列範圍内;
                                            if Core.Int64(k) <= Core.Int64(Base.findmin([Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["date_transaction"]), Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["turnover_volume"]), Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["opening_price"]), Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["close_price"]), Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["low_price"]), Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["high_price"]), Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["focus"]), Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["amplitude"]), Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["amplitude_rate"]), Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["opening_price_Standardization"]), Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["closing_price_Standardization"]), Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["low_price_Standardization"]), Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["high_price_Standardization"]), Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["turnover_volume_growth_rate"]), Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["opening_price_growth_rate"]), Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["closing_price_growth_rate"]), Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["closing_minus_opening_price_growth_rate"]), Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["high_price_proportion"]), Base.length(steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["low_price_proportion"])])[1])
                                                # 判斷測試集數據滑框頭界是否在數據序列範圍内;
                                                if Core.Int64(k) >= Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2))

                                                    x0 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["date_transaction"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 交易日期;
                                                    x1 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["turnover_volume"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 成交量;
                                                    # x2 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["turnover_amount"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 成交總金額;
                                                    x3 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["opening_price"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 開盤成交價;
                                                    x4 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["close_price"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 收盤成交價;
                                                    x5 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["low_price"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 最低成交價;
                                                    x6 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["high_price"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 最高成交價;
                                                    x7 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["focus"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 當日成交價重心;
                                                    x8 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["amplitude"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 當日成交價絕對振幅;
                                                    x9 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["amplitude_rate"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 當日成交價相對振幅（%）;
                                                    x10 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["opening_price_Standardization"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 日棒缐（K Line Daily）數據交易日首筆成交價（開盤價）標準化值;
                                                    x11 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["closing_price_Standardization"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 日棒缐（K Line Daily）數據交易日尾筆成交價（收盤價）標準化值;
                                                    x12 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["low_price_Standardization"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 日棒缐（K Line Daily）數據交易日最低成交價標準化值;
                                                    x13 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["high_price_Standardization"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 日棒缐（K Line Daily）數據交易日最高成交價標準化值;
                                                    x14 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["turnover_volume_growth_rate"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 成交量的成長率;
                                                    x15 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["opening_price_growth_rate"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 開盤價的成長率;
                                                    x16 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["closing_price_growth_rate"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 收盤價的成長率;
                                                    x17 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["closing_minus_opening_price_growth_rate"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 收盤價減開盤價的成長率;
                                                    x18 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["high_price_proportion"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 收盤價和開盤價裏的最大值占最高價的比例;
                                                    x19 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["low_price_proportion"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 最低價占收盤價和開盤價裏的最小值的比例;
                                                    # x20 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["turnover_rate"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 成交量換手率;
                                                    # x21 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["price_earnings"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 每股收益（公司經營利潤率 ÷ 股本）;
                                                    # x22 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["book_value_per_share"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 每股净值（公司净資產 ÷ 股本）;
                                                    # x23 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["capitalization"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 總市值;
                                                    # x24 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["moving_average_5"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 收盤價 5 日滑動平均缐;
                                                    # x25 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["moving_average_10"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 收盤價 10 日滑動平均缐;
                                                    # x26 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["moving_average_20"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 收盤價 20 日滑動平均缐;
                                                    # x27 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["moving_average_30"][Core.Int64(Core.Int64(k) - Core.Int64(Core.Int64(maximum_MarketTiming_and_PickStock_P1) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(k)];  # 收盤價 30 日滑動平均缐;
                                                    Pdata_0 = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["Pdata_0"];
                                                    Plower = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["Plower"];
                                                    Pupper = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["Pupper"];
                                                    weight = steppingData[Base.string(testing_data_ticker_symbol_Array[h])]["weight"];

                                                    testingData[Base.string(testing_data_ticker_symbol_Array[h])] = Base.Dict{Core.String, Core.Any}(
                                                        "date_transaction" => x0,  # 交易日期;
                                                        "turnover_volume" => x1,  # 成交量;
                                                        # "turnover_amount" => x2,  # 成交總金額;
                                                        "opening_price" => x3,  # 開盤成交價;
                                                        "close_price" => x4,  # 收盤成交價;
                                                        "low_price" => x5,  # 最低成交價;
                                                        "high_price" => x6,  # 最高成交價;
                                                        "focus" => x7,  # 當日成交價重心;
                                                        "amplitude" => x8,  # 當日成交價絕對振幅;
                                                        "amplitude_rate" => x9,  # 當日成交價相對振幅（%）;
                                                        "opening_price_Standardization" => x10,  # 日棒缐（K Line Daily）數據交易日首筆成交價（開盤價）標準化值;
                                                        "closing_price_Standardization" => x11,  # 日棒缐（K Line Daily）數據交易日尾筆成交價（收盤價）標準化值;
                                                        "low_price_Standardization" => x12,  # 日棒缐（K Line Daily）數據交易日最低成交價標準化值;
                                                        "high_price_Standardization" => x13,  # 日棒缐（K Line Daily）數據交易日最高成交價標準化值;
                                                        "turnover_volume_growth_rate" => x14,  # 成交量的成長率;
                                                        "opening_price_growth_rate" => x15,  # 開盤價的成長率;
                                                        "closing_price_growth_rate" => x16,  # 收盤價的成長率;
                                                        "closing_minus_opening_price_growth_rate" => x17,  # 收盤價減開盤價的成長率;
                                                        "high_price_proportion" => x18,  # 收盤價和開盤價裏的最大值占最高價的比例;
                                                        "low_price_proportion" => x19,  # 最低價占收盤價和開盤價裏的最小值的比例;
                                                        # "turnover_rate" => x20,  # 成交量換手率;
                                                        # "price_earnings" => x21,  # 每股收益（公司經營利潤率 ÷ 股本）;
                                                        # "book_value_per_share" => x22,  # 每股净值（公司净資產 ÷ 股本）;
                                                        # "capitalization" => x23,  # 總市值;
                                                        # "moving_average_5" => x24,  # 收盤價 5 日滑動平均缐;
                                                        # "moving_average_10" => x25,  # 收盤價 10 日滑動平均缐;
                                                        # "moving_average_20" => x26,  # 收盤價 20 日滑動平均缐;
                                                        # "moving_average_30" => x27,  # 收盤價 30 日滑動平均缐;
                                                        "Pdata_0" => Pdata_0,
                                                        "Plower" => Plower,
                                                        "Pupper" => Pupper,
                                                        "weight" => weight
                                                    );

                                                    # 釋放内存;
                                                    x0 = Core.nothing;
                                                    x1 = Core.nothing;
                                                    # x2 = Core.nothing;
                                                    x3 = Core.nothing;
                                                    x4 = Core.nothing;
                                                    x5 = Core.nothing;
                                                    x6 = Core.nothing;
                                                    x7 = Core.nothing;
                                                    x8 = Core.nothing;
                                                    x9 = Core.nothing;
                                                    x10 = Core.nothing;
                                                    x11 = Core.nothing;
                                                    x12 = Core.nothing;
                                                    x13 = Core.nothing;
                                                    x14 = Core.nothing;
                                                    x15 = Core.nothing;
                                                    x16 = Core.nothing;
                                                    x17 = Core.nothing;
                                                    x18 = Core.nothing;
                                                    x19 = Core.nothing;
                                                    # x20 = Core.nothing;
                                                    # x21 = Core.nothing;
                                                    # x22 = Core.nothing;
                                                    # x23 = Core.nothing;
                                                    # x24 = Core.nothing;
                                                    # x25 = Core.nothing;
                                                    # x26 = Core.nothing;
                                                    # x27 = Core.nothing;
                                                    Pdata_0 = Core.nothing;
                                                    Plower = Core.nothing;
                                                    Pupper = Core.nothing;
                                                    weight = Core.nothing;
                                                end
                                            end
                                        end
                                    end
                                end

                                stepping_transaction_Dict["testing_data"] = testingData;

                                if Base.isa(testingData, Base.Dict) && Base.length(testingData) > 0

                                    # 測試數據集交易過股票的總隻數，函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
                                    maximum_ticker_symbol_transaction_testing_data = Core.Int64(Base.length(Base.keys(testingData)));  # 測試數據集交易過股票的總隻數;
                                    # println(maximum_ticker_symbol_transaction_testing_data);
                                    maximum_dates_transaction_testing_data = Core.Int64(0);  # 測試數據集各股票裏的最長交易天數;
                                    minimum_dates_transaction_testing_data = Core.Int64(0);  # 測試數據集各股票裏的最短交易天數;
                                    dates_transaction_Array_testing_data = Core.Array{Core.Int64, 1}();
                                    # 遍歷字典的鍵:值對;
                                    for (key, value) in testingData
                                        # println("Key: $key, Value: $value");
                                        if Base.isa(value, Base.Dict)
                                            if Base.haskey(value, "date_transaction") && Base.typeof(value["date_transaction"]) <: Core.Array
                                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                Base.push!(dates_transaction_Array_testing_data, Core.Int64(Base.length(value["date_transaction"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
        
                                                # 篩選最長交易天數;
                                                if Core.Int64(Base.length(value["date_transaction"])) > Core.Int64(maximum_dates_transaction_testing_data)
                                                    maximum_dates_transaction_testing_data_2 = Core.Int64(Base.length(value["date_transaction"]));
                                                    maximum_dates_transaction_testing_data *= Core.Int64(0);
                                                    maximum_dates_transaction_testing_data += Core.Int64(maximum_dates_transaction_testing_data_2);
                                                end
                                            end
                                            if Base.haskey(value, "turnover_volume") && Base.typeof(value["turnover_volume"]) <: Core.Array
                                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                Base.push!(dates_transaction_Array_testing_data, Core.Int64(Base.length(value["turnover_volume"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
        
                                                # 篩選最長交易天數;
                                                if Core.Int64(Base.length(value["turnover_volume"])) > Core.Int64(maximum_dates_transaction_testing_data)
                                                    maximum_dates_transaction_testing_data_2 = Core.Int64(Base.length(value["turnover_volume"]));
                                                    maximum_dates_transaction_testing_data *= Core.Int64(0);
                                                    maximum_dates_transaction_testing_data += Core.Int64(maximum_dates_transaction_testing_data_2);
                                                end
                                            end
                                            if Base.haskey(value, "opening_price") && Base.typeof(value["opening_price"]) <: Core.Array
                                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                Base.push!(dates_transaction_Array_testing_data, Core.Int64(Base.length(value["opening_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
        
                                                # 篩選最長交易天數;
                                                if Core.Int64(Base.length(value["opening_price"])) > Core.Int64(maximum_dates_transaction_testing_data)
                                                    maximum_dates_transaction_testing_data_2 = Core.Int64(Base.length(value["opening_price"]));
                                                    maximum_dates_transaction_testing_data *= Core.Int64(0);
                                                    maximum_dates_transaction_testing_data += Core.Int64(maximum_dates_transaction_testing_data_2);
                                                end
                                            end
                                            if Base.haskey(value, "close_price") && Base.typeof(value["close_price"]) <: Core.Array
                                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                Base.push!(dates_transaction_Array_testing_data, Core.Int64(Base.length(value["close_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
        
                                                # 篩選最長交易天數;
                                                if Core.Int64(Base.length(value["close_price"])) > Core.Int64(maximum_dates_transaction_testing_data)
                                                    maximum_dates_transaction_testing_data_2 = Core.Int64(Base.length(value["close_price"]));
                                                    maximum_dates_transaction_testing_data *= Core.Int64(0);
                                                    maximum_dates_transaction_testing_data += Core.Int64(maximum_dates_transaction_testing_data_2);
                                                end
                                            end
                                            if Base.haskey(value, "low_price") && Base.typeof(value["low_price"]) <: Core.Array
                                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                Base.push!(dates_transaction_Array_testing_data, Core.Int64(Base.length(value["low_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
        
                                                # 篩選最長交易天數;
                                                if Core.Int64(Base.length(value["low_price"])) > Core.Int64(maximum_dates_transaction_testing_data)
                                                    maximum_dates_transaction_testing_data_2 = Core.Int64(Base.length(value["low_price"]));
                                                    maximum_dates_transaction_testing_data *= Core.Int64(0);
                                                    maximum_dates_transaction_testing_data += Core.Int64(maximum_dates_transaction_testing_data_2);
                                                end
                                            end
                                            if Base.haskey(value, "high_price") && Base.typeof(value["high_price"]) <: Core.Array
                                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                Base.push!(dates_transaction_Array_testing_data, Core.Int64(Base.length(value["high_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
        
                                                # 篩選最長交易天數;
                                                if Core.Int64(Base.length(value["high_price"])) > Core.Int64(maximum_dates_transaction_testing_data)
                                                    maximum_dates_transaction_testing_data_2 = Core.Int64(Base.length(value["high_price"]));
                                                    maximum_dates_transaction_testing_data *= Core.Int64(0);
                                                    maximum_dates_transaction_testing_data += Core.Int64(maximum_dates_transaction_testing_data_2);
                                                end
                                            end
                                        end
                                    end
                                    # println(maximum_dates_transaction_testing_data);
                                    if Base.length(dates_transaction_Array_testing_data) > 0
                                        minimum_dates_transaction_testing_data_2 = Core.Int64(Base.findmin(dates_transaction_Array_testing_data)[1]);
                                        minimum_dates_transaction_testing_data *= Core.Int64(0);
                                        minimum_dates_transaction_testing_data += Core.Int64(minimum_dates_transaction_testing_data_2);
                                    end
                                    # println(minimum_dates_transaction_testing_data);
                                    dates_transaction_Array_testing_data = Core.nothing;  # 釋放内存;

                                    # # 依照選股規則篩選出股票，並將股票代碼字符串存儲數組;
                                    # return_PickStock_fit_model = PickStock_fit_model(
                                    #     testingData,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # ::Core.Array{Core.Float64, 2} = testingData,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
                                    #     PickStock_Parameter_Dict["Long_Position"][1],  # Core.Int64(3),  # P1,  # 觀察收益率歷史向前推的交易日長度;
                                    #     PickStock_Parameter_Dict["Long_Position"][2],  # Core.Int64(3),  # P2  # 依據市值高低分組選股的分類數目;
                                    #     MarketTiming_Parameter_Dict,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
                                    #     MarketTiming,
                                    #     MarketTiming_fit_model,
                                    #     Quantitative_Indicators_Function,
                                    #     "Long_Position"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
                                    # );
                                    # PickStock_ticker_symbol_Array_testing_data_Long_Position = return_PickStock_fit_model["PickStock_sort"]["ticker_symbol"];
                                    # return_PickStock_fit_model = Core.nothing;  # 釋放内存;
                                    # return_PickStock_fit_model = PickStock_fit_model(
                                    #     testingData,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # ::Core.Array{Core.Float64, 2} = testingData,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
                                    #     PickStock_Parameter_Dict["Short_Selling"][1],  # Core.Int64(3),  # P1,  # 觀察收益率歷史向前推的交易日長度;
                                    #     PickStock_Parameter_Dict["Short_Selling"][2],  # Core.Int64(10),  # P2  # 依據市值高低分組選股的分類數目;
                                    #     MarketTiming_Parameter_Dict,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
                                    #     MarketTiming,
                                    #     MarketTiming_fit_model,
                                    #     Quantitative_Indicators_Function,
                                    #     "Short_Selling"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
                                    # );
                                    # PickStock_ticker_symbol_Array_testing_data_Short_Selling = return_PickStock_fit_model["PickStock_sort"]["ticker_symbol"];
                                    # return_PickStock_fit_model = Core.nothing;  # 釋放内存;
                                    # # println("optimization - y_profit = ", return_PickStock_fit_model["y_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    # # println("Long Position optimization - y_profit = ", return_PickStock_fit_model["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    # # println("Short Selling optimization - y_profit = ", return_PickStock_fit_model["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    # # println("optimization - y_loss = ", return_PickStock_fit_model["y_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                    # # println("Long Position optimization - y_loss = ", return_PickStock_fit_model["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                    # # println("Short Selling optimization - y_loss = ", return_PickStock_fit_model["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                    # # println("maximum_drawdown = ", return_PickStock_fit_model["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                    # # println("maximum_drawdown_Long_Position = ", return_PickStock_fit_model["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                    # # println("maximum_drawdown_Short_Selling = ", return_PickStock_fit_model["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                    # # println("profit_total = ", return_PickStock_fit_model["profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
                                    # # println("Long_Position_profit_total = ", return_PickStock_fit_model["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
                                    # # println("Short_Selling_profit_total = ", return_PickStock_fit_model["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
                                    # # println("profit_Positive = ", return_PickStock_fit_model["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                    # # println("Long_Position_profit_Positive = ", return_PickStock_fit_model["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                    # # println("Short_Selling_profit_Positive = ", return_PickStock_fit_model["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                    # # println("profit_Positive_probability = ", return_PickStock_fit_model["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                    # # println("Long_Position_profit_Positive_probability = ", return_PickStock_fit_model["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                    # # println("Short_Selling_profit_Positive_probability = ", return_PickStock_fit_model["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                    # # println("profit_Negative = ", return_PickStock_fit_model["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                    # # println("Long_Position_profit_Negative = ", return_PickStock_fit_model["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                    # # println("Short_Selling_profit_Negative = ", return_PickStock_fit_model["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                    # # println("profit_Negative_probability = ", return_PickStock_fit_model["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                    # # println("Long_Position_profit_Negative_probability = ", return_PickStock_fit_model["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                    # # println("Short_Selling_profit_Negative_probability = ", return_PickStock_fit_model["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                    # # println("average_price_amplitude_date_transaction = ", return_PickStock_fit_model["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                    # # println("Long_Position_average_price_amplitude_date_transaction = ", return_PickStock_fit_model["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                    # # println("Short_Selling_average_price_amplitude_date_transaction = ", return_PickStock_fit_model["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                    # # println("average_volume_turnover_date_transaction = ", return_PickStock_fit_model["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                    # # println("Long_Position_average_volume_turnover_date_transaction = ", return_PickStock_fit_model["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                    # # println("Short_Selling_average_volume_turnover_date_transaction = ", return_PickStock_fit_model["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                    # # println("average_date_transaction_between = ", return_PickStock_fit_model["average_date_transaction_between"]);  # 兩次交易間隔日長，均值;
                                    # # println("Long_Position_average_date_transaction_between = ", return_PickStock_fit_model["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                                    # # println("Short_Selling_average_date_transaction_between = ", return_PickStock_fit_model["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                                    # # println("number_PickStock_transaction = ", return_PickStock_fit_model["number_PickStock_transaction"]);  # 交易過股票的總隻數;
                                    # # println("weight_PickStock = ", return_PickStock_fit_model["weight_PickStock"]);  # 選股權重，每隻股票的盈利概率占比;
                                    # # println(return_PickStock_fit_model["PickStock_sort"]);  # 依照選股規則排序篩選出的股票代碼字符串和得分存儲字典（Dict）;
                                    # # println(return_PickStock_fit_model["PickStock_sort"]["ticker_symbol"]);  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;
                                    # # println(return_PickStock_fit_model["PickStock_sort"]["score"]);  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]);
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]);
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
                                    # # println(return_PickStock_fit_model["PickStock_transaction_sequence"]["ticker_symbol"]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;

                                    if Core.Int64(minimum_dates_transaction_testing_data) > Core.Int64(0)
                                        PickStock_ticker_symbol_Array_testing_data_Long_Position = [PickStock_ticker_symbol_Array_testing_data_Long_Position for i = 1:Core.Int64(minimum_dates_transaction_testing_data)];
                                        PickStock_ticker_symbol_Array_testing_data_Short_Selling = [PickStock_ticker_symbol_Array_testing_data_Short_Selling for i = 1:Core.Int64(minimum_dates_transaction_testing_data)];
                                    end

                                    # # 倉位優化;
                                    # # SizePosition_Parameter_Array = Core.Array{Core.Any, 1}();  # 依照倉位規則優化之後得到的倉位數據存儲字典;
                                    # # weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
                                    # # weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
                                    # # investment_method = "Long_Position"
                                    # return_SizePosition = SizePosition(
                                    #     training_data = testingData,  # ::Core.Array{Core.Float64, 2} = testingData,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
                                    #     testing_data = testingData,  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
                                    #     Pdata_0 = SizePosition_Pdata_0,  # [weight_MarketTiming_Dict, weight_PickStock_Dict],  # testingData["002611"]["Pdata_0"],
                                    #     weight = SizePosition_weight,  # Core.Array{Core.Float64, 1}(),  # testingData["002611"]["weight"],
                                    #     Plower = SizePosition_Plower,  # [Plower_weight_MarketTiming_Dict, Plower_weight_PickStock_Dict],
                                    #     Pupper = SizePosition_Pupper,  # [Pupper_weight_MarketTiming_Dict, Pupper_weight_PickStock_Dict],
                                    #     MarketTiming_Parameter = MarketTiming_Parameter_Dict,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
                                    #     PickStock_Parameter = PickStock_Parameter_Dict,  # 按照選股規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
                                    #     PickStock_ticker_symbol = PickStock_ticker_symbol_Array_testing_data_Long_Position,  # PickStock_ticker_symbol_Array,  # Core.Array{Core.Any, 1}(),  # ::Core.Array{Core.Array{Core.String, 1}, 1} = Core.Array{Core.Array{Core.String, 1}, 1}(),  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;
                                    #     SizePosition_fit_model = SizePosition_fit_model,
                                    #     PickStock = PickStock,
                                    #     PickStock_fit_model = PickStock_fit_model,
                                    #     MarketTiming = MarketTiming,
                                    #     MarketTiming_fit_model = MarketTiming_fit_model,
                                    #     Quantitative_Indicators_Function = Quantitative_Indicators_Function,
                                    #     investment_method = "Long_Position"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
                                    # );
                                    # # println("optimization - coefficient 1 - weight_MarketTiming :", "\n", return_SizePosition["Coefficient"][1], "optimization - coefficient 2 - weight_PickStock :", "\n", return_SizePosition["Coefficient"][2]);  # 最優化計算之後得到的參數;
                                    # # # println("optimization - coefficient StandardDeviation : ", return_SizePosition["Coefficient-StandardDeviation"]);  # 擬合得到的參數解的標準差;
                                    # # # println("optimization - coefficient Confidence Lower 95% : ", return_SizePosition["Coefficient-Confidence-Lower-95%"]);  # 擬合得到的參數解的區間估計下限;
                                    # # # println("optimization - coefficient Confidence Upper 95% : ", return_SizePosition["Coefficient-Confidence-Upper-95%"]);  # 擬合得到的參數解的區間估計上限;
                                    # # # println("y - fit : ", return_SizePosition["Yfit"]);  # 擬合 y 值;
                                    # # # println("y - fit Uncertainty Lower : ", return_SizePosition["Yfit-Uncertainty-Lower"]);  # 擬合的應變量 Yvals 誤差下限;
                                    # # # println("y - fit Uncertainty Upper : ", return_SizePosition["Yfit-Uncertainty-Upper"]);  # 擬合的應變量 Yvals 誤差上限;
                                    # # # println("residual : ", return_SizePosition["Residual"]);  # 擬合殘差;
                                    # # println("y_profit : ", return_SizePosition["y_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    # # println("y_Long_Position_profit : ", return_SizePosition["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    # # println("y_Short_Selling_profit : ", return_SizePosition["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    # # println("y_loss : ", return_SizePosition["y_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                    # # println("y_Long_Position_loss : ", return_SizePosition["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                    # # println("y_Short_Selling_loss : ", return_SizePosition["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                    # # println("maximum_drawdown : ", return_SizePosition["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                    # # println("maximum_drawdown_Long_Position : ", return_SizePosition["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                    # # println("maximum_drawdown_Short_Selling : ", return_SizePosition["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                    # # println("profit total per share : ", return_SizePosition["profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
                                    # # println("Long Position profit total per share : ", return_SizePosition["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
                                    # # println("Short Selling profit total per share : ", return_SizePosition["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
                                    # # println("profit Positive : ", return_SizePosition["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                    # # println("Long Position profit Positive : ", return_SizePosition["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                    # # println("Short Selling_profit Positive : ", return_SizePosition["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                    # # println("profit Positive probability : ", return_SizePosition["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                    # # println("Long Position profit Positive probability : ", return_SizePosition["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                    # # println("Short Selling profit Positive probability : ", return_SizePosition["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                    # # println("profit Negative : ", return_SizePosition["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                    # # println("Long Position profit Negative : ", return_SizePosition["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                    # # println("Short Selling profit Negative : ", return_SizePosition["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                    # # println("profit Negative probability : ", return_SizePosition["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                    # # println("Long Position profit Negative probability : ", return_SizePosition["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                    # # println("Short Selling profit Negative probability : ", return_SizePosition["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                    # # println("average price amplitude date transaction : ", return_SizePosition["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                    # # println("Long Position average price amplitude date transaction : ", return_SizePosition["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                    # # println("Short Selling average price amplitude date transaction : ", return_SizePosition["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                    # # println("average volume turnover date transaction : ", return_SizePosition["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                    # # println("Long Position average volume turnover date transaction : ", return_SizePosition["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                    # # println("Short Selling average volume turnover date transaction : ", return_SizePosition["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                    # # println("average date transaction between : ", return_SizePosition["average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                                    # # println("Long Position average date transaction between : ", return_SizePosition["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                                    # # println("Short Selling average date transaction between : ", return_SizePosition["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                                    # # println("number SizePosition transaction : ", return_SizePosition["number_PickStock_transaction"]);  # 交易過股票的總隻數，函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]);  # 記錄按規則篩選股票按照擇時規則交易信息的序列字典（Dict）;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]);  # 記錄按規則篩選股票按照擇時規則交易信息的序列字典（Dict）;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
                                    # # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
                                    # # println("test profit estimate : ", return_SizePosition["test_profit"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
                                    # # println("test odds ratio estimate : ", return_SizePosition["test_odds_ratio"]);
                                    # # println("test date transaction between : ", return_SizePosition["test_date_transaction_between"]);
                                    # # # println(return_SizePosition["testData"]);;  # 傳入測試數據集的計算結果;
                                    # # println("test profit total per share : ", return_SizePosition["testData"]["profit_total"]);
                                    # # println("test Long Position profit total per share : ", return_SizePosition["testData"]["Long_Position_profit_total"]);
                                    # # println("test Short Selling profit total per share : ", return_SizePosition["testData"]["Short_Selling_profit_total"]);
                                    # # println("test profit positive per share : ", return_SizePosition["testData"]["profit_Positive"]);
                                    # # println("test Long Position profit positive per share : ", return_SizePosition["testData"]["Long_Position_profit_Positive"]);
                                    # # println("test Short Selling profit positive per share : ", return_SizePosition["testData"]["Short_Selling_profit_Positive"]);
                                    # # println("test profit positive probability : ", return_SizePosition["testData"]["profit_Positive_probability"]);
                                    # # println("test Long Position profit positive probability : ", return_SizePosition["testData"]["Long_Position_profit_Positive_probability"]);
                                    # # println("test Short Selling profit positive probability : ", return_SizePosition["testData"]["Short_Selling_profit_Positive_probability"]);
                                    # # println("test profit negative per share : ", return_SizePosition["testData"]["profit_Negative"]);
                                    # # println("test Long Position profit negative per share : ", return_SizePosition["testData"]["Long_Position_profit_Negative"]);
                                    # # println("test Short Selling profit negative per share : ", return_SizePosition["testData"]["Short_Selling_profit_Negative"]);
                                    # # println("test profit negative probability : ", return_SizePosition["testData"]["profit_Negative_probability"]);
                                    # # println("test Long Position profit negative probability : ", return_SizePosition["testData"]["Long_Position_profit_Negative_probability"]);
                                    # # println("test Short Selling profit negative probability : ", return_SizePosition["testData"]["Short_Selling_profit_Negative_probability"]);
                                    # # println("test average date transaction between : ", return_SizePosition["testData"]["average_date_transaction_between"]);
                                    # # println("test Long Position average date transaction between : ", return_SizePosition["testData"]["Long_Position_average_date_transaction_between"]);
                                    # # println("test Short Selling average date transaction between : ", return_SizePosition["testData"]["Short_Selling_average_date_transaction_between"]);
                                    # # println("test number SizePosition transaction : ", return_SizePosition["testData"]["number_PickStock_transaction"]);  # 交易過股票的總隻數;
                                    # # # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]["P1_Array"]);
                                    # # # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"]);
                                    # # # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"]);
                                    # # # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]);
                                    # # weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
                                    # # weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
                                    # if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 1 && Base.isa(return_SizePosition["Coefficient"][1], Base.Dict)
                                    #     for (key, value) in return_SizePosition["Coefficient"][1]
                                    #         # println("Key: $key, Value: $value");
                                    #         if Base.isa(value, Base.Dict) && Base.haskey(value, "Long_Position")
                                    #             if Base.isa(weight_MarketTiming_Dict, Base.Dict) && Base.haskey(weight_MarketTiming_Dict, Base.string(key))
                                    #                 if Base.isa(weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
                                    #                     weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
                                    #                 end
                                    #             elseif Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
                                    #                 weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                    #                 weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
                                    #             else
                                    #             end
                                    #         end
                                    #     end
                                    # end
                                    # if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 2 && Base.isa(return_SizePosition["Coefficient"][2], Base.Dict)
                                    #     for (key, value) in return_SizePosition["Coefficient"][2]
                                    #         # println("Key: $key, Value: $value");
                                    #         if Base.isa(value, Base.Dict) && Base.haskey(value, "Long_Position")
                                    #             if Base.isa(weight_PickStock_Dict, Base.Dict) && Base.haskey(weight_PickStock_Dict, Base.string(key))
                                    #                 if Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict)
                                    #                     weight_PickStock_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
                                    #                 end
                                    #             elseif Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
                                    #                 weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                    #                 weight_PickStock_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
                                    #             else
                                    #             end
                                    #         end
                                    #     end
                                    # end
                                    # return_SizePosition = Core.nothing;  # 釋放内存;
                                    # # investment_method = "Short_Selling"
                                    # return_SizePosition = SizePosition(
                                    #     training_data = testingData,  # ::Core.Array{Core.Float64, 2} = testingData,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
                                    #     testing_data = testingData,  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
                                    #     Pdata_0 = SizePosition_Pdata_0,  # [weight_MarketTiming_Dict, weight_PickStock_Dict],  # testingData["002611"]["Pdata_0"],
                                    #     weight = SizePosition_weight,  # Core.Array{Core.Float64, 1}(),  # testingData["002611"]["weight"],
                                    #     Plower = SizePosition_Plower,  # [Plower_weight_MarketTiming_Dict, Plower_weight_PickStock_Dict],
                                    #     Pupper = SizePosition_Pupper,  # [Pupper_weight_MarketTiming_Dict, Pupper_weight_PickStock_Dict],
                                    #     MarketTiming_Parameter = MarketTiming_Parameter_Dict,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
                                    #     PickStock_Parameter = PickStock_Parameter_Dict,  # 按照選股規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
                                    #     PickStock_ticker_symbol = PickStock_ticker_symbol_Array_testing_data_Short_Selling,  # PickStock_ticker_symbol_Array,  # Core.Array{Core.Any, 1}(),  # ::Core.Array{Core.Array{Core.String, 1}, 1} = Core.Array{Core.Array{Core.String, 1}, 1}(),  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;
                                    #     SizePosition_fit_model = SizePosition_fit_model,
                                    #     PickStock = PickStock,
                                    #     PickStock_fit_model = PickStock_fit_model,
                                    #     MarketTiming = MarketTiming,
                                    #     MarketTiming_fit_model = MarketTiming_fit_model,
                                    #     Quantitative_Indicators_Function = Quantitative_Indicators_Function,
                                    #     investment_method = "Short_Selling"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
                                    # );
                                    # # weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
                                    # # weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
                                    # if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 1 && Base.isa(return_SizePosition["Coefficient"][1], Base.Dict)
                                    #     for (key, value) in return_SizePosition["Coefficient"][1]
                                    #         # println("Key: $key, Value: $value");
                                    #         if Base.isa(value, Base.Dict) && Base.haskey(value, "Short_Selling")
                                    #             if Base.isa(weight_MarketTiming_Dict, Base.Dict) && Base.haskey(weight_MarketTiming_Dict, Base.string(key))
                                    #                 if Base.isa(weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
                                    #                     weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
                                    #                 end
                                    #             elseif Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
                                    #                 weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                    #                 weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
                                    #             else
                                    #             end
                                    #         end
                                    #     end
                                    # end
                                    # if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 2 && Base.isa(return_SizePosition["Coefficient"][2], Base.Dict)
                                    #     for (key, value) in return_SizePosition["Coefficient"][2]
                                    #         # println("Key: $key, Value: $value");
                                    #         if Base.isa(value, Base.Dict) && Base.haskey(value, "Short_Selling")
                                    #             if Base.isa(weight_PickStock_Dict, Base.Dict) && Base.haskey(weight_PickStock_Dict, Base.string(key))
                                    #                 if Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict)
                                    #                     weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
                                    #                 end
                                    #             elseif Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
                                    #                 weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                    #                 weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
                                    #             else
                                    #             end
                                    #         end
                                    #     end
                                    # end
                                    # return_SizePosition = Core.nothing;  # 釋放内存;
                                    # SizePosition_Parameter_Array = [weight_MarketTiming_Dict, weight_PickStock_Dict];
                                    # # # println(SizePosition_Parameter_Array);
                                    # # println("optimization - coefficient 1 - weight_MarketTiming :", "\n", SizePosition_Parameter_Array[1]);  # 最優化計算之後得到的參數;
                                    # # println("optimization - coefficient 2 - weight_PickStock :", "\n", SizePosition_Parameter_Array[2]);  # 最優化計算之後得到的參數;
                                    # # return_SizePosition_fit_model = SizePosition_fit_model(
                                    # #     testingData,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # ::Core.Array{Core.Float64, 2} = testingData,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
                                    # #     SizePosition_Parameter_Array[1],  # weight_MarketTiming_Dict,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 股票擇時交易倉位占比;
                                    # #     SizePosition_Parameter_Array[2],  # weight_PickStock_Dict,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 選股組合占比;
                                    # #     MarketTiming_Parameter_Dict,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
                                    # #     PickStock_Parameter_Dict,  # 按照選股規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
                                    # #     PickStock_ticker_symbol_Array_testing_data_Long_Position,  # PickStock_ticker_symbol_Array,  # = Core.Array{Core.Any, 1}(),  # ::Core.Array{Core.Array{Core.String, 1}, 1} = Core.Array{Core.Array{Core.String, 1}, 1}(),  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;
                                    # #     PickStock,
                                    # #     PickStock_fit_model,
                                    # #     MarketTiming,
                                    # #     MarketTiming_fit_model,
                                    # #     Quantitative_Indicators_Function,
                                    # #     "Long_Position"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
                                    # # );
                                    # # println("y_profit = ", return_SizePosition_fit_model["y_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    # # println("y_Long_Position_profit = ", return_SizePosition_fit_model["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    # # println("y_Short_Selling_profit = ", return_SizePosition_fit_model["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    # # println("y_loss = ", return_SizePosition_fit_model["y_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                    # # println("y_Long_Position_loss = ", return_SizePosition_fit_model["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                    # # println("y_Short_Selling_loss = ", return_SizePosition_fit_model["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                    # # println("maximum_drawdown = ", return_SizePosition_fit_model["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                    # # println("maximum_drawdown_Long_Position = ", return_SizePosition_fit_model["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                    # # println("maximum_drawdown_Short_Selling = ", return_SizePosition_fit_model["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                    # # println("profit_total = ", return_SizePosition_fit_model["profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                    # # println("Long_Position_profit_total = ", return_SizePosition_fit_model["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                    # # println("Short_Selling_profit_total = ", return_SizePosition_fit_model["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                    # # println("profit_Positive = ", return_SizePosition_fit_model["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                    # # println("profit_Negative = ", return_SizePosition_fit_model["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                    # # println("Long_Position_profit_Positive = ", return_SizePosition_fit_model["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                    # # println("Long_Position_profit_Negative = ", return_SizePosition_fit_model["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                    # # println("Short_Selling_profit_Positive = ", return_SizePosition_fit_model["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                    # # println("Short_Selling_profit_Negative = ", return_SizePosition_fit_model["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                    # # println("profit_Positive_probability = ", return_SizePosition_fit_model["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                    # # println("profit_Negative_probability = ", return_SizePosition_fit_model["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                    # # println("Long_Position_profit_Positive_probability = ", return_SizePosition_fit_model["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                    # # println("Long_Position_profit_Negative_probability = ", return_SizePosition_fit_model["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                    # # println("Short_Selling_profit_Positive_probability = ", return_SizePosition_fit_model["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                    # # println("Short_Selling_profit_Negative_probability = ", return_SizePosition_fit_model["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                    # # println("average_price_amplitude_date_transaction = ", return_SizePosition_fit_model["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                    # # println("Long_Position_average_price_amplitude_date_transaction = ", return_SizePosition_fit_model["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                    # # println("Short_Selling_average_price_amplitude_date_transaction = ", return_SizePosition_fit_model["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                    # # println("average_volume_turnover_date_transaction = ", return_SizePosition_fit_model["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                    # # println("Long_Position_average_volume_turnover_date_transaction = ", return_SizePosition_fit_model["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                    # # println("Short_Selling_average_volume_turnover_date_transaction = ", return_SizePosition_fit_model["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                    # # println("average_date_transaction_between = ", return_SizePosition_fit_model["average_date_transaction_between"]);  # 兩次交易間隔日長，均值;
                                    # # println("Long_Position_average_date_transaction_between = ", return_SizePosition_fit_model["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                                    # # println("Short_Selling_average_date_transaction_between = ", return_SizePosition_fit_model["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                                    # # println("number_SizePosition_transaction = ", return_SizePosition_fit_model["number_PickStock_transaction"]);  # 交易過股票的總隻數;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]);
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
                                    # # # println(return_SizePosition_fit_model["SizePosition_transaction_sequence"]["002611"]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
                                    # # return_SizePosition_fit_model = Core.nothing;  # 釋放内存;

                                    # 記錄推進分析交易信息的序列;
                                    Long_Position_testing_data_transaction_sequence_Dict = Base.Dict{Core.String, Core.Any}();  # 記錄按規則篩選股票按照擇時規則交易信息的序列;
                                    # if Base.isa(testingData, Base.Dict) && Base.length(testingData) > 0
                                    #     for t = Core.Int64(1):Base.length(testing_data_ticker_symbol_Array)
                                    #         if (!(Base.ismissing(testing_data_ticker_symbol_Array[t]) || Base.isnothing(testing_data_ticker_symbol_Array[t])))
                                    #             if !(Base.haskey(testingData, Base.string(testing_data_ticker_symbol_Array[t])))
                                    #                 if !(Base.haskey(Long_Position_testing_data_transaction_sequence_Dict, Base.string(testing_data_ticker_symbol_Array[t])))
                                    #                     Long_Position_testing_data_transaction_sequence_Dict[Base.string(testing_data_ticker_symbol_Array[t])] = Base.Dict{Core.String, Core.Any}();
                                    #                     # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling）;
                                    #                     Long_Position_testing_data_transaction_sequence_Dict[Base.string(testing_data_ticker_symbol_Array[t])]["revenue_and_expenditure_records_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
                                    #                     # 做多（Long Position）記錄;
                                    #                     Long_Position_testing_data_transaction_sequence_Dict[Base.string(testing_data_ticker_symbol_Array[t])]["Long_Position_profit_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 每兩次對衝交易價格差值利潤，向量;
                                    #                     # Long_Position_testing_data_transaction_sequence_Dict[Base.string(testing_data_ticker_symbol_Array[t])]["Long_Position_price_amplitude_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 兩次對衝交易日成交價振幅平方和，向量;
                                    #                     # Long_Position_testing_data_transaction_sequence_Dict[Base.string(testing_data_ticker_symbol_Array[t])]["Long_Position_volume_turnover_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 兩次對衝交易日成交量（換手率）向量;
                                    #                     # Long_Position_testing_data_transaction_sequence_Dict[Base.string(testing_data_ticker_symbol_Array[t])]["Long_Position_date_transaction_between"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 兩次對衝交易間隔日長，向量;
                                    #                     Long_Position_testing_data_transaction_sequence_Dict[Base.string(testing_data_ticker_symbol_Array[t])]["Long_Position_date_transaction"] = Core.Array{Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}, 1}();  # Core.Array{Core.Any, 1}();  # 按規則執行交易的日期，向量;
                                    #                     Long_Position_testing_data_transaction_sequence_Dict[Base.string(testing_data_ticker_symbol_Array[t])]["Index_date_transaction_Long_Position"] = Core.Int64(0);  # 每兩次對衝交易序號標識;
                                    #                     Long_Position_testing_data_transaction_sequence_Dict[Base.string(testing_data_ticker_symbol_Array[t])]["Long_Position_drawdown_date_transaction"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                    #                 end
                                    #             end
                                    #         end
                                    #     end
                                    # end
                                    Short_Selling_testing_data_transaction_sequence_Dict = Base.Dict{Core.String, Core.Any}();  # 記錄按規則篩選股票按照擇時規則交易信息的序列;
                                    # if Base.isa(testingData, Base.Dict) && Base.length(testingData) > 0
                                    #     for t = Core.Int64(1):Base.length(testing_data_ticker_symbol_Array)
                                    #         if (!(Base.ismissing(testing_data_ticker_symbol_Array[t]) || Base.isnothing(testing_data_ticker_symbol_Array[t])))
                                    #             if !(Base.haskey(testingData, Base.string(testing_data_ticker_symbol_Array[t])))
                                    #                 if !(Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict, Base.string(testing_data_ticker_symbol_Array[t])))
                                    #                     Short_Selling_testing_data_transaction_sequence_Dict[Base.string(testing_data_ticker_symbol_Array[t])] = Base.Dict{Core.String, Core.Any}();
                                    #                     # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling）;
                                    #                     Short_Selling_testing_data_transaction_sequence_Dict[Base.string(testing_data_ticker_symbol_Array[t])]["revenue_and_expenditure_records_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
                                    #                     # 做空（Short Selling）記錄;
                                    #                     Short_Selling_testing_data_transaction_sequence_Dict[Base.string(testing_data_ticker_symbol_Array[t])]["Short_Selling_profit_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 每兩次對衝交易價格差值利潤，向量;
                                    #                     # Short_Selling_testing_data_transaction_sequence_Dict[Base.string(testing_data_ticker_symbol_Array[t])]["Short_Selling_price_amplitude_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 兩次對衝交易日成交價振幅平方和，向量;
                                    #                     # Short_Selling_testing_data_transaction_sequence_Dict[Base.string(testing_data_ticker_symbol_Array[t])]["Short_Selling_volume_turnover_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 兩次對衝交易日成交量（換手率）向量;
                                    #                     # Short_Selling_testing_data_transaction_sequence_Dict[Base.string(testing_data_ticker_symbol_Array[t])]["Short_Selling_date_transaction_between"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 兩次對衝交易間隔日長，向量;
                                    #                     Short_Selling_testing_data_transaction_sequence_Dict[Base.string(testing_data_ticker_symbol_Array[t])]["Short_Selling_date_transaction"] = Core.Array{Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}, 1}();  # Core.Array{Core.Any, 1}();  # 按規則執行交易的日期，向量;
                                    #                     Short_Selling_testing_data_transaction_sequence_Dict[Base.string(testing_data_ticker_symbol_Array[t])]["Index_date_transaction_Short_Selling"] = Core.Int64(0);  # 每兩次對衝交易序號標識;
                                    #                     Short_Selling_testing_data_transaction_sequence_Dict[Base.string(testing_data_ticker_symbol_Array[t])]["Short_Selling_drawdown_date_transaction"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 向量，記錄做空模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                    #                 end
                                    #             end
                                    #         end
                                    #     end
                                    # end

                                    # 祇取測試數據集的最後一個交易日數據，代入交易規則，判斷交易狀態;
                                    # 依照選股規則挑選出的股票，計算（融資做多 buying long）交易利潤;
                                    t = Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position));  # Core.Int64(minimum_dates_transaction_testing_data);  # Core.Int64(maximum_dates_transaction_testing_data);  # Core.Int64(1);
                                    if investment_method === "Long_Position_and_Short_Selling" || investment_method === "Long_Position"

                                        if Core.Int64(t) > Core.Int64(0) && Core.Int64(t) <= Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))
                                            if (!(Base.ismissing(PickStock_ticker_symbol_Array_testing_data_Long_Position[t]) || Base.isnothing(PickStock_ticker_symbol_Array_testing_data_Long_Position[t]))) && Base.typeof(PickStock_ticker_symbol_Array_testing_data_Long_Position[t]) <: Core.Array
                                                # 依照選股規則挑選出的股票，計算（融資做多 buying long）交易利潤;
                                                if Base.haskey(PickStock_Parameter_Dict, "Long_Position")
                                                    g_min = Core.Int64(Base.findmin([Core.Int64(PickStock_Parameter_Dict["Long_Position"][2]), Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position[t]))])[1]);
                                                else
                                                    g_min = Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position[t]));
                                                end
                                                for g = Core.Int64(1):Core.Int64(g_min)
                                                    if Core.Int64(g) >= Core.Int64(1) && Core.Int64(g) <= Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position[t]))
                                                        if (!(Base.ismissing(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]) || Base.isnothing(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]))) && Base.typeof(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]) <: Core.String
                                                            if Base.isa(testingData, Base.Dict) && Base.haskey(testingData, PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]) && Base.isa(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]], Base.Dict) && Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]) > 0
                                                                # 判斷循環遍歷「t」小於序列數據（1 維數組）的最大長度，並跳過超出的部分;
                                                                if Core.Int64(t) <= Core.Int64(Base.findmin([Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["date_transaction"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["turnover_volume"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["opening_price"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["close_price"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["low_price"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["high_price"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["focus"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["amplitude"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["amplitude_rate"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["opening_price_Standardization"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["closing_price_Standardization"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["low_price_Standardization"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["high_price_Standardization"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["turnover_volume_growth_rate"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["opening_price_growth_rate"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["closing_price_growth_rate"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["closing_minus_opening_price_growth_rate"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["high_price_proportion"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["low_price_proportion"])])[1])
                                                                    if Base.haskey(MarketTiming_Parameter_Dict, Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])) && Base.haskey(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]], "Long_Position") && Core.Int64(t) >= Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2))

                                                                        x0 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["date_transaction"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 交易日期;
                                                                        x1 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["turnover_volume"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 成交量;
                                                                        # x2 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["turnover_amount"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 成交總金額;
                                                                        x3 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["opening_price"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 開盤成交價;
                                                                        x4 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["close_price"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤成交價;
                                                                        x5 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["low_price"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 最低成交價;
                                                                        x6 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["high_price"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 最高成交價;
                                                                        x7 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["focus"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 當日成交價重心;
                                                                        x8 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["amplitude"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 當日成交價絕對振幅;
                                                                        x9 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["amplitude_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 當日成交價相對振幅（%）;
                                                                        x10 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["opening_price_Standardization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 日棒缐（K Line Daily）數據交易日首筆成交價（開盤價）標準化值;
                                                                        x11 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["closing_price_Standardization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 日棒缐（K Line Daily）數據交易日尾筆成交價（收盤價）標準化值;
                                                                        x12 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["low_price_Standardization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 日棒缐（K Line Daily）數據交易日最低成交價標準化值;
                                                                        x13 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["high_price_Standardization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 日棒缐（K Line Daily）數據交易日最高成交價標準化值;
                                                                        x14 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["turnover_volume_growth_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 成交量的成長率;
                                                                        x15 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["opening_price_growth_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 開盤價的成長率;
                                                                        x16 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["closing_price_growth_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價的成長率;
                                                                        x17 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["closing_minus_opening_price_growth_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價減開盤價的成長率;
                                                                        x18 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["high_price_proportion"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價和開盤價裏的最大值占最高價的比例;
                                                                        x19 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["low_price_proportion"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 最低價占收盤價和開盤價裏的最小值的比例;
                                                                        # x20 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["turnover_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 成交量換手率;
                                                                        # x21 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["price_earnings"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 每股收益（公司經營利潤率 ÷ 股本）;
                                                                        # x22 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["book_value_per_share"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 每股净值（公司净資產 ÷ 股本）;
                                                                        # x23 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["capitalization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 總市值;
                                                                        # x24 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["moving_average_5"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價 5 日滑動平均缐;
                                                                        # x25 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["moving_average_10"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價 10 日滑動平均缐;
                                                                        # x26 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["moving_average_20"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價 20 日滑動平均缐;
                                                                        # x27 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["moving_average_30"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價 30 日滑動平均缐;
                                                                        # x_Pdata_0 = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Pdata_0"];
                                                                        # x_Plower = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Plower"];
                                                                        # x_Pupper = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["Pupper"];
                                                                        # x_weight = testingData[PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]]["weight"];

                                                                        # 記錄每個交易日的回撤值序列;
                                                                        risk_threshold_drawdown_loss = Core.Float64(MarketTiming_Parameter_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position"][4]);  # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                        # risk_threshold_drawdown_loss = Core.Float64(0.0);
                                                                        risk_drawdown_loss_Long_Position = Core.Float64(Core.Float64(risk_threshold_drawdown_loss) + Core.Float64(0.1));  # 回撤比例初值，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;

                                                                        # 標示融資做多 buying long 兩次對衝交易滑框的左邊（首，第一次，買入交易 buy）或右邊（尾，第二次，賣出交易 sell），取值爲 1 時表示滑框的左邊（首，第一次，買入交易 buy），取值爲 0 時表示滑框的右邊（尾，第二次，賣出交易 sell），預設值爲 1 ，即取滑框的左邊（首，第一次，買入交易 buy）;
                                                                        Long_Position_sliding_frame = Core.Int64(1);  # 標示融資做多 buying long 兩次對衝交易滑框的左邊（首，第一次，買入交易 buy）或右邊（尾，第二次，賣出交易 sell），取值爲 1 時表示滑框的左邊（首，第一次，買入交易 buy），取值爲 0 時表示滑框的右邊（尾，第二次，賣出交易 sell），預設值爲 1 ，即取滑框的左邊（首，第一次，買入交易 buy）;

                                                                        # 判斷、執行做多 buying long 兩次對衝交易滑框的右邊（尾，第二次，賣出交易 sell）;
                                                                        if Base.typeof(stepping_sequence_Array) <: Core.Array && Core.Int64(Base.length(stepping_sequence_Array)) > Core.Int64(0)
                                                                            if Base.isa(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))], Base.Dict) && Base.haskey(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))], "testing_transaction")
                                                                                # 依照選股規則挑選出的股票，計算（融資做多 buying long）交易利潤;
                                                                                if Base.isa(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"], Base.Dict) && Base.haskey(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"], "Long_Position")
                                                                                    if Base.isa(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"], Base.Dict) && Base.haskey(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"], Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]))
                                                                                        if Base.isa(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], Base.Dict) && Base.haskey(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position_date_transaction")
                                                                                            if Base.typeof(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]) <: Core.Array && Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"])) >= Core.Int64(0)
                                                                                                if Base.typeof(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))]) <: Core.Array && Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))])) >= Core.Int64(3)
                                                                                                    if Base.string(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))][2]) === "buy"

                                                                                                        # 標示融資做多 buying long 兩次對衝交易滑框的左邊（首，第一次，買入交易 buy）或右邊（尾，第二次，賣出交易 sell），取值爲 1 時表示滑框的左邊（首，第一次，買入交易 buy），取值爲 0 時表示滑框的右邊（尾，第二次，賣出交易 sell），預設值爲 1 ，即取滑框的左邊（首，第一次，買入交易 buy）;
                                                                                                        # 融資做多 buying long 兩次對衝交易類型，從滑框的左邊（首，第一次，買入交易 buy）修改爲滑框的右邊（尾，第二次，賣出交易 sell）;
                                                                                                        if Core.Int64(Long_Position_sliding_frame) >= Core.Int64(1)
                                                                                                            Long_Position_sliding_frame *= Core.Int64(0);
                                                                                                            Long_Position_sliding_frame += Core.Int64(0);
                                                                                                        end

                                                                                                        risk_drawdown_loss_Long_Position *= Core.Float64(0.0);
                                                                                                        risk_drawdown_loss_Long_Position += Core.Float64(Core.Float64(x3[Core.Int64(Base.length(x3))]) / Core.Float64(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))][3]));  # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                                        # risk_drawdown_loss_Long_Position += Core.Float64(Core.Float64(Base.abs(Core.Float64(x3[Core.Int64(Base.length(x3))]))) / Core.Float64(Base.abs(Core.Float64(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))][3]))));  # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;

                                                                                                        # 記錄做多模式每個交易日的回撤值序列;
                                                                                                        Base.push!(drawdown_Array_Long_Position, risk_drawdown_loss_Long_Position);  # 使用 push! 函數在數組末尾追加推入新元;

                                                                                                        # if Core.Float64(risk_drawdown_loss_Long_Position) <= Core.Float64(risk_threshold_drawdown_loss) || Core.Int64(k) === Core.Int64(minimum_dates_transaction)
                                                                                                        if Core.Float64(risk_drawdown_loss_Long_Position) <= Core.Float64(risk_threshold_drawdown_loss)

                                                                                                            # 做多（Long Position）記錄;
                                                                                                            if Base.isa(Long_Position_testing_data_transaction_sequence_Dict, Base.Dict) && (!(Base.haskey(Long_Position_testing_data_transaction_sequence_Dict, Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])) && Base.isa(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], Base.Dict)))
                                                                                                                Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])] = Base.Dict{Core.String, Core.Any}();
                                                                                                            end
                                                                                                            if Base.isa(Long_Position_testing_data_transaction_sequence_Dict, Base.Dict) && Base.haskey(Long_Position_testing_data_transaction_sequence_Dict, Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])) && Base.isa(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], Base.Dict)
                                                                                                                # 每兩次對衝交易序號標識;
                                                                                                                Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Index_date_transaction_Long_Position"] = Core.Int64(k);  # 每兩次對衝交易序號標識;
                                                                                                                # 按規則執行第二次對衝賣出（融資做多 buying long）交易的日期;
                                                                                                                if !(Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]) <: Core.Array)
                                                                                                                    Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                                                end
                                                                                                                if Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]) <: Core.Array
                                                                                                                    y_F_Long_Position_I = Core.Array{Core.Any, 1}(Core.undef, 16);  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}(Core.undef, 16);
                                                                                                                    y_F_Long_Position_I[1] = x0[Core.Int64(Base.length(x0))];  # 交易時間日期（Dates.Date 或 Dates.DateTime 類型）;
                                                                                                                    y_F_Long_Position_I[2] = Base.string("sell");  # 買入或賣出;
                                                                                                                    y_F_Long_Position_I[3] = x3[Core.Int64(Base.length(x3))];  # 成交價;
                                                                                                                    if Core.Int64(Base.length(SizePosition_Parameter_Array)) >= Core.Int64(2) && Base.haskey(SizePosition_Parameter_Array[1], Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])) && Base.haskey(SizePosition_Parameter_Array[1][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position") && Base.haskey(SizePosition_Parameter_Array[2], Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])) && Base.haskey(SizePosition_Parameter_Array[2][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position")
                                                                                                                        y_F_Long_Position_I[4] = [SizePosition_Parameter_Array[1][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position"], SizePosition_Parameter_Array[2][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position"]];  # 倉位;
                                                                                                                    else
                                                                                                                        y_F_Long_Position_I[4] = [Core.Float64(1.0), Core.Float64(1.0)];  # 倉位;
                                                                                                                    end
                                                                                                                    if Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Index_date_transaction_Long_Position")
                                                                                                                        y_F_Long_Position_I[5] = Core.Int64(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Index_date_transaction_Long_Position"]);  # 每兩次對衝成交序號標識;
                                                                                                                    else
                                                                                                                        y_F_Long_Position_I[5] = Core.Int64(0);  # 每兩次對衝成交序號標識;
                                                                                                                    end
                                                                                                                    y_F_Long_Position_I[6] = Core.Int64(k);  # 交易日期的序列號，用於繪圖可視化;
                                                                                                                    y_F_Long_Position_I[7] = x0[Core.Int64(Base.length(x0))];  # 交易日（Dates.Date 類型）;
                                                                                                                    y_F_Long_Position_I[8] = x1[Core.Int64(Base.length(x1))];  # 當日總成交量（turnover volume）;
                                                                                                                    y_F_Long_Position_I[9] = x3[Core.Int64(Base.length(x3))];  # 當日開盤（opening）成交價;
                                                                                                                    y_F_Long_Position_I[10] = x4[Core.Int64(Base.length(x4))];  # 當日收盤（closing）成交價;
                                                                                                                    y_F_Long_Position_I[11] = x5[Core.Int64(Base.length(x5))];  # 當日最低（low）成交價;
                                                                                                                    y_F_Long_Position_I[12] = x6[Core.Int64(Base.length(x6))];  # 當日最高（high）成交價;
                                                                                                                    # y_F_Long_Position_I[13] = x2[Core.Int64(Base.length(x2))];  # 當日總成交金額（turnover amount）;
                                                                                                                    # y_F_Long_Position_I[14] = x20[Core.Int64(Base.length(x20))];  # 當日成交量（turnover volume）換手率（turnover rate）;
                                                                                                                    # y_F_Long_Position_I[15] = x21[Core.Int64(Base.length(x21))];  # 當日每股收益（price earnings）;
                                                                                                                    # y_F_Long_Position_I[16] = x22[Core.Int64(Base.length(x22))];  # 當日每股净值（book value per share）;
                                                                                                                    Base.push!(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"], y_F_Long_Position_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                                    y_F_Long_Position_I = Core.nothing;  # 釋放内存;
                                                                                                                end
                                                                                                                # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling）;
                                                                                                                if !(Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array)
                                                                                                                    Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                                                end
                                                                                                                if Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array
                                                                                                                    y_G_Long_Position_I = Core.Float64(+Core.Float64(x3[Core.Int64(Base.length(x3))]));
                                                                                                                    Base.push!(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"], y_G_Long_Position_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                                    y_G_Long_Position_I = Core.nothing;  # 釋放内存;
                                                                                                                end
                                                                                                                # 每兩次對衝交易差價利潤初值;
                                                                                                                if !(Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position_profit_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_date_transaction"]) <: Core.Array)
                                                                                                                    Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                                                end
                                                                                                                if Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position_profit_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_date_transaction"]) <: Core.Array
                                                                                                                    y_A_Long_Position_I_2 = Core.Float64(+Core.Float64(x3[Core.Int64(Base.length(x3))]));
                                                                                                                    y_A_Long_Position_I = Core.Float64(y_A_Long_Position_I_2);
                                                                                                                    # y_A_Long_Position_I *= Core.Float64(0.0);
                                                                                                                    # y_A_Long_Position_I += Core.Float64(y_A_Long_Position_I_2);
                                                                                                                    # y_A_Long_Position_I += Core.Float64(x3[t + 1] - x3[k + 1]);
                                                                                                                    # y_A_Long_Position_I = Core.Float64(x3[t + 1] - x3[k + 1]);
                                                                                                                    Base.push!(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_date_transaction"], y_A_Long_Position_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                                    y_A_Long_Position_I = Core.nothing;  # 釋放内存;
                                                                                                                end

                                                                                                                # 記錄做多模式本輪對衝交易的回撤值序列;
                                                                                                                if Base.typeof(drawdown_Array_Long_Position) <: Core.Array && Core.Int64(Base.length(drawdown_Array_Long_Position)) >= Core.Int64(0)
                                                                                                                    Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["drawdown"] = drawdown_Array_Long_Position;
                                                                                                                end
                                                                                                            end
                                                                                                        end

                                                                                                        # if Core.Float64(risk_drawdown_loss_Long_Position) > Core.Float64(risk_threshold_drawdown_loss) && Core.Int64(k) < Core.Int64(minimum_dates_transaction)
                                                                                                        if Core.Float64(risk_drawdown_loss_Long_Position) > Core.Float64(risk_threshold_drawdown_loss)

                                                                                                            # 計算該時間日期切面的交易信息;
                                                                                                            return_MarketTiming_fit_model = MarketTiming_fit_model(
                                                                                                                Base.Dict{Core.String, Core.Any}(
                                                                                                                    Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]) => Base.Dict{Core.String, Core.Any}(
                                                                                                                        "date_transaction" => x0,
                                                                                                                        "turnover_volume" => x1,
                                                                                                                        "opening_price" => x3,
                                                                                                                        "close_price" => x4,
                                                                                                                        "low_price" => x5,
                                                                                                                        "high_price" => x6,
                                                                                                                        "focus" => x7,
                                                                                                                        "amplitude" => x8,
                                                                                                                        "amplitude_rate" => x9,
                                                                                                                        "opening_price_Standardization" => x10,
                                                                                                                        "closing_price_Standardization" => x11,
                                                                                                                        "low_price_Standardization" => x12,
                                                                                                                        "high_price_Standardization" => x13,
                                                                                                                        "turnover_volume_growth_rate" => x14,
                                                                                                                        "opening_price_growth_rate" => x15,
                                                                                                                        "closing_price_growth_rate" => x16,
                                                                                                                        "closing_minus_opening_price_growth_rate" => x17,
                                                                                                                        "high_price_proportion" => x18,
                                                                                                                        "low_price_proportion" => x19
                                                                                                                        # "turnover_rate" => x20
                                                                                                                    )
                                                                                                                ),  # trainingData,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # ::Core.Array{Core.Float64, 2} = testingData,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
                                                                                                                MarketTiming_Parameter_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position"][1],  # Core.Int64(3),  # P1,  # 觀察收益率歷史向前推的交易日長度;
                                                                                                                MarketTiming_Parameter_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position"][2],  # Core.Float64(+1.0),  # P2,  # 買入閾值;
                                                                                                                MarketTiming_Parameter_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position"][3],  # Core.Float64(-1.0),  # P3,  # 賣出閾值;
                                                                                                                MarketTiming_Parameter_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position"][4],  # Core.Float64(0.0),  # P4,  # risk threshold drawdown loss; # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                                                Quantitative_Indicators_Function,
                                                                                                                "Short_Selling"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
                                                                                                            );
                                                                                                            # return_MarketTiming_fit_model === Base.Dict{Core.String, Core.Any}(
                                                                                                            #     "ticker_symbol" => Base.Dict{Core.String, Core.Any}(
                                                                                                            #         "y_profit" => y_profit,  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
                                                                                                            #         "y_Long_Position_profit" => y_Long_Position_profit,  # 優化目標變量;
                                                                                                            #         "y_Short_Selling_profit" => y_Short_Selling_profit,  # 優化目標變量;
                                                                                                            #         "y_loss" => y_loss,  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
                                                                                                            #         "y_Long_Position_loss" => y_Long_Position_loss,  # 優化目標變量;
                                                                                                            #         "y_Short_Selling_loss" => y_Short_Selling_loss,  # 優化目標變量;
                                                                                                            #         "profit_total" => y_total,  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                                                            #         "Long_Position_profit_total" => y_total_Long_Position,  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                                                            #         "Short_Selling_profit_total" => y_total_Short_Selling,  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                                                            #         "profit_Positive" => y_Positive,  # 每兩次對衝交易收益纍加總計;
                                                                                                            #         "Long_Position_profit_Positive" => y_Positive_Long_Position,  # 每兩次對衝交易收益纍加總計;
                                                                                                            #         "Short_Selling_profit_Positive" => y_Positive_Short_Selling,  # 每兩次對衝交易收益纍加總計;
                                                                                                            #         "profit_Positive_probability" => y_P_Positive,  # 每兩次對衝交易正利潤概率;
                                                                                                            #         "Long_Position_profit_Positive_probability" => y_P_Positive_Long_Position,  # 每兩次對衝交易正利潤概率;
                                                                                                            #         "Short_Selling_profit_Positive_probability" => y_P_Positive_Short_Selling,  # 每兩次對衝交易正利潤概率;
                                                                                                            #         "profit_Negative" => y_Negative,  # 每兩次對衝交易損失纍加總計;
                                                                                                            #         "Long_Position_profit_Negative" => y_Negative_Long_Position,  # 每兩次對衝交易損失纍加總計;
                                                                                                            #         "Short_Selling_profit_Negative" => y_Negative_Short_Selling,  # 每兩次對衝交易損失纍加總計;
                                                                                                            #         "profit_Negative_probability" => y_P_Negative,  # 每兩次對衝交易負利潤概率;
                                                                                                            #         "Long_Position_profit_Negative_probability" => y_P_Negative_Long_Position,  # 每兩次對衝交易負利潤概率;
                                                                                                            #         "Short_Selling_profit_Negative_probability" => y_P_Negative_Short_Selling,  # 每兩次對衝交易負利潤概率;
                                                                                                            #         "Long_Position_profit_date_transaction" => y_A_Long_Position,  # 每兩次對衝交易利潤，向量;
                                                                                                            #         "Short_Selling_profit_date_transaction" => y_A_Short_Selling,  # 每兩次對衝交易利潤，向量;
                                                                                                            #         "maximum_drawdown" => y_maximum_drawdown,  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                                                            #         "maximum_drawdown_Long_Position" => y_maximum_drawdown_Long_Position,  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                                                            #         "maximum_drawdown_Short_Selling" => y_maximum_drawdown_Short_Selling,  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                                                            #         "Long_Position_drawdown_date_transaction" => y_H_Long_Position,  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                                            #         "Short_Selling_drawdown_date_transaction" => y_H_Short_Selling,  # 向量，記錄做空模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                                            #         "average_price_amplitude_date_transaction" => y_amplitude,  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                                                            #         "Long_Position_average_price_amplitude_date_transaction" => y_amplitude_Long_Position,  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                                                            #         "Short_Selling_average_price_amplitude_date_transaction" => y_amplitude_Short_Selling,  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                                                            #         "Long_Position_price_amplitude_date_transaction" => y_D_Long_Position,  # 兩次對衝交易日成交價振幅平方和，向量;
                                                                                                            #         "Short_Selling_price_amplitude_date_transaction" => y_D_Short_Selling,  # 兩次對衝交易日成交價振幅平方和，向量;
                                                                                                            #         "average_volume_turnover_date_transaction" => y_turnover,  # 兩次對衝交易日成交量（換手率）均值;
                                                                                                            #         "Long_Position_average_volume_turnover_date_transaction" => y_turnover_Long_Position,  # 兩次對衝交易日成交量（換手率）均值;
                                                                                                            #         "Short_Selling_average_volume_turnover_date_transaction" => y_turnover_Short_Selling,  # 兩次對衝交易日成交量（換手率）均值;
                                                                                                            #         "Long_Position_volume_turnover_date_transaction" => y_E_Long_Position,  # 兩次對衝交易日成交量（換手率）向量;
                                                                                                            #         "Short_Selling_volume_turnover_date_transaction" => y_E_Short_Selling,  # 兩次對衝交易日成交量（換手率）向量;
                                                                                                            #         "average_date_transaction_between" => y_date_transaction_between,  # 兩次對衝交易間隔日長，均值;
                                                                                                            #         "Long_Position_average_date_transaction_between" => y_date_transaction_between_Long_Position,  # 兩次對衝交易間隔日長，均值;
                                                                                                            #         "Short_Selling_average_date_transaction_between" => y_date_transaction_between_Short_Selling,  # 兩次對衝交易間隔日長，均值;
                                                                                                            #         "Long_Position_date_transaction_between" => y_C_Long_Position,  # 兩次對衝交易間隔日長，向量;
                                                                                                            #         "Short_Selling_date_transaction_between" => y_C_Short_Selling,  # 兩次對衝交易間隔日長，向量;
                                                                                                            #         "Long_Position_date_transaction" => y_F_Long_Position,  # 按規則執行交易的日期，向量;
                                                                                                            #         "Short_Selling_date_transaction" => y_F_Short_Selling,  # 按規則執行交易的日期，向量;
                                                                                                            #         "P1_Array" => P1_Array,  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
                                                                                                            #         "revenue_and_expenditure_records_date_transaction" => y_G  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
                                                                                                            #     )
                                                                                                            # );
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["y_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["y_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_drawdown_date_transaction"]);  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_drawdown_date_transaction"]);  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["average_date_transaction_between"]);  # 兩次交易間隔日長，均值;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["weight_MarketTiming"]);  # 擇時權重，每兩次對衝交易的盈利概率占比;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
                                                                                                            if Base.isa(return_MarketTiming_fit_model, Base.Dict) && Base.haskey(return_MarketTiming_fit_model, Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]))
                                                                                                                if Base.isa(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], Base.Dict)
                                                                                                                    if Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position_date_transaction") && Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Short_Selling_date_transaction") && Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "revenue_and_expenditure_records_date_transaction")

                                                                                                                        # 判斷是否進行（融券做空 short selling）對衝交易的第一次賣出交易;
                                                                                                                        if Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"])) === Core.Int64(0) && Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"])) === Core.Int64(2) && Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"])) === Core.Int64(2) && Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_profit_date_transaction"])) === Core.Int64(1)
                                                                                                                            if return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][Core.Int64(1)][1] === return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"]))][1] && Base.string(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][Core.Int64(1)][2]) === Base.string("sell") && Base.string(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"]))][2]) === Base.string("buy") && Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(1)]) > Core.Float64(0.0) && Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"]))]) < Core.Float64(0.0) && Core.Float64(Base.abs(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_profit_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_profit_date_transaction"]))])) === Core.Float64(0.0)

                                                                                                                                # 做多（Long Position）記錄;
                                                                                                                                if Base.isa(Long_Position_testing_data_transaction_sequence_Dict, Base.Dict) && (!(Base.haskey(Long_Position_testing_data_transaction_sequence_Dict, Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])) && Base.isa(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], Base.Dict)))
                                                                                                                                    Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])] = Base.Dict{Core.String, Core.Any}();
                                                                                                                                end
                                                                                                                                if Base.isa(Long_Position_testing_data_transaction_sequence_Dict, Base.Dict) && Base.haskey(Long_Position_testing_data_transaction_sequence_Dict, Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])) && Base.isa(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], Base.Dict)
                                                                                                                                    # 每兩次對衝交易序號標識;
                                                                                                                                    Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Index_date_transaction_Long_Position"] = Core.Int64(k);  # 每兩次對衝交易序號標識;
                                                                                                                                    # 按規則執行第二次對衝賣出（融資做多 buying long）交易的日期;
                                                                                                                                    if !(Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]) <: Core.Array)
                                                                                                                                        Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                                                                    end
                                                                                                                                    if Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]) <: Core.Array
                                                                                                                                        if Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Short_Selling_date_transaction") && Base.typeof(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"]) <: Core.Array
                                                                                                                                            if Base.typeof(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"]))]) <: Core.Array
                                                                                                                                                y_F_Long_Position_I = Core.Array{Core.Any, 1}(Core.undef, 16);  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}(Core.undef, 16);
                                                                                                                                                y_F_Long_Position_I[1] = x0[Core.Int64(Base.length(x0))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"]))][1];  # 交易時間日期（Dates.Date 或 Dates.DateTime 類型）;
                                                                                                                                                y_F_Long_Position_I[2] = Base.string("sell");  # Base.string(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"]))][2]);  # 買入或賣出;
                                                                                                                                                y_F_Long_Position_I[3] = return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][Core.Int64(1)][3];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"]))][3];  # 成交價;
                                                                                                                                                if Core.Int64(Base.length(SizePosition_Parameter_Array)) >= Core.Int64(2) && Base.haskey(SizePosition_Parameter_Array[1], Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])) && Base.haskey(SizePosition_Parameter_Array[1][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position") && Base.haskey(SizePosition_Parameter_Array[2], Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])) && Base.haskey(SizePosition_Parameter_Array[2][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position")
                                                                                                                                                    y_F_Long_Position_I[4] = [SizePosition_Parameter_Array[1][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position"], SizePosition_Parameter_Array[2][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position"]];  # 倉位;
                                                                                                                                                else
                                                                                                                                                    y_F_Long_Position_I[4] = [Core.Float64(1.0), Core.Float64(1.0)];  # 倉位;
                                                                                                                                                end
                                                                                                                                                if Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Index_date_transaction_Long_Position")
                                                                                                                                                    y_F_Long_Position_I[5] = Core.Int64(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Index_date_transaction_Long_Position"]);  # 每兩次對衝成交序號標識;
                                                                                                                                                else
                                                                                                                                                    y_F_Long_Position_I[5] = Core.Int64(0);  # 每兩次對衝成交序號標識;
                                                                                                                                                end
                                                                                                                                                y_F_Long_Position_I[6] = Core.Int64(k);  # 交易日期的序列號，用於繪圖可視化;
                                                                                                                                                y_F_Long_Position_I[7] = x0[Core.Int64(Base.length(x0))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"]))][7];  # 交易日（Dates.Date 類型）;
                                                                                                                                                y_F_Long_Position_I[8] = x1[Core.Int64(Base.length(x1))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"]))][8];  # 當日總成交量（turnover volume）;
                                                                                                                                                y_F_Long_Position_I[9] = x3[Core.Int64(Base.length(x3))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"]))][9];  # 當日開盤（opening）成交價;
                                                                                                                                                y_F_Long_Position_I[10] = x4[Core.Int64(Base.length(x4))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"]))][10];  # 當日收盤（closing）成交價;
                                                                                                                                                y_F_Long_Position_I[11] = x5[Core.Int64(Base.length(x5))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"]))][11];  # 當日最低（low）成交價;
                                                                                                                                                y_F_Long_Position_I[12] = x6[Core.Int64(Base.length(x6))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"]))][12];  # 當日最高（high）成交價;
                                                                                                                                                # y_F_Long_Position_I[13] = x2[Core.Int64(Base.length(x2))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"]))][2];  # 當日總成交金額（turnover amount）;
                                                                                                                                                # y_F_Long_Position_I[14] = x20[Core.Int64(Base.length(x20))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"]))][20];  # 當日成交量（turnover volume）換手率（turnover rate）;
                                                                                                                                                # y_F_Long_Position_I[15] = x21[Core.Int64(Base.length(x21))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"]))][21];  # 當日每股收益（price earnings）;
                                                                                                                                                # y_F_Long_Position_I[16] = x22[Core.Int64(Base.length(x22))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"]))][22];  # 當日每股净值（book value per share）;
                                                                                                                                                Base.push!(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"], y_F_Long_Position_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                                                                y_F_Long_Position_I = Core.nothing;  # 釋放内存;
                                                                                                                                            end
                                                                                                                                        end
                                                                                                                                    end
                                                                                                                                    # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling）;
                                                                                                                                    if !(Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array)
                                                                                                                                        Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                                                                    end
                                                                                                                                    if Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array
                                                                                                                                        # y_G_Long_Position_I = Core.Float64(+Core.Float64(x3[Core.Int64(Base.length(x3))]));
                                                                                                                                        # Base.push!(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"], y_G_Long_Position_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                                                        if Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array
                                                                                                                                            y_G_Long_Position_I = Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(1)]);  # Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"]))]);
                                                                                                                                            Base.push!(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"], y_G_Long_Position_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                                                            y_G_Long_Position_I = Core.nothing;  # 釋放内存;
                                                                                                                                        end
                                                                                                                                    end
                                                                                                                                    # 每兩次對衝交易差價利潤初值;
                                                                                                                                    if !(Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position_profit_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_date_transaction"]) <: Core.Array)
                                                                                                                                        Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                                                                    end
                                                                                                                                    if Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position_profit_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_date_transaction"]) <: Core.Array
                                                                                                                                        if Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array
                                                                                                                                            y_A_Long_Position_I_2 = Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(1)]);
                                                                                                                                            # y_A_Long_Position_I_2 = Core.Float64(Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(1)]) + Core.Float64(y_A_Long_Position_I));
                                                                                                                                            y_A_Long_Position_I = Core.Float64(y_A_Long_Position_I_2);
                                                                                                                                            # y_A_Long_Position_I *= Core.Float64(0.0);
                                                                                                                                            # y_A_Long_Position_I += Core.Float64(y_A_Long_Position_I_2);
                                                                                                                                            # y_A_Long_Position_I += Core.Float64(x3[t + 1] - x3[k + 1]);
                                                                                                                                            # y_A_Long_Position_I = Core.Float64(x3[t + 1] - x3[k + 1]);
                                                                                                                                            Base.push!(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_date_transaction"], y_A_Long_Position_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                                                            y_A_Long_Position_I = Core.nothing;  # 釋放内存;
                                                                                                                                        end
                                                                                                                                    end

                                                                                                                                    # 記錄做多模式本輪對衝交易的回撤值序列;
                                                                                                                                    if Base.typeof(drawdown_Array_Long_Position) <: Core.Array && Core.Int64(Base.length(drawdown_Array_Long_Position)) >= Core.Int64(0)
                                                                                                                                        Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["drawdown"] = drawdown_Array_Long_Position;
                                                                                                                                    end
                                                                                                                                end
                                                                                                                            end
                                                                                                                        end
                                                                                                                    end
                                                                                                                end
                                                                                                            end
                                                                                                            return_MarketTiming_fit_model = Core.nothing;  # 釋放内存;
                                                                                                        end
                                                                                                    end
                                                                                                end
                                                                                            end
                                                                                        end
                                                                                    end
                                                                                end
                                                                            end
                                                                        end

                                                                        # 判斷、執行做多 buying long 兩次對衝交易滑框的左邊（首，第一次，買入交易 buy）;
                                                                        if Core.Int64(Long_Position_sliding_frame) >= Core.Int64(1)

                                                                            # 計算該時間日期切面的交易信息;
                                                                            return_MarketTiming_fit_model = MarketTiming_fit_model(
                                                                                Base.Dict{Core.String, Core.Any}(
                                                                                    Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]) => Base.Dict{Core.String, Core.Any}(
                                                                                        "date_transaction" => x0,
                                                                                        "turnover_volume" => x1,
                                                                                        "opening_price" => x3,
                                                                                        "close_price" => x4,
                                                                                        "low_price" => x5,
                                                                                        "high_price" => x6,
                                                                                        "focus" => x7,
                                                                                        "amplitude" => x8,
                                                                                        "amplitude_rate" => x9,
                                                                                        "opening_price_Standardization" => x10,
                                                                                        "closing_price_Standardization" => x11,
                                                                                        "low_price_Standardization" => x12,
                                                                                        "high_price_Standardization" => x13,
                                                                                        "turnover_volume_growth_rate" => x14,
                                                                                        "opening_price_growth_rate" => x15,
                                                                                        "closing_price_growth_rate" => x16,
                                                                                        "closing_minus_opening_price_growth_rate" => x17,
                                                                                        "high_price_proportion" => x18,
                                                                                        "low_price_proportion" => x19
                                                                                        # "turnover_rate" => x20
                                                                                    )
                                                                                ),  # trainingData,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # ::Core.Array{Core.Float64, 2} = testingData,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
                                                                                MarketTiming_Parameter_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position"][1],  # Core.Int64(3),  # P1,  # 觀察收益率歷史向前推的交易日長度;
                                                                                MarketTiming_Parameter_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position"][2],  # Core.Float64(+1.0),  # P2,  # 買入閾值;
                                                                                MarketTiming_Parameter_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position"][3],  # Core.Float64(-1.0),  # P3,  # 賣出閾值;
                                                                                MarketTiming_Parameter_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position"][4],  # Core.Float64(0.0),  # P4,  # risk threshold drawdown loss; # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                Quantitative_Indicators_Function,
                                                                                "Long_Position"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
                                                                            );
                                                                            # return_MarketTiming_fit_model === Base.Dict{Core.String, Core.Any}(
                                                                            #     "ticker_symbol" => Base.Dict{Core.String, Core.Any}(
                                                                            #         "y_profit" => y_profit,  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
                                                                            #         "y_Long_Position_profit" => y_Long_Position_profit,  # 優化目標變量;
                                                                            #         "y_Short_Selling_profit" => y_Short_Selling_profit,  # 優化目標變量;
                                                                            #         "y_loss" => y_loss,  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
                                                                            #         "y_Long_Position_loss" => y_Long_Position_loss,  # 優化目標變量;
                                                                            #         "y_Short_Selling_loss" => y_Short_Selling_loss,  # 優化目標變量;
                                                                            #         "profit_total" => y_total,  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                            #         "Long_Position_profit_total" => y_total_Long_Position,  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                            #         "Short_Selling_profit_total" => y_total_Short_Selling,  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                            #         "profit_Positive" => y_Positive,  # 每兩次對衝交易收益纍加總計;
                                                                            #         "Long_Position_profit_Positive" => y_Positive_Long_Position,  # 每兩次對衝交易收益纍加總計;
                                                                            #         "Short_Selling_profit_Positive" => y_Positive_Short_Selling,  # 每兩次對衝交易收益纍加總計;
                                                                            #         "profit_Positive_probability" => y_P_Positive,  # 每兩次對衝交易正利潤概率;
                                                                            #         "Long_Position_profit_Positive_probability" => y_P_Positive_Long_Position,  # 每兩次對衝交易正利潤概率;
                                                                            #         "Short_Selling_profit_Positive_probability" => y_P_Positive_Short_Selling,  # 每兩次對衝交易正利潤概率;
                                                                            #         "profit_Negative" => y_Negative,  # 每兩次對衝交易損失纍加總計;
                                                                            #         "Long_Position_profit_Negative" => y_Negative_Long_Position,  # 每兩次對衝交易損失纍加總計;
                                                                            #         "Short_Selling_profit_Negative" => y_Negative_Short_Selling,  # 每兩次對衝交易損失纍加總計;
                                                                            #         "profit_Negative_probability" => y_P_Negative,  # 每兩次對衝交易負利潤概率;
                                                                            #         "Long_Position_profit_Negative_probability" => y_P_Negative_Long_Position,  # 每兩次對衝交易負利潤概率;
                                                                            #         "Short_Selling_profit_Negative_probability" => y_P_Negative_Short_Selling,  # 每兩次對衝交易負利潤概率;
                                                                            #         "Long_Position_profit_date_transaction" => y_A_Long_Position,  # 每兩次對衝交易利潤，向量;
                                                                            #         "Short_Selling_profit_date_transaction" => y_A_Short_Selling,  # 每兩次對衝交易利潤，向量;
                                                                            #         "maximum_drawdown" => y_maximum_drawdown,  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                            #         "maximum_drawdown_Long_Position" => y_maximum_drawdown_Long_Position,  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                            #         "maximum_drawdown_Short_Selling" => y_maximum_drawdown_Short_Selling,  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                            #         "Long_Position_drawdown_date_transaction" => y_H_Long_Position,  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                            #         "Short_Selling_drawdown_date_transaction" => y_H_Short_Selling,  # 向量，記錄做空模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                            #         "average_price_amplitude_date_transaction" => y_amplitude,  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                            #         "Long_Position_average_price_amplitude_date_transaction" => y_amplitude_Long_Position,  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                            #         "Short_Selling_average_price_amplitude_date_transaction" => y_amplitude_Short_Selling,  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                            #         "Long_Position_price_amplitude_date_transaction" => y_D_Long_Position,  # 兩次對衝交易日成交價振幅平方和，向量;
                                                                            #         "Short_Selling_price_amplitude_date_transaction" => y_D_Short_Selling,  # 兩次對衝交易日成交價振幅平方和，向量;
                                                                            #         "average_volume_turnover_date_transaction" => y_turnover,  # 兩次對衝交易日成交量（換手率）均值;
                                                                            #         "Long_Position_average_volume_turnover_date_transaction" => y_turnover_Long_Position,  # 兩次對衝交易日成交量（換手率）均值;
                                                                            #         "Short_Selling_average_volume_turnover_date_transaction" => y_turnover_Short_Selling,  # 兩次對衝交易日成交量（換手率）均值;
                                                                            #         "Long_Position_volume_turnover_date_transaction" => y_E_Long_Position,  # 兩次對衝交易日成交量（換手率）向量;
                                                                            #         "Short_Selling_volume_turnover_date_transaction" => y_E_Short_Selling,  # 兩次對衝交易日成交量（換手率）向量;
                                                                            #         "average_date_transaction_between" => y_date_transaction_between,  # 兩次對衝交易間隔日長，均值;
                                                                            #         "Long_Position_average_date_transaction_between" => y_date_transaction_between_Long_Position,  # 兩次對衝交易間隔日長，均值;
                                                                            #         "Short_Selling_average_date_transaction_between" => y_date_transaction_between_Short_Selling,  # 兩次對衝交易間隔日長，均值;
                                                                            #         "Long_Position_date_transaction_between" => y_C_Long_Position,  # 兩次對衝交易間隔日長，向量;
                                                                            #         "Short_Selling_date_transaction_between" => y_C_Short_Selling,  # 兩次對衝交易間隔日長，向量;
                                                                            #         "Long_Position_date_transaction" => y_F_Long_Position,  # 按規則執行交易的日期，向量;
                                                                            #         "Short_Selling_date_transaction" => y_F_Short_Selling,  # 按規則執行交易的日期，向量;
                                                                            #         "P1_Array" => P1_Array,  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
                                                                            #         "revenue_and_expenditure_records_date_transaction" => y_G  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
                                                                            #     )
                                                                            # );
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["y_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["y_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_drawdown_date_transaction"]);  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_drawdown_date_transaction"]);  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["average_date_transaction_between"]);  # 兩次交易間隔日長，均值;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["weight_MarketTiming"]);  # 擇時權重，每兩次對衝交易的盈利概率占比;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
                                                                            if Base.isa(return_MarketTiming_fit_model, Base.Dict) && Base.haskey(return_MarketTiming_fit_model, Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g]))
                                                                                if Base.isa(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], Base.Dict)
                                                                                    if Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position_date_transaction") && Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Short_Selling_date_transaction") && Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "revenue_and_expenditure_records_date_transaction")

                                                                                        # 判斷是否進行（融資做多 buying long）第一次對衝交易的買入交易;
                                                                                        if Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"])) === Core.Int64(2) && Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Short_Selling_date_transaction"])) === Core.Int64(0) && Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"])) === Core.Int64(2) && Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_date_transaction"])) === Core.Int64(1)
                                                                                            if return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(1)][1] === return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))][1] && Base.string(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(1)][2]) === Base.string("buy") && Base.string(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))][2]) === Base.string("sell") && Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(1)]) < Core.Float64(0.0) && Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"]))]) > Core.Float64(0.0) && Core.Float64(Base.abs(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_date_transaction"]))])) === Core.Float64(0.0)

                                                                                                # 清空重置做多模式每個交易日的回撤值的記錄序列：drawdown_Array_Long_Position ;
                                                                                                Base.resize!(drawdown_Array_Long_Position, 0);

                                                                                                # 做多（Long Position）記錄;
                                                                                                if Base.isa(Long_Position_testing_data_transaction_sequence_Dict, Base.Dict) && (!(Base.haskey(Long_Position_testing_data_transaction_sequence_Dict, Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])) && Base.isa(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], Base.Dict)))
                                                                                                    Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])] = Base.Dict{Core.String, Core.Any}();
                                                                                                end
                                                                                                if Base.isa(Long_Position_testing_data_transaction_sequence_Dict, Base.Dict) && Base.haskey(Long_Position_testing_data_transaction_sequence_Dict, Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])) && Base.isa(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], Base.Dict)
                                                                                                    # 每兩次對衝交易序號標識;
                                                                                                    Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Index_date_transaction_Long_Position"] = Core.Int64(k);  # 每兩次對衝交易序號標識;
                                                                                                    # 按規則執行第一次對衝買入（融資做多 buying long）交易的日期;
                                                                                                    if !(Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]) <: Core.Array)
                                                                                                        Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                                    end
                                                                                                    if Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]) <: Core.Array
                                                                                                        if Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position_date_transaction") && Base.typeof(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]) <: Core.Array
                                                                                                            if Base.typeof(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))]) <: Core.Array
                                                                                                                y_F_Long_Position_I = Core.Array{Core.Any, 1}(Core.undef, 16);  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}(Core.undef, 16);
                                                                                                                y_F_Long_Position_I[1] = x0[Core.Int64(Base.length(x0))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))][1];  # 交易時間日期（Dates.Date 或 Dates.DateTime 類型）;
                                                                                                                y_F_Long_Position_I[2] = Base.string("buy");  # Base.string(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))][2]);  # 買入或賣出;
                                                                                                                y_F_Long_Position_I[3] = return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(1)][3];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))][3];  # 成交價;
                                                                                                                if Core.Int64(Base.length(SizePosition_Parameter_Array)) >= Core.Int64(2) && Base.haskey(SizePosition_Parameter_Array[1], Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])) && Base.haskey(SizePosition_Parameter_Array[1][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position") && Base.haskey(SizePosition_Parameter_Array[2], Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])) && Base.haskey(SizePosition_Parameter_Array[2][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position")
                                                                                                                    y_F_Long_Position_I[4] = [SizePosition_Parameter_Array[1][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position"], SizePosition_Parameter_Array[2][Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position"]];  # 倉位;
                                                                                                                else
                                                                                                                    y_F_Long_Position_I[4] = [Core.Float64(1.0), Core.Float64(1.0)];  # 倉位;
                                                                                                                end
                                                                                                                if Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Index_date_transaction_Long_Position")
                                                                                                                    y_F_Long_Position_I[5] = Core.Int64(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Index_date_transaction_Long_Position"]);  # 每兩次對衝成交序號標識;
                                                                                                                else
                                                                                                                    y_F_Long_Position_I[5] = Core.Int64(0);  # 每兩次對衝成交序號標識;
                                                                                                                end
                                                                                                                y_F_Long_Position_I[6] = Core.Int64(k);  # 交易日期的序列號，用於繪圖可視化;
                                                                                                                y_F_Long_Position_I[7] = x0[Core.Int64(Base.length(x0))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))][7];  # 交易日（Dates.Date 類型）;
                                                                                                                y_F_Long_Position_I[8] = x1[Core.Int64(Base.length(x1))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))][8];  # 當日總成交量（turnover volume）;
                                                                                                                y_F_Long_Position_I[9] = x3[Core.Int64(Base.length(x3))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))][9];  # 當日開盤（opening）成交價;
                                                                                                                y_F_Long_Position_I[10] = x4[Core.Int64(Base.length(x4))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))][10];  # 當日收盤（closing）成交價;
                                                                                                                y_F_Long_Position_I[11] = x5[Core.Int64(Base.length(x5))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))][11];  # 當日最低（low）成交價;
                                                                                                                y_F_Long_Position_I[12] = x6[Core.Int64(Base.length(x6))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))][12];  # 當日最高（high）成交價;
                                                                                                                # y_F_Long_Position_I[13] = x2[Core.Int64(Base.length(x2))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))][2];  # 當日總成交金額（turnover amount）;
                                                                                                                # y_F_Long_Position_I[14] = x20[Core.Int64(Base.length(x20))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))][20];  # 當日成交量（turnover volume）換手率（turnover rate）;
                                                                                                                # y_F_Long_Position_I[15] = x21[Core.Int64(Base.length(x21))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))][21];  # 當日每股收益（price earnings）;
                                                                                                                # y_F_Long_Position_I[16] = x22[Core.Int64(Base.length(x22))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"]))][22];  # 當日每股净值（book value per share）;
                                                                                                                Base.push!(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_date_transaction"], y_F_Long_Position_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                                y_F_Long_Position_I = Core.nothing;  # 釋放内存;
                                                                                                            end
                                                                                                        end
                                                                                                    end
                                                                                                    # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling）;
                                                                                                    if !(Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array)
                                                                                                        Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                                    end
                                                                                                    if Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array
                                                                                                        # y_G_Long_Position_I = Core.Float64(-Core.Float64(x3[Core.Int64(Base.length(x3))]));
                                                                                                        # Base.push!(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"], y_G_Long_Position_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                        if Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array
                                                                                                            y_G_Long_Position_I = Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(1)]);  # Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"]))]);
                                                                                                            Base.push!(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"], y_G_Long_Position_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                            y_G_Long_Position_I = Core.nothing;  # 釋放内存;
                                                                                                        end
                                                                                                    end
                                                                                                    # 每兩次對衝交易差價利潤初值;
                                                                                                    if !(Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position_profit_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_date_transaction"]) <: Core.Array)
                                                                                                        Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                                    end
                                                                                                    if Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "Long_Position_profit_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_date_transaction"]) <: Core.Array
                                                                                                        if Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array
                                                                                                            y_A_Long_Position_I = Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(1)]);
                                                                                                            # y_A_Long_Position_I *= Core.Float64(0.0);
                                                                                                            # y_A_Long_Position_I += Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_date_transaction"]))]);
                                                                                                            # y_A_Long_Position_I += Core.Float64(Core.Float64(0.0) - Core.Float64(x3[Core.Int64(Base.length(x3))]));
                                                                                                            # y_A_Long_Position_I = Core.Float64(Core.Float64(0.0) - Core.Float64(x3[Core.Int64(Base.length(x3))]));
                                                                                                            Base.push!(Long_Position_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Long_Position[t][g])]["Long_Position_profit_date_transaction"], y_A_Long_Position_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                            y_A_Long_Position_I = Core.nothing;  # 釋放内存;
                                                                                                        end
                                                                                                    end
                                                                                                end
                                                                                            end
                                                                                        end
                                                                                    end
                                                                                end
                                                                            end

                                                                            return_MarketTiming_fit_model = Core.nothing;  # 釋放内存;
                                                                        end

                                                                        Long_Position_sliding_frame = Core.nothing;  # 釋放内存;
                                                                        risk_drawdown_loss_Long_Position = Core.nothing;  # 釋放内存;

                                                                        # 釋放内存;
                                                                        x0 = Core.nothing;
                                                                        x1 = Core.nothing;
                                                                        x3 = Core.nothing;
                                                                        x4 = Core.nothing;
                                                                        x5 = Core.nothing;
                                                                        x6 = Core.nothing;
                                                                        x7 = Core.nothing;
                                                                        x8 = Core.nothing;
                                                                        x9 = Core.nothing;
                                                                        x10 = Core.nothing;
                                                                        x11 = Core.nothing;
                                                                        x12 = Core.nothing;
                                                                        x13 = Core.nothing;
                                                                        x14 = Core.nothing;
                                                                        x15 = Core.nothing;
                                                                        x16 = Core.nothing;
                                                                        x17 = Core.nothing;
                                                                        x18 = Core.nothing;
                                                                        x19 = Core.nothing;
                                                                        # x20 = Core.nothing;
                                                                        # x21 = Core.nothing;
                                                                        # x22 = Core.nothing;
                                                                        # x23 = Core.nothing;
                                                                        # x24 = Core.nothing;
                                                                        # x25 = Core.nothing;
                                                                        # x26 = Core.nothing;
                                                                        # x27 = Core.nothing;
                                                                        # x_Pdata_0 = Core.nothing;
                                                                        # x_Plower = Core.nothing;
                                                                        # x_Pupper = Core.nothing;
                                                                        # x_weight = Core.nothing;
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    t = Core.nothing;  # 釋放内存;

                                    # 依照選股規則挑選出的股票，計算（融券做空 short selling）交易利潤;
                                    t = Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling));  # Core.Int64(minimum_dates_transaction_testing_data);  # Core.Int64(maximum_dates_transaction_testing_data);  # Core.Int64(1);
                                    if investment_method === "Long_Position_and_Short_Selling" || investment_method === "Short_Selling"

                                        if Core.Int64(t) > Core.Int64(0) && Core.Int64(t) <= Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))
                                            if (!(Base.ismissing(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t]) || Base.isnothing(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t]))) && Base.typeof(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t]) <: Core.Array
                                                # 依照選股規則挑選出的股票，計算（融券做空 short selling）交易利潤;
                                                if Base.haskey(PickStock_Parameter_Dict, "Short_Selling")
                                                    g_max = Core.Int64(Base.findmax([Core.Int64(1), Core.Int64(Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t])) - Core.Int64(PickStock_Parameter_Dict["Short_Selling"][2]) + Core.Int64(1))])[1]);
                                                else
                                                    g_max = Core.Int64(1);
                                                end
                                                for g = Core.Int64(g_max):Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t]))
                                                    if Core.Int64(g) >= Core.Int64(1) && Core.Int64(g) <= Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t]))
                                                        if (!(Base.ismissing(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]) || Base.isnothing(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]))) && Base.typeof(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]) <: Core.String
                                                            if Base.isa(testingData, Base.Dict) && Base.haskey(testingData, PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]) && Base.isa(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]], Base.Dict) && Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]) > 0
                                                                # 判斷循環遍歷「t」小於序列數據（1 維數組）的最大長度，並跳過超出的部分;
                                                                if Core.Int64(t) <= Core.Int64(Base.findmin([Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["date_transaction"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["turnover_volume"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["opening_price"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["close_price"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["low_price"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["high_price"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["focus"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["amplitude"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["amplitude_rate"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["opening_price_Standardization"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["closing_price_Standardization"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["low_price_Standardization"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["high_price_Standardization"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["turnover_volume_growth_rate"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["opening_price_growth_rate"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["closing_price_growth_rate"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["closing_minus_opening_price_growth_rate"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["high_price_proportion"]), Base.length(testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["low_price_proportion"])])[1])
                                                                    if Base.haskey(MarketTiming_Parameter_Dict, Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])) && Base.haskey(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]], "Short_Selling") && Core.Int64(t) >= Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2))

                                                                        x0 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["date_transaction"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 交易日期;
                                                                        x1 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["turnover_volume"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 成交量;
                                                                        # x2 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["turnover_amount"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 成交總金額;
                                                                        x3 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["opening_price"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 開盤成交價;
                                                                        x4 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["close_price"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤成交價;
                                                                        x5 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["low_price"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 最低成交價;
                                                                        x6 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["high_price"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 最高成交價;
                                                                        x7 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["focus"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 當日成交價重心;
                                                                        x8 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["amplitude"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 當日成交價絕對振幅;
                                                                        x9 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["amplitude_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 當日成交價相對振幅（%）;
                                                                        x10 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["opening_price_Standardization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 日棒缐（K Line Daily）數據交易日首筆成交價（開盤價）標準化值;
                                                                        x11 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["closing_price_Standardization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 日棒缐（K Line Daily）數據交易日尾筆成交價（收盤價）標準化值;
                                                                        x12 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["low_price_Standardization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 日棒缐（K Line Daily）數據交易日最低成交價標準化值;
                                                                        x13 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["high_price_Standardization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 日棒缐（K Line Daily）數據交易日最高成交價標準化值;
                                                                        x14 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["turnover_volume_growth_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 成交量的成長率;
                                                                        x15 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["opening_price_growth_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 開盤價的成長率;
                                                                        x16 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["closing_price_growth_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價的成長率;
                                                                        x17 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["closing_minus_opening_price_growth_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價減開盤價的成長率;
                                                                        x18 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["high_price_proportion"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價和開盤價裏的最大值占最高價的比例;
                                                                        x19 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["low_price_proportion"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 最低價占收盤價和開盤價裏的最小值的比例;
                                                                        # x20 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["turnover_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 成交量換手率;
                                                                        # x21 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["price_earnings"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 每股收益（公司經營利潤率 ÷ 股本）;
                                                                        # x22 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["book_value_per_share"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 每股净值（公司净資產 ÷ 股本）;
                                                                        # x23 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["capitalization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 總市值;
                                                                        # x24 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["moving_average_5"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價 5 日滑動平均缐;
                                                                        # x25 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["moving_average_10"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價 10 日滑動平均缐;
                                                                        # x26 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["moving_average_20"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價 20 日滑動平均缐;
                                                                        # x27 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["moving_average_30"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價 30 日滑動平均缐;
                                                                        # x_Pdata_0 = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Pdata_0"];
                                                                        # x_Plower = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Plower"];
                                                                        # x_Pupper = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["Pupper"];
                                                                        # x_weight = testingData[PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]]["weight"];

                                                                        # 記錄每個交易日的回撤值序列;
                                                                        risk_threshold_drawdown_loss = Core.Float64(MarketTiming_Parameter_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling"][4]);  # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                        # risk_threshold_drawdown_loss = Core.Float64(0.0);
                                                                        risk_drawdown_loss_Short_Selling = Core.Float64(Core.Float64(risk_threshold_drawdown_loss) + Core.Float64(0.1));  # 回撤比例初值，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;

                                                                        # 標示融券做空 short selling 兩次對衝交易滑框的左邊（首，第一次，賣出交易 sell）或右邊（尾，第二次，買入交易 buy），取值爲 1 時表示滑框的左邊（首，第一次，賣出交易 sell），取值爲 0 時表示滑框的右邊（尾，第二次，買入交易 buy），預設值爲 1 ，即取滑框的左邊（首，第一次，賣出交易 sell）;
                                                                        Short_Selling_sliding_frame = Core.Int64(1);  # 標示融券做空 short selling 兩次對衝交易滑框的左邊（首，第一次，賣出交易 sell）或右邊（尾，第二次，買入交易 buy），取值爲 1 時表示滑框的左邊（首，第一次，賣出交易 sell），取值爲 0 時表示滑框的右邊（尾，第二次，買入交易 buy），預設值爲 1 ，即取滑框的左邊（首，第一次，賣出交易 sell）;

                                                                        # 判斷、執行融券做空 short selling 兩次對衝交易滑框的右邊（尾，第二次，買入交易 buy）;
                                                                        if Base.typeof(stepping_sequence_Array) <: Core.Array && Core.Int64(Base.length(stepping_sequence_Array)) > Core.Int64(0)
                                                                            if Base.isa(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))], Base.Dict) && Base.haskey(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))], "testing_transaction")
                                                                                # 依照選股規則挑選出的股票，計算（融券做空 short selling）交易利潤;
                                                                                if Base.isa(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"], Base.Dict) && Base.haskey(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"], "Short_Selling")
                                                                                    if Base.isa(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"], Base.Dict) && Base.haskey(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"], Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]))
                                                                                        if Base.isa(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], Base.Dict) && Base.haskey(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling_date_transaction")
                                                                                            if Base.typeof(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]) <: Core.Array && Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"])) >= Core.Int64(0)
                                                                                                if Base.typeof(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))]) <: Core.Array && Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))])) >= Core.Int64(3)
                                                                                                    if Base.string(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][2]) === "sell"

                                                                                                        # 標示融券做空 short selling 兩次對衝交易滑框的左邊（首，第一次，賣出交易 sell）或右邊（尾，第二次，買入交易 buy），取值爲 1 時表示滑框的左邊（首，第一次，賣出交易 sell），取值爲 0 時表示滑框的右邊（尾，第二次，買入交易 buy），預設值爲 1 ，即取滑框的左邊（首，第一次，賣出交易 sell）;
                                                                                                        # 融券做空 short selling 兩次對衝交易類型，從滑框的左邊（首，第一次，賣出交易 sell）修改爲滑框的右邊（尾，第二次，買入交易 buy）;
                                                                                                        if Core.Int64(Short_Selling_sliding_frame) >= Core.Int64(1)
                                                                                                            Short_Selling_sliding_frame *= Core.Int64(0);
                                                                                                            Short_Selling_sliding_frame += Core.Int64(0);
                                                                                                        end

                                                                                                        risk_drawdown_loss_Short_Selling *= Core.Float64(0.0);
                                                                                                        risk_drawdown_loss_Short_Selling += Core.Float64(Core.Float64(1.0) + Core.Float64(Core.Float64(Core.Float64(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][3]) - Core.Float64(x3[Core.Int64(Base.length(x3))])) / Core.Float64(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][3])));  # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                                        # risk_drawdown_loss_Short_Selling += Core.Float64(Core.Float64(1.0) + Core.Float64(Core.Float64(Core.Float64(Base.abs(Core.Float64(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][3]))) - Core.Float64(Base.abs(Core.Float64(x3[Core.Int64(Base.length(x3))])))) / Core.Float64(Base.abs(Core.Float64(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][3])))));  # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;

                                                                                                        # 記錄做空模式每個交易日的回撤值序列;
                                                                                                        Base.push!(drawdown_Array_Short_Selling, risk_drawdown_loss_Short_Selling);  # 使用 push! 函數在數組末尾追加推入新元;

                                                                                                        # if Core.Float64(risk_drawdown_loss_Short_Selling) <= Core.Float64(risk_threshold_drawdown_loss) || Core.Int64(k) === Core.Int64(minimum_dates_transaction)
                                                                                                        if Core.Float64(risk_drawdown_loss_Short_Selling) <= Core.Float64(risk_threshold_drawdown_loss)

                                                                                                            # 做空（Short Selling）記錄;
                                                                                                            if Base.isa(Short_Selling_testing_data_transaction_sequence_Dict, Base.Dict) && (!(Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict, Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])) && Base.isa(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], Base.Dict)))
                                                                                                                Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])] = Base.Dict{Core.String, Core.Any}();
                                                                                                            end
                                                                                                            if Base.isa(Short_Selling_testing_data_transaction_sequence_Dict, Base.Dict) && Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict, Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])) && Base.isa(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], Base.Dict)
                                                                                                                # 每兩次對衝交易序號標識;
                                                                                                                Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Index_date_transaction_Short_Selling"] = Core.Int64(k);  # 每兩次對衝交易序號標識;
                                                                                                                # 按規則執行第一次對衝賣出（融券做空 short selling）交易的日期;
                                                                                                                if !(Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]) <: Core.Array)
                                                                                                                    Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                                                end
                                                                                                                if Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]) <: Core.Array
                                                                                                                    y_F_Short_Selling_I = Core.Array{Core.Any, 1}(Core.undef, 16);  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}(Core.undef, 16);
                                                                                                                    y_F_Short_Selling_I[1] = x0[Core.Int64(Base.length(x0))];  # 交易時間日期（Dates.Date 或 Dates.DateTime 類型）;
                                                                                                                    y_F_Short_Selling_I[2] = Base.string("buy");  # 買入或賣出;
                                                                                                                    y_F_Short_Selling_I[3] = x3[Core.Int64(Base.length(x3))];  # 成交價;
                                                                                                                    if Core.Int64(Base.length(SizePosition_Parameter_Array)) >= Core.Int64(2) && Base.haskey(SizePosition_Parameter_Array[1], Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])) && Base.haskey(SizePosition_Parameter_Array[1][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling") && Base.haskey(SizePosition_Parameter_Array[2], Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])) && Base.haskey(SizePosition_Parameter_Array[2][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling")
                                                                                                                        y_F_Short_Selling_I[4] = [SizePosition_Parameter_Array[1][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling"], SizePosition_Parameter_Array[2][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling"]];  # 倉位;
                                                                                                                    else
                                                                                                                        y_F_Short_Selling_I[4] = [Core.Float64(1.0), Core.Float64(1.0)];  # 倉位;
                                                                                                                    end
                                                                                                                    if Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Index_date_transaction_Short_Selling")
                                                                                                                        y_F_Short_Selling_I[5] = Core.Int64(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Index_date_transaction_Short_Selling"]);  # 每兩次對衝成交序號標識;
                                                                                                                    else
                                                                                                                        y_F_Short_Selling_I[5] = Core.Int64(0);  # 每兩次對衝成交序號標識;
                                                                                                                    end
                                                                                                                    y_F_Short_Selling_I[6] = Core.Int64(k);  # 交易日期的序列號，用於繪圖可視化;
                                                                                                                    y_F_Short_Selling_I[7] = x0[Core.Int64(Base.length(x0))];  # 交易日（Dates.Date 類型）;
                                                                                                                    y_F_Short_Selling_I[8] = x1[Core.Int64(Base.length(x1))];  # 當日總成交量（turnover volume）;
                                                                                                                    y_F_Short_Selling_I[9] = x3[Core.Int64(Base.length(x3))];  # 當日開盤（opening）成交價;
                                                                                                                    y_F_Short_Selling_I[10] = x4[Core.Int64(Base.length(x4))];  # 當日收盤（closing）成交價;
                                                                                                                    y_F_Short_Selling_I[11] = x5[Core.Int64(Base.length(x5))];  # 當日最低（low）成交價;
                                                                                                                    y_F_Short_Selling_I[12] = x6[Core.Int64(Base.length(x6))];  # 當日最高（high）成交價;
                                                                                                                    # y_F_Short_Selling_I[13] = x2[Core.Int64(Base.length(x2))];  # 當日總成交金額（turnover amount）;
                                                                                                                    # y_F_Short_Selling_I[14] = x20[Core.Int64(Base.length(x20))];  # 當日成交量（turnover volume）換手率（turnover rate）;
                                                                                                                    # y_F_Short_Selling_I[15] = x21[Core.Int64(Base.length(x21))];  # 當日每股收益（price earnings）;
                                                                                                                    # y_F_Short_Selling_I[16] = x22[Core.Int64(Base.length(x22))];  # 當日每股净值（book value per share）;
                                                                                                                    Base.push!(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"], y_F_Short_Selling_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                                    y_F_Short_Selling_I = Core.nothing;  # 釋放内存;
                                                                                                                end
                                                                                                                # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling）;
                                                                                                                if !(Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array)
                                                                                                                    Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                                                end
                                                                                                                if Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array
                                                                                                                    y_G_Short_Selling_I = Core.Float64(Core.Int64(-1) * Core.Float64(x3[Core.Int64(Base.length(x3))]));
                                                                                                                    Base.push!(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"], y_G_Short_Selling_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                                    y_G_Short_Selling_I = Core.nothing;  # 釋放内存;
                                                                                                                end
                                                                                                                # 每兩次對衝交易差價利潤初值;
                                                                                                                if !(Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling_profit_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_date_transaction"]) <: Core.Array)
                                                                                                                    Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                                                end
                                                                                                                if Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling_profit_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_date_transaction"]) <: Core.Array
                                                                                                                    y_A_Short_Selling_I_2 = Core.Float64(x3[Core.Int64(Base.length(x3))]);
                                                                                                                    # y_A_Short_Selling_I_2 = Core.Float64(Core.Int64(-1) * Core.Float64(Core.Float64(x3[Core.Int64(Base.length(x3))]) + Core.Float64(y_A_Short_Selling_I)));
                                                                                                                    y_A_Short_Selling_I = Core.Float64(y_A_Short_Selling_I_2);
                                                                                                                    # y_A_Short_Selling_I *= Core.Float64(0.0);
                                                                                                                    # y_A_Short_Selling_I += Core.Float64(y_A_Short_Selling_I_2);
                                                                                                                    # y_A_Short_Selling_I += Core.Float64(-(x3[t + 1] - x3[k + 1]));
                                                                                                                    # y_A_Short_Selling_I = Core.Float64(-(x3[t + 1] - x3[k + 1]));
                                                                                                                    Base.push!(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_date_transaction"], y_A_Short_Selling_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                                    y_A_Short_Selling_I = Core.nothing;  # 釋放内存;
                                                                                                                end

                                                                                                                # 記錄做空模式本輪對衝交易的回撤值序列;
                                                                                                                if Base.typeof(drawdown_Array_Short_Selling) <: Core.Array && Core.Int64(Base.length(drawdown_Array_Short_Selling)) >= Core.Int64(0)
                                                                                                                    Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["drawdown"] = drawdown_Array_Short_Selling;
                                                                                                                end
                                                                                                            end
                                                                                                        end

                                                                                                        # if Core.Float64(risk_drawdown_loss_Short_Selling) > Core.Float64(risk_threshold_drawdown_loss) && Core.Int64(k) < Core.Int64(minimum_dates_transaction)
                                                                                                        if Core.Float64(risk_drawdown_loss_Short_Selling) > Core.Float64(risk_threshold_drawdown_loss)

                                                                                                            # 計算該時間日期切面的交易信息;
                                                                                                            return_MarketTiming_fit_model = MarketTiming_fit_model(
                                                                                                                Base.Dict{Core.String, Core.Any}(
                                                                                                                    Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]) => Base.Dict{Core.String, Core.Any}(
                                                                                                                        "date_transaction" => x0,
                                                                                                                        "turnover_volume" => x1,
                                                                                                                        "opening_price" => x3,
                                                                                                                        "close_price" => x4,
                                                                                                                        "low_price" => x5,
                                                                                                                        "high_price" => x6,
                                                                                                                        "focus" => x7,
                                                                                                                        "amplitude" => x8,
                                                                                                                        "amplitude_rate" => x9,
                                                                                                                        "opening_price_Standardization" => x10,
                                                                                                                        "closing_price_Standardization" => x11,
                                                                                                                        "low_price_Standardization" => x12,
                                                                                                                        "high_price_Standardization" => x13,
                                                                                                                        "turnover_volume_growth_rate" => x14,
                                                                                                                        "opening_price_growth_rate" => x15,
                                                                                                                        "closing_price_growth_rate" => x16,
                                                                                                                        "closing_minus_opening_price_growth_rate" => x17,
                                                                                                                        "high_price_proportion" => x18,
                                                                                                                        "low_price_proportion" => x19
                                                                                                                        # "turnover_rate" => x20
                                                                                                                    )
                                                                                                                ),  # trainingData,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # ::Core.Array{Core.Float64, 2} = testingData,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
                                                                                                                MarketTiming_Parameter_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling"][1],  # Core.Int64(3),  # P1,  # 觀察收益率歷史向前推的交易日長度;
                                                                                                                MarketTiming_Parameter_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling"][2],  # Core.Float64(+1.0),  # P2,  # 買入閾值;
                                                                                                                MarketTiming_Parameter_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling"][3],  # Core.Float64(-1.0),  # P3,  # 賣出閾值;
                                                                                                                MarketTiming_Parameter_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling"][4],  # Core.Float64(0.0),  # P4,  # risk threshold drawdown loss; # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                                                Quantitative_Indicators_Function,
                                                                                                                "Long_Position"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
                                                                                                            );
                                                                                                            # return_MarketTiming_fit_model === Base.Dict{Core.String, Core.Any}(
                                                                                                            #     "ticker_symbol" => Base.Dict{Core.String, Core.Any}(
                                                                                                            #         "y_profit" => y_profit,  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
                                                                                                            #         "y_Long_Position_profit" => y_Long_Position_profit,  # 優化目標變量;
                                                                                                            #         "y_Short_Selling_profit" => y_Short_Selling_profit,  # 優化目標變量;
                                                                                                            #         "y_loss" => y_loss,  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
                                                                                                            #         "y_Long_Position_loss" => y_Long_Position_loss,  # 優化目標變量;
                                                                                                            #         "y_Short_Selling_loss" => y_Short_Selling_loss,  # 優化目標變量;
                                                                                                            #         "profit_total" => y_total,  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                                                            #         "Long_Position_profit_total" => y_total_Long_Position,  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                                                            #         "Short_Selling_profit_total" => y_total_Short_Selling,  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                                                            #         "profit_Positive" => y_Positive,  # 每兩次對衝交易收益纍加總計;
                                                                                                            #         "Long_Position_profit_Positive" => y_Positive_Long_Position,  # 每兩次對衝交易收益纍加總計;
                                                                                                            #         "Short_Selling_profit_Positive" => y_Positive_Short_Selling,  # 每兩次對衝交易收益纍加總計;
                                                                                                            #         "profit_Positive_probability" => y_P_Positive,  # 每兩次對衝交易正利潤概率;
                                                                                                            #         "Long_Position_profit_Positive_probability" => y_P_Positive_Long_Position,  # 每兩次對衝交易正利潤概率;
                                                                                                            #         "Short_Selling_profit_Positive_probability" => y_P_Positive_Short_Selling,  # 每兩次對衝交易正利潤概率;
                                                                                                            #         "profit_Negative" => y_Negative,  # 每兩次對衝交易損失纍加總計;
                                                                                                            #         "Long_Position_profit_Negative" => y_Negative_Long_Position,  # 每兩次對衝交易損失纍加總計;
                                                                                                            #         "Short_Selling_profit_Negative" => y_Negative_Short_Selling,  # 每兩次對衝交易損失纍加總計;
                                                                                                            #         "profit_Negative_probability" => y_P_Negative,  # 每兩次對衝交易負利潤概率;
                                                                                                            #         "Long_Position_profit_Negative_probability" => y_P_Negative_Long_Position,  # 每兩次對衝交易負利潤概率;
                                                                                                            #         "Short_Selling_profit_Negative_probability" => y_P_Negative_Short_Selling,  # 每兩次對衝交易負利潤概率;
                                                                                                            #         "Long_Position_profit_date_transaction" => y_A_Long_Position,  # 每兩次對衝交易利潤，向量;
                                                                                                            #         "Short_Selling_profit_date_transaction" => y_A_Short_Selling,  # 每兩次對衝交易利潤，向量;
                                                                                                            #         "maximum_drawdown" => y_maximum_drawdown,  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                                                            #         "maximum_drawdown_Long_Position" => y_maximum_drawdown_Long_Position,  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                                                            #         "maximum_drawdown_Short_Selling" => y_maximum_drawdown_Short_Selling,  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                                                            #         "Long_Position_drawdown_date_transaction" => y_H_Long_Position,  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                                            #         "Short_Selling_drawdown_date_transaction" => y_H_Short_Selling,  # 向量，記錄做空模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                                            #         "average_price_amplitude_date_transaction" => y_amplitude,  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                                                            #         "Long_Position_average_price_amplitude_date_transaction" => y_amplitude_Long_Position,  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                                                            #         "Short_Selling_average_price_amplitude_date_transaction" => y_amplitude_Short_Selling,  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                                                            #         "Long_Position_price_amplitude_date_transaction" => y_D_Long_Position,  # 兩次對衝交易日成交價振幅平方和，向量;
                                                                                                            #         "Short_Selling_price_amplitude_date_transaction" => y_D_Short_Selling,  # 兩次對衝交易日成交價振幅平方和，向量;
                                                                                                            #         "average_volume_turnover_date_transaction" => y_turnover,  # 兩次對衝交易日成交量（換手率）均值;
                                                                                                            #         "Long_Position_average_volume_turnover_date_transaction" => y_turnover_Long_Position,  # 兩次對衝交易日成交量（換手率）均值;
                                                                                                            #         "Short_Selling_average_volume_turnover_date_transaction" => y_turnover_Short_Selling,  # 兩次對衝交易日成交量（換手率）均值;
                                                                                                            #         "Long_Position_volume_turnover_date_transaction" => y_E_Long_Position,  # 兩次對衝交易日成交量（換手率）向量;
                                                                                                            #         "Short_Selling_volume_turnover_date_transaction" => y_E_Short_Selling,  # 兩次對衝交易日成交量（換手率）向量;
                                                                                                            #         "average_date_transaction_between" => y_date_transaction_between,  # 兩次對衝交易間隔日長，均值;
                                                                                                            #         "Long_Position_average_date_transaction_between" => y_date_transaction_between_Long_Position,  # 兩次對衝交易間隔日長，均值;
                                                                                                            #         "Short_Selling_average_date_transaction_between" => y_date_transaction_between_Short_Selling,  # 兩次對衝交易間隔日長，均值;
                                                                                                            #         "Long_Position_date_transaction_between" => y_C_Long_Position,  # 兩次對衝交易間隔日長，向量;
                                                                                                            #         "Short_Selling_date_transaction_between" => y_C_Short_Selling,  # 兩次對衝交易間隔日長，向量;
                                                                                                            #         "Long_Position_date_transaction" => y_F_Long_Position,  # 按規則執行交易的日期，向量;
                                                                                                            #         "Short_Selling_date_transaction" => y_F_Short_Selling,  # 按規則執行交易的日期，向量;
                                                                                                            #         "P1_Array" => P1_Array,  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
                                                                                                            #         "revenue_and_expenditure_records_date_transaction" => y_G  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
                                                                                                            #     )
                                                                                                            # );
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["y_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["y_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_drawdown_date_transaction"]);  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_drawdown_date_transaction"]);  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["average_date_transaction_between"]);  # 兩次交易間隔日長，均值;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["weight_MarketTiming"]);  # 擇時權重，每兩次對衝交易的盈利概率占比;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
                                                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
                                                                                                            if Base.isa(return_MarketTiming_fit_model, Base.Dict) && Base.haskey(return_MarketTiming_fit_model, Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]))
                                                                                                                if Base.isa(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], Base.Dict)
                                                                                                                    if Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Long_Position_date_transaction") && Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling_date_transaction") && Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "revenue_and_expenditure_records_date_transaction")

                                                                                                                        # 判斷是否進行（融券做空 short selling）對衝交易的第一次賣出交易;
                                                                                                                        if Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"])) === Core.Int64(2) && Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"])) === Core.Int64(0) && Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"])) === Core.Int64(2) && Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_profit_date_transaction"])) === Core.Int64(1)
                                                                                                                            if return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][Core.Int64(1)][1] === return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"]))][1] && Base.string(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][Core.Int64(1)][2]) === Base.string("buy") && Base.string(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"]))][2]) === Base.string("sell") && Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(1)]) < Core.Float64(0.0) && Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"]))]) > Core.Float64(0.0) && Core.Float64(Base.abs(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_profit_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_profit_date_transaction"]))])) === Core.Float64(0.0)

                                                                                                                                # 做空（Short Selling）記錄;
                                                                                                                                if Base.isa(Short_Selling_testing_data_transaction_sequence_Dict, Base.Dict) && (!(Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict, Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])) && Base.isa(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], Base.Dict)))
                                                                                                                                    Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])] = Base.Dict{Core.String, Core.Any}();
                                                                                                                                end
                                                                                                                                if Base.isa(Short_Selling_testing_data_transaction_sequence_Dict, Base.Dict) && Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict, Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])) && Base.isa(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], Base.Dict)
                                                                                                                                    # 每兩次對衝交易序號標識;
                                                                                                                                    Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Index_date_transaction_Short_Selling"] = Core.Int64(k);  # 每兩次對衝交易序號標識;
                                                                                                                                    # 按規則執行第一次對衝賣出（融券做空 short selling）交易的日期;
                                                                                                                                    if !(Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]) <: Core.Array)
                                                                                                                                        Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                                                                    end
                                                                                                                                    if Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]) <: Core.Array
                                                                                                                                        if Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Long_Position_date_transaction") && Base.typeof(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"]) <: Core.Array
                                                                                                                                            if Base.typeof(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"]))]) <: Core.Array
                                                                                                                                                y_F_Short_Selling_I = Core.Array{Core.Any, 1}(Core.undef, 16);  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}(Core.undef, 16);
                                                                                                                                                y_F_Short_Selling_I[1] = x0[Core.Int64(Base.length(x0))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"]))][1];  # 交易時間日期（Dates.Date 或 Dates.DateTime 類型）;
                                                                                                                                                y_F_Short_Selling_I[2] = Base.string("buy");  # Base.string(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"]))][2]);  # 買入或賣出;
                                                                                                                                                y_F_Short_Selling_I[3] = return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][Core.Int64(1)][3];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"]))][3];  # 成交價;
                                                                                                                                                if Core.Int64(Base.length(SizePosition_Parameter_Array)) >= Core.Int64(2) && Base.haskey(SizePosition_Parameter_Array[1], Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])) && Base.haskey(SizePosition_Parameter_Array[1][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling") && Base.haskey(SizePosition_Parameter_Array[2], Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])) && Base.haskey(SizePosition_Parameter_Array[2][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling")
                                                                                                                                                    y_F_Short_Selling_I[4] = [SizePosition_Parameter_Array[1][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling"], SizePosition_Parameter_Array[2][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling"]];  # 倉位;
                                                                                                                                                else
                                                                                                                                                    y_F_Short_Selling_I[4] = [Core.Float64(1.0), Core.Float64(1.0)];  # 倉位;
                                                                                                                                                end
                                                                                                                                                if Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Index_date_transaction_Short_Selling")
                                                                                                                                                    y_F_Short_Selling_I[5] = Core.Int64(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Index_date_transaction_Short_Selling"]);  # 每兩次對衝成交序號標識;
                                                                                                                                                else
                                                                                                                                                    y_F_Short_Selling_I[5] = Core.Int64(0);  # 每兩次對衝成交序號標識;
                                                                                                                                                end
                                                                                                                                                y_F_Short_Selling_I[6] = Core.Int64(k);  # 交易日期的序列號，用於繪圖可視化;
                                                                                                                                                y_F_Short_Selling_I[7] = x0[Core.Int64(Base.length(x0))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"]))][7];  # 交易日（Dates.Date 類型）;
                                                                                                                                                y_F_Short_Selling_I[8] = x1[Core.Int64(Base.length(x1))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"]))][8];  # 當日總成交量（turnover volume）;
                                                                                                                                                y_F_Short_Selling_I[9] = x3[Core.Int64(Base.length(x3))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"]))][9];  # 當日開盤（opening）成交價;
                                                                                                                                                y_F_Short_Selling_I[10] = x4[Core.Int64(Base.length(x4))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"]))][10];  # 當日收盤（closing）成交價;
                                                                                                                                                y_F_Short_Selling_I[11] = x5[Core.Int64(Base.length(x5))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"]))][11];  # 當日最低（low）成交價;
                                                                                                                                                y_F_Short_Selling_I[12] = x6[Core.Int64(Base.length(x6))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"]))][12];  # 當日最高（high）成交價;
                                                                                                                                                # y_F_Short_Selling_I[13] = x2[Core.Int64(Base.length(x2))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"]))][2];  # 當日總成交金額（turnover amount）;
                                                                                                                                                # y_F_Short_Selling_I[14] = x20[Core.Int64(Base.length(x20))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"]))][20];  # 當日成交量（turnover volume）換手率（turnover rate）;
                                                                                                                                                # y_F_Short_Selling_I[15] = x21[Core.Int64(Base.length(x21))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"]))][21];  # 當日每股收益（price earnings）;
                                                                                                                                                # y_F_Short_Selling_I[16] = x22[Core.Int64(Base.length(x22))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"]))][22];  # 當日每股净值（book value per share）;
                                                                                                                                                Base.push!(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"], y_F_Short_Selling_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                                                                y_F_Short_Selling_I = Core.nothing;  # 釋放内存;
                                                                                                                                            end
                                                                                                                                        end
                                                                                                                                    end
                                                                                                                                    # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling）;
                                                                                                                                    if !(Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array)
                                                                                                                                        Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                                                                    end
                                                                                                                                    if Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array
                                                                                                                                        # y_G_Short_Selling_I = Core.Float64(+Core.Float64(x3[Core.Int64(Base.length(x3))]));
                                                                                                                                        # Base.push!(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"], y_G_Short_Selling_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                                                        if Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array
                                                                                                                                            y_G_Short_Selling_I = Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(1)]);  # Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"]))]);
                                                                                                                                            Base.push!(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"], y_G_Short_Selling_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                                                            y_G_Short_Selling_I = Core.nothing;  # 釋放内存;
                                                                                                                                        end
                                                                                                                                    end
                                                                                                                                    # 每兩次對衝交易差價利潤初值;
                                                                                                                                    if !(Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling_profit_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_date_transaction"]) <: Core.Array)
                                                                                                                                        Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                                                                    end
                                                                                                                                    if Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling_profit_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_date_transaction"]) <: Core.Array
                                                                                                                                        if Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array
                                                                                                                                            y_A_Short_Selling_I_2 = Core.Float64(Core.Int64(-1) * Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(1)]));
                                                                                                                                            # y_A_Short_Selling_I_2 = Core.Float64(Core.Int64(-1) * Core.Float64(Core.Float64(Core.Int64(-1) * Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(1)])) + Core.Float64(y_A_Short_Selling_I)));
                                                                                                                                            y_A_Short_Selling_I = Core.Float64(y_A_Short_Selling_I_2);
                                                                                                                                            # y_A_Short_Selling_I *= Core.Float64(0.0);
                                                                                                                                            # y_A_Short_Selling_I += Core.Float64(y_A_Short_Selling_I_2);
                                                                                                                                            # y_A_Short_Selling_I += Core.Float64(-(x3[t + 1] - x3[k + 1]));
                                                                                                                                            # y_A_Short_Selling_I = Core.Float64(-(x3[t + 1] - x3[k + 1]));
                                                                                                                                            Base.push!(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_date_transaction"], y_A_Short_Selling_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                                                            y_A_Short_Selling_I = Core.nothing;  # 釋放内存;
                                                                                                                                        end
                                                                                                                                    end

                                                                                                                                    # 記錄做空模式本輪對衝交易的回撤值序列;
                                                                                                                                    if Base.typeof(drawdown_Array_Short_Selling) <: Core.Array && Core.Int64(Base.length(drawdown_Array_Short_Selling)) >= Core.Int64(0)
                                                                                                                                        Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["drawdown"] = drawdown_Array_Short_Selling;
                                                                                                                                    end
                                                                                                                                end
                                                                                                                            end
                                                                                                                        end                                
                                                                                                                    end
                                                                                                                end
                                                                                                            end
                                                                                                            return_MarketTiming_fit_model = Core.nothing;
                                                                                                        end
                                                                                                    end
                                                                                                end
                                                                                            end
                                                                                        end
                                                                                    end
                                                                                end
                                                                            end
                                                                        end

                                                                        # 判斷、執行融券做空 short selling 兩次對衝交易滑框的左邊（首，第一次，賣出交易 sell）;
                                                                        if Core.Int64(Short_Selling_sliding_frame) >= Core.Int64(1)

                                                                            # 計算該時間日期切面的交易信息;
                                                                            return_MarketTiming_fit_model = MarketTiming_fit_model(
                                                                                Base.Dict{Core.String, Core.Any}(
                                                                                    Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]) => Base.Dict{Core.String, Core.Any}(
                                                                                        "date_transaction" => x0,
                                                                                        "turnover_volume" => x1,
                                                                                        "opening_price" => x3,
                                                                                        "close_price" => x4,
                                                                                        "low_price" => x5,
                                                                                        "high_price" => x6,
                                                                                        "focus" => x7,
                                                                                        "amplitude" => x8,
                                                                                        "amplitude_rate" => x9,
                                                                                        "opening_price_Standardization" => x10,
                                                                                        "closing_price_Standardization" => x11,
                                                                                        "low_price_Standardization" => x12,
                                                                                        "high_price_Standardization" => x13,
                                                                                        "turnover_volume_growth_rate" => x14,
                                                                                        "opening_price_growth_rate" => x15,
                                                                                        "closing_price_growth_rate" => x16,
                                                                                        "closing_minus_opening_price_growth_rate" => x17,
                                                                                        "high_price_proportion" => x18,
                                                                                        "low_price_proportion" => x19
                                                                                        # "turnover_rate" => x20
                                                                                    )
                                                                                ),  # trainingData,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # ::Core.Array{Core.Float64, 2} = testingData,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
                                                                                MarketTiming_Parameter_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling"][1],  # Core.Int64(3),  # P1,  # 觀察收益率歷史向前推的交易日長度;
                                                                                MarketTiming_Parameter_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling"][2],  # Core.Float64(+1.0),  # P2,  # 買入閾值;
                                                                                MarketTiming_Parameter_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling"][3],  # Core.Float64(-1.0),  # P3,  # 賣出閾值;
                                                                                MarketTiming_Parameter_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling"][4],  # Core.Float64(0.0),  # P4,  # risk threshold drawdown loss; # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                Quantitative_Indicators_Function,
                                                                                "Short_Selling"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
                                                                            );
                                                                            # return_MarketTiming_fit_model === Base.Dict{Core.String, Core.Any}(
                                                                            #     "ticker_symbol" => Base.Dict{Core.String, Core.Any}(
                                                                            #         "y_profit" => y_profit,  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
                                                                            #         "y_Long_Position_profit" => y_Long_Position_profit,  # 優化目標變量;
                                                                            #         "y_Short_Selling_profit" => y_Short_Selling_profit,  # 優化目標變量;
                                                                            #         "y_loss" => y_loss,  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
                                                                            #         "y_Long_Position_loss" => y_Long_Position_loss,  # 優化目標變量;
                                                                            #         "y_Short_Selling_loss" => y_Short_Selling_loss,  # 優化目標變量;
                                                                            #         "profit_total" => y_total,  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                            #         "Long_Position_profit_total" => y_total_Long_Position,  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                            #         "Short_Selling_profit_total" => y_total_Short_Selling,  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                            #         "profit_Positive" => y_Positive,  # 每兩次對衝交易收益纍加總計;
                                                                            #         "Long_Position_profit_Positive" => y_Positive_Long_Position,  # 每兩次對衝交易收益纍加總計;
                                                                            #         "Short_Selling_profit_Positive" => y_Positive_Short_Selling,  # 每兩次對衝交易收益纍加總計;
                                                                            #         "profit_Positive_probability" => y_P_Positive,  # 每兩次對衝交易正利潤概率;
                                                                            #         "Long_Position_profit_Positive_probability" => y_P_Positive_Long_Position,  # 每兩次對衝交易正利潤概率;
                                                                            #         "Short_Selling_profit_Positive_probability" => y_P_Positive_Short_Selling,  # 每兩次對衝交易正利潤概率;
                                                                            #         "profit_Negative" => y_Negative,  # 每兩次對衝交易損失纍加總計;
                                                                            #         "Long_Position_profit_Negative" => y_Negative_Long_Position,  # 每兩次對衝交易損失纍加總計;
                                                                            #         "Short_Selling_profit_Negative" => y_Negative_Short_Selling,  # 每兩次對衝交易損失纍加總計;
                                                                            #         "profit_Negative_probability" => y_P_Negative,  # 每兩次對衝交易負利潤概率;
                                                                            #         "Long_Position_profit_Negative_probability" => y_P_Negative_Long_Position,  # 每兩次對衝交易負利潤概率;
                                                                            #         "Short_Selling_profit_Negative_probability" => y_P_Negative_Short_Selling,  # 每兩次對衝交易負利潤概率;
                                                                            #         "Long_Position_profit_date_transaction" => y_A_Long_Position,  # 每兩次對衝交易利潤，向量;
                                                                            #         "Short_Selling_profit_date_transaction" => y_A_Short_Selling,  # 每兩次對衝交易利潤，向量;
                                                                            #         "maximum_drawdown" => y_maximum_drawdown,  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                            #         "maximum_drawdown_Long_Position" => y_maximum_drawdown_Long_Position,  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                            #         "maximum_drawdown_Short_Selling" => y_maximum_drawdown_Short_Selling,  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                            #         "Long_Position_drawdown_date_transaction" => y_H_Long_Position,  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                            #         "Short_Selling_drawdown_date_transaction" => y_H_Short_Selling,  # 向量，記錄做空模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                            #         "average_price_amplitude_date_transaction" => y_amplitude,  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                            #         "Long_Position_average_price_amplitude_date_transaction" => y_amplitude_Long_Position,  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                            #         "Short_Selling_average_price_amplitude_date_transaction" => y_amplitude_Short_Selling,  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                            #         "Long_Position_price_amplitude_date_transaction" => y_D_Long_Position,  # 兩次對衝交易日成交價振幅平方和，向量;
                                                                            #         "Short_Selling_price_amplitude_date_transaction" => y_D_Short_Selling,  # 兩次對衝交易日成交價振幅平方和，向量;
                                                                            #         "average_volume_turnover_date_transaction" => y_turnover,  # 兩次對衝交易日成交量（換手率）均值;
                                                                            #         "Long_Position_average_volume_turnover_date_transaction" => y_turnover_Long_Position,  # 兩次對衝交易日成交量（換手率）均值;
                                                                            #         "Short_Selling_average_volume_turnover_date_transaction" => y_turnover_Short_Selling,  # 兩次對衝交易日成交量（換手率）均值;
                                                                            #         "Long_Position_volume_turnover_date_transaction" => y_E_Long_Position,  # 兩次對衝交易日成交量（換手率）向量;
                                                                            #         "Short_Selling_volume_turnover_date_transaction" => y_E_Short_Selling,  # 兩次對衝交易日成交量（換手率）向量;
                                                                            #         "average_date_transaction_between" => y_date_transaction_between,  # 兩次對衝交易間隔日長，均值;
                                                                            #         "Long_Position_average_date_transaction_between" => y_date_transaction_between_Long_Position,  # 兩次對衝交易間隔日長，均值;
                                                                            #         "Short_Selling_average_date_transaction_between" => y_date_transaction_between_Short_Selling,  # 兩次對衝交易間隔日長，均值;
                                                                            #         "Long_Position_date_transaction_between" => y_C_Long_Position,  # 兩次對衝交易間隔日長，向量;
                                                                            #         "Short_Selling_date_transaction_between" => y_C_Short_Selling,  # 兩次對衝交易間隔日長，向量;
                                                                            #         "Long_Position_date_transaction" => y_F_Long_Position,  # 按規則執行交易的日期，向量;
                                                                            #         "Short_Selling_date_transaction" => y_F_Short_Selling,  # 按規則執行交易的日期，向量;
                                                                            #         "P1_Array" => P1_Array,  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
                                                                            #         "revenue_and_expenditure_records_date_transaction" => y_G  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
                                                                            #     )
                                                                            # );
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["y_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["y_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_drawdown_date_transaction"]);  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_drawdown_date_transaction"]);  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["average_date_transaction_between"]);  # 兩次交易間隔日長，均值;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["weight_MarketTiming"]);  # 擇時權重，每兩次對衝交易的盈利概率占比;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
                                                                            # println(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
                                                                            if Base.isa(return_MarketTiming_fit_model, Base.Dict) && Base.haskey(return_MarketTiming_fit_model, Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g]))
                                                                                if Base.isa(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], Base.Dict)
                                                                                    if Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Long_Position_date_transaction") && Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling_date_transaction") && Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "revenue_and_expenditure_records_date_transaction")

                                                                                        # 判斷是否進行（融券做空 short selling）第一次對衝交易的賣出交易;
                                                                                        if Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Long_Position_date_transaction"])) === Core.Int64(0) && Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"])) === Core.Int64(2) && Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"])) === Core.Int64(2) && Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_date_transaction"])) === Core.Int64(1)
                                                                                            if return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(1)][1] === return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][1] && Base.string(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(1)][2]) === Base.string("sell") && Base.string(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][2]) === Base.string("buy") && Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(1)]) > Core.Float64(0.0) && Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"]))]) < Core.Float64(0.0) && Core.Float64(Base.abs(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_date_transaction"]))])) === Core.Float64(0.0)

                                                                                                # 清空重置做多模式每個交易日的回撤值的記錄序列：drawdown_Array_Short_Selling ;
                                                                                                Base.resize!(drawdown_Array_Short_Selling, 0);

                                                                                                # 做空（Short Selling）記錄;
                                                                                                if Base.isa(Short_Selling_testing_data_transaction_sequence_Dict, Base.Dict) && (!(Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict, Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])) && Base.isa(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], Base.Dict)))
                                                                                                    Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])] = Base.Dict{Core.String, Core.Any}();
                                                                                                end
                                                                                                if Base.isa(Short_Selling_testing_data_transaction_sequence_Dict, Base.Dict) && Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict, Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])) && Base.isa(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], Base.Dict)
                                                                                                    # 每兩次對衝交易序號標識;
                                                                                                    Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Index_date_transaction_Short_Selling"] = Core.Int64(k);  # 每兩次對衝交易序號標識;
                                                                                                    # 按規則執行第一次對衝賣出（融券做空 short selling）交易的日期;
                                                                                                    if !(Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]) <: Core.Array)
                                                                                                        Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                                    end
                                                                                                    if Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]) <: Core.Array
                                                                                                        if Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling_date_transaction") && Base.typeof(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]) <: Core.Array
                                                                                                            if Base.typeof(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))]) <: Core.Array
                                                                                                                y_F_Short_Selling_I = Core.Array{Core.Any, 1}(Core.undef, 16);  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}(Core.undef, 16);
                                                                                                                y_F_Short_Selling_I[1] = x0[Core.Int64(Base.length(x0))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][1];  # 交易時間日期（Dates.Date 或 Dates.DateTime 類型）;
                                                                                                                y_F_Short_Selling_I[2] = Base.string("sell");  # Base.string(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][2]);  # 買入或賣出;
                                                                                                                y_F_Short_Selling_I[3] = return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(1)][3];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][3];  # 成交價;
                                                                                                                if Core.Int64(Base.length(SizePosition_Parameter_Array)) >= Core.Int64(2) && Base.haskey(SizePosition_Parameter_Array[1], Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])) && Base.haskey(SizePosition_Parameter_Array[1][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling") && Base.haskey(SizePosition_Parameter_Array[2], Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])) && Base.haskey(SizePosition_Parameter_Array[2][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling")
                                                                                                                    y_F_Short_Selling_I[4] = [SizePosition_Parameter_Array[1][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling"], SizePosition_Parameter_Array[2][Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling"]];  # 倉位;
                                                                                                                else
                                                                                                                    y_F_Short_Selling_I[4] = [Core.Float64(1.0), Core.Float64(1.0)];  # 倉位;
                                                                                                                end
                                                                                                                if Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Index_date_transaction_Short_Selling")
                                                                                                                    y_F_Short_Selling_I[5] = Core.Int64(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Index_date_transaction_Short_Selling"]);  # 每兩次對衝成交序號標識;
                                                                                                                else
                                                                                                                    y_F_Short_Selling_I[5] = Core.Int64(0);  # 每兩次對衝成交序號標識;
                                                                                                                end
                                                                                                                y_F_Short_Selling_I[6] = Core.Int64(k);  # 交易日期的序列號，用於繪圖可視化;
                                                                                                                y_F_Short_Selling_I[7] = x0[Core.Int64(Base.length(x0))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][7];  # 交易日（Dates.Date 類型）;
                                                                                                                y_F_Short_Selling_I[8] = x1[Core.Int64(Base.length(x1))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][8];  # 當日總成交量（turnover volume）;
                                                                                                                y_F_Short_Selling_I[9] = x3[Core.Int64(Base.length(x3))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][9];  # 當日開盤（opening）成交價;
                                                                                                                y_F_Short_Selling_I[10] = x4[Core.Int64(Base.length(x4))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][10];  # 當日收盤（closing）成交價;
                                                                                                                y_F_Short_Selling_I[11] = x5[Core.Int64(Base.length(x5))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][11];  # 當日最低（low）成交價;
                                                                                                                y_F_Short_Selling_I[12] = x6[Core.Int64(Base.length(x6))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][12];  # 當日最高（high）成交價;
                                                                                                                # y_F_Short_Selling_I[13] = x2[Core.Int64(Base.length(x2))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][2];  # 當日總成交金額（turnover amount）;
                                                                                                                # y_F_Short_Selling_I[14] = x20[Core.Int64(Base.length(x20))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][20];  # 當日成交量（turnover volume）換手率（turnover rate）;
                                                                                                                # y_F_Short_Selling_I[15] = x21[Core.Int64(Base.length(x21))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][21];  # 當日每股收益（price earnings）;
                                                                                                                # y_F_Short_Selling_I[16] = x22[Core.Int64(Base.length(x22))];  # return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"]))][22];  # 當日每股净值（book value per share）;
                                                                                                                Base.push!(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_date_transaction"], y_F_Short_Selling_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                                y_F_Short_Selling_I = Core.nothing;  # 釋放内存;
                                                                                                            end
                                                                                                        end
                                                                                                    end
                                                                                                    # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling）;
                                                                                                    if !(Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array)
                                                                                                        Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                                    end
                                                                                                    if Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array
                                                                                                        # y_G_Short_Selling_I = Core.Float64(-Core.Float64(x3[Core.Int64(Base.length(x3))]));
                                                                                                        # Base.push!(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"], y_G_Short_Selling_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                        if Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array
                                                                                                            y_G_Short_Selling_I = Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(1)]);  # Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"]))]);
                                                                                                            Base.push!(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"], y_G_Short_Selling_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                            y_G_Short_Selling_I = Core.nothing;  # 釋放内存;
                                                                                                        end
                                                                                                    end
                                                                                                    # 每兩次對衝交易差價利潤初值;
                                                                                                    if !(Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling_profit_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_date_transaction"]) <: Core.Array)
                                                                                                        Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                                    end
                                                                                                    if Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "Short_Selling_profit_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_date_transaction"]) <: Core.Array
                                                                                                        if Base.haskey(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])], "revenue_and_expenditure_records_date_transaction") && Base.typeof(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array
                                                                                                            y_A_Short_Selling_I = Core.Float64(-Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["revenue_and_expenditure_records_date_transaction"][Core.Int64(1)]));
                                                                                                            # y_A_Short_Selling_I *= Core.Float64(0.0);
                                                                                                            # y_A_Short_Selling_I += Core.Float64(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_date_transaction"][Core.Int64(Base.length(return_MarketTiming_fit_model[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_date_transaction"]))]);
                                                                                                            # y_A_Short_Selling_I += Core.Float64(Core.Float64(0.0) - Core.Float64(x3[Core.Int64(Base.length(x3))]));
                                                                                                            # y_A_Short_Selling_I = Core.Float64(Core.Float64(0.0) - Core.Float64(x3[Core.Int64(Base.length(x3))]));
                                                                                                            Base.push!(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(PickStock_ticker_symbol_Array_testing_data_Short_Selling[t][g])]["Short_Selling_profit_date_transaction"], y_A_Short_Selling_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                            y_A_Short_Selling_I = Core.nothing;  # 釋放内存;
                                                                                                        end
                                                                                                    end
                                                                                                end
                                                                                            end
                                                                                        end
                                                                                    end
                                                                                end
                                                                            end

                                                                            return_MarketTiming_fit_model = Core.nothing;
                                                                        end

                                                                        Short_Selling_sliding_frame = Core.nothing;  # 釋放内存;
                                                                        risk_drawdown_loss_Short_Selling = Core.nothing;  # 釋放内存;

                                                                        # 釋放内存;
                                                                        x0 = Core.nothing;
                                                                        x1 = Core.nothing;
                                                                        x3 = Core.nothing;
                                                                        x4 = Core.nothing;
                                                                        x5 = Core.nothing;
                                                                        x6 = Core.nothing;
                                                                        x7 = Core.nothing;
                                                                        x8 = Core.nothing;
                                                                        x9 = Core.nothing;
                                                                        x10 = Core.nothing;
                                                                        x11 = Core.nothing;
                                                                        x12 = Core.nothing;
                                                                        x13 = Core.nothing;
                                                                        x14 = Core.nothing;
                                                                        x15 = Core.nothing;
                                                                        x16 = Core.nothing;
                                                                        x17 = Core.nothing;
                                                                        x18 = Core.nothing;
                                                                        x19 = Core.nothing;
                                                                        # x20 = Core.nothing;
                                                                        # x21 = Core.nothing;
                                                                        # x22 = Core.nothing;
                                                                        # x23 = Core.nothing;
                                                                        # x24 = Core.nothing;
                                                                        # x25 = Core.nothing;
                                                                        # x26 = Core.nothing;
                                                                        # x27 = Core.nothing;
                                                                        # x_Pdata_0 = Core.nothing;
                                                                        # x_Plower = Core.nothing;
                                                                        # x_Pupper = Core.nothing;
                                                                        # x_weight = Core.nothing;
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    t = Core.nothing;  # 釋放内存;

                                    if Core.Int64(Base.length(Long_Position_testing_data_transaction_sequence_Dict)) > Core.Int64(0) || Core.Int64(Base.length(Short_Selling_testing_data_transaction_sequence_Dict)) > Core.Int64(0)
                                        stepping_transaction_Dict["testing_transaction"] = Base.Dict{Core.String, Core.Any}();
                                        if Core.Int64(Base.length(Long_Position_testing_data_transaction_sequence_Dict)) > Core.Int64(0)
                                            stepping_transaction_Dict["testing_transaction"]["Long_Position"] = Long_Position_testing_data_transaction_sequence_Dict;
                                        end
                                        if Core.Int64(Base.length(Short_Selling_testing_data_transaction_sequence_Dict)) > Core.Int64(0)
                                            stepping_transaction_Dict["testing_transaction"]["Short_Selling"] = Short_Selling_testing_data_transaction_sequence_Dict;
                                        end
                                    end
                                    Long_Position_testing_data_transaction_sequence_Dict = Core.nothing;  # 釋放内存;
                                    Short_Selling_testing_data_transaction_sequence_Dict = Core.nothing;  # 釋放内存;

                                    if Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position)) > Core.Int64(0) && Base.typeof(PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))]) <: Core.Array
                                        if Base.haskey(PickStock_Parameter_Dict, "Long_Position")
                                            g_min = Core.Int64(Base.findmin([Core.Int64(PickStock_Parameter_Dict["Long_Position"][2]), Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))]))])[1]);
                                        else
                                            g_min = Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))]));
                                        end
                                        if Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))][Core.Int64(1):Core.Int64(1):Core.Int64(g_min)])) > Core.Int64(0)
                                            if !(Base.haskey(stepping_transaction_Dict, "testing_PickStock_ticker_symbol"))
                                                stepping_transaction_Dict["testing_PickStock_ticker_symbol"] = Base.Dict{Core.String, Core.Any}();
                                            end
                                            if Base.haskey(stepping_transaction_Dict, "testing_PickStock_ticker_symbol") && Base.isa(stepping_transaction_Dict["testing_PickStock_ticker_symbol"], Base.Dict)
                                                stepping_transaction_Dict["testing_PickStock_ticker_symbol"]["Long_Position"] = PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))][Core.Int64(1):Core.Int64(1):Core.Int64(g_min)];
                                            end
                                        end
                                    end
                                    if Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling)) > Core.Int64(0) && Base.typeof(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))]) <: Core.Array
                                        if Base.haskey(PickStock_Parameter_Dict, "Short_Selling")
                                            g_max = Core.Int64(Base.findmax([Core.Int64(1), Core.Int64(Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))])) - Core.Int64(PickStock_Parameter_Dict["Short_Selling"][2]) + Core.Int64(1))])[1]);
                                        else
                                            g_max = Core.Int64(1);
                                        end
                                        if Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))][Core.Int64(g_max):Core.Int64(1):Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))]))])) > Core.Int64(0)
                                            if !(Base.haskey(stepping_transaction_Dict, "testing_PickStock_ticker_symbol"))
                                                stepping_transaction_Dict["testing_PickStock_ticker_symbol"] = Base.Dict{Core.String, Core.Any}();
                                            end
                                            if Base.haskey(stepping_transaction_Dict, "testing_PickStock_ticker_symbol") && Base.isa(stepping_transaction_Dict["testing_PickStock_ticker_symbol"], Base.Dict)
                                                stepping_transaction_Dict["testing_PickStock_ticker_symbol"]["Short_Selling"] = PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))][Core.Int64(g_max):Core.Int64(1):Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))]))];
                                            end
                                        end
                                    end
                                    # PickStock_ticker_symbol_Array_testing_data_Long_Position = Core.nothing;  # 釋放内存;
                                    # PickStock_ticker_symbol_Array_testing_data_Short_Selling = Core.nothing;  # 釋放内存;

                                    # Base.push!(stepping_sequence_Array, stepping_transaction_Dict);  # 使用 push! 函數在數組末尾追加推入新元;
                                    # # stepping_transaction_Dict = Core.nothing;  # 釋放内存;
                                    # # testingData = Core.nothing;  # 釋放内存;

                                    if Base.haskey(stepping_transaction_Dict, "testing_transaction")

                                        # stepping_transaction_Dict["training_data"] = trainingData;
                                        # stepping_transaction_Dict["training_MarketTiming_Parameter"] = MarketTiming_Parameter_Dict;
                                        # stepping_transaction_Dict["training_PickStock_Parameter"] = PickStock_Parameter_Dict;
                                        # stepping_transaction_Dict["training_PickStock_ticker_symbol"] = PickStock_ticker_symbol_Array;
                                        # stepping_transaction_Dict["training_SizePosition_Parameter"] = SizePosition_Parameter_Array;

                                        # stepping_transaction_Dict["testing_data"] = testingData;

                                        # if Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))][Core.Int64(1):Core.Int64(1):Core.Int64(Base.findmin([Core.Int64(PickStock_Parameter_Dict["Long_Position"][2]), Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))]))])[1])])) > Core.Int64(0) || Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))][Core.Int64(Base.findmax([Core.Int64(1), Core.Int64(Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))])) - Core.Int64(PickStock_Parameter_Dict["Short_Selling"][2]) + Core.Int64(1))])[1]):Core.Int64(1):Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))]))])) > Core.Int64(0)
                                        #     stepping_transaction_Dict["testing_PickStock_ticker_symbol"] = Base.Dict{Core.String, Core.Any}();
                                        #     if Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))][Core.Int64(1):Core.Int64(1):Core.Int64(Base.findmin([Core.Int64(PickStock_Parameter_Dict["Long_Position"][2]), Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))]))])[1])])) > Core.Int64(0)
                                        #         stepping_transaction_Dict["testing_PickStock_ticker_symbol"]["Long_Position"] = PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))][Core.Int64(1):Core.Int64(1):Core.Int64(Base.findmin([Core.Int64(PickStock_Parameter_Dict["Long_Position"][2]), Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))]))])[1])];
                                        #     end
                                        #     if Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))][Core.Int64(Base.findmax([Core.Int64(1), Core.Int64(Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))])) - Core.Int64(PickStock_Parameter_Dict["Short_Selling"][2]) + Core.Int64(1))])[1]):Core.Int64(1):Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))]))])) > Core.Int64(0)
                                        #         stepping_transaction_Dict["testing_PickStock_ticker_symbol"]["Short_Selling"] = PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))][Core.Int64(Base.findmax([Core.Int64(1), Core.Int64(Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))])) - Core.Int64(PickStock_Parameter_Dict["Short_Selling"][2]) + Core.Int64(1))])[1]):Core.Int64(1):Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))]))];
                                        #     end
                                        # end
                                        # PickStock_ticker_symbol_Array_testing_data_Long_Position = Core.nothing;  # 釋放内存;
                                        # PickStock_ticker_symbol_Array_testing_data_Short_Selling = Core.nothing;  # 釋放内存;

                                        Base.push!(stepping_sequence_Array, stepping_transaction_Dict);  # 使用 push! 函數在數組末尾追加推入新元;
                                        # stepping_transaction_Dict = Core.nothing;  # 釋放内存;
                                        # testingData = Core.nothing;  # 釋放内存;
                                    end

                                    # 數據序列的最後一個交易日，强制平倉;
                                    # k = Core.Int64(Core.Int64(i) + Core.Int64(testing_data_sequence_length));
                                    if Core.Int64(k) === Core.Int64(minimum_dates_transaction)
                                        if Base.typeof(stepping_sequence_Array) <: Core.Array && Core.Int64(Base.length(stepping_sequence_Array)) > Core.Int64(0)
                                            if Base.isa(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))], Base.Dict) && Base.haskey(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))], "testing_transaction")

                                                # 依照選股規則挑選出的股票，計算（融資做多 buying long）交易利潤;
                                                Long_Position_testing_data_transaction_sequence_Dict = Base.Dict{Core.String, Core.Any}();  # 記錄按規則篩選股票按照擇時規則交易信息的序列;
                                                # 依照選股規則挑選出的股票，計算（融券做空 short selling）交易利潤;
                                                Short_Selling_testing_data_transaction_sequence_Dict = Base.Dict{Core.String, Core.Any}();  # 記錄按規則篩選股票按照擇時規則交易信息的序列;

                                                # 依照選股規則挑選出的股票，計算（融資做多 buying long）交易利潤;
                                                if Base.isa(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"], Base.Dict) && Base.haskey(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"], "Long_Position")
                                                    if Base.isa(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"], Base.Dict) && Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"])) > Core.Int64(0)
                                                        for (key, value) in stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"]
                                                            if Base.isa(value, Base.Dict) && Base.haskey(value, "Long_Position_date_transaction")
                                                                if Base.typeof(value["Long_Position_date_transaction"]) <: Core.Array && Core.Int64(Base.length(value["Long_Position_date_transaction"])) >= Core.Int64(0)
                                                                    if Base.typeof(value["Long_Position_date_transaction"][Core.Int64(Base.length(value["Long_Position_date_transaction"]))]) <: Core.Array && Core.Int64(Base.length(value["Long_Position_date_transaction"][Core.Int64(Base.length(value["Long_Position_date_transaction"]))])) >= Core.Int64(3)
                                                                        if Base.string(value["Long_Position_date_transaction"][Core.Int64(Base.length(value["Long_Position_date_transaction"]))][2]) === "buy"
                                                                            # 祇取測試數據集的最後一個交易日數據，代入交易規則，判斷交易狀態;
                                                                            # 依照選股規則挑選出的股票，計算（融資做多 buying long）交易利潤;
                                                                            # Long_Position_testing_data_transaction_sequence_Dict = Base.Dict{Core.String, Core.Any}();  # 記錄按規則篩選股票按照擇時規則交易信息的序列;
                                                                            t = Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position));  # Core.Int64(minimum_dates_transaction_testing_data);  # Core.Int64(maximum_dates_transaction_testing_data);  # Core.Int64(1);
                                                                            if Base.isa(testingData, Base.Dict) && Base.haskey(testingData, Base.string(key)) && Base.isa(testingData[Base.string(key)], Base.Dict) && Base.length(testingData[Base.string(key)]) > 0
                                                                                # 判斷循環遍歷「t」小於序列數據（1 維數組）的最大長度，並跳過超出的部分;
                                                                                if Core.Int64(t) > Core.Int64(0) && Core.Int64(t) <= Core.Int64(Base.findmin([Base.length(testingData[Base.string(key)]["date_transaction"]), Base.length(testingData[Base.string(key)]["turnover_volume"]), Base.length(testingData[Base.string(key)]["opening_price"]), Base.length(testingData[Base.string(key)]["close_price"]), Base.length(testingData[Base.string(key)]["low_price"]), Base.length(testingData[Base.string(key)]["high_price"]), Base.length(testingData[Base.string(key)]["focus"]), Base.length(testingData[Base.string(key)]["amplitude"]), Base.length(testingData[Base.string(key)]["amplitude_rate"]), Base.length(testingData[Base.string(key)]["opening_price_Standardization"]), Base.length(testingData[Base.string(key)]["closing_price_Standardization"]), Base.length(testingData[Base.string(key)]["low_price_Standardization"]), Base.length(testingData[Base.string(key)]["high_price_Standardization"]), Base.length(testingData[Base.string(key)]["turnover_volume_growth_rate"]), Base.length(testingData[Base.string(key)]["opening_price_growth_rate"]), Base.length(testingData[Base.string(key)]["closing_price_growth_rate"]), Base.length(testingData[Base.string(key)]["closing_minus_opening_price_growth_rate"]), Base.length(testingData[Base.string(key)]["high_price_proportion"]), Base.length(testingData[Base.string(key)]["low_price_proportion"])])[1])
                                                                                    if Base.haskey(MarketTiming_Parameter_Dict, Base.string(key)) && Base.haskey(MarketTiming_Parameter_Dict[Base.string(key)], "Long_Position") && Core.Int64(t) >= Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2))

                                                                                        x0 = testingData[Base.string(key)]["date_transaction"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 交易日期;
                                                                                        x1 = testingData[Base.string(key)]["turnover_volume"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 成交量;
                                                                                        # x2 = testingData[Base.string(key)]["turnover_amount"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 成交總金額;
                                                                                        x3 = testingData[Base.string(key)]["opening_price"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 開盤成交價;
                                                                                        x4 = testingData[Base.string(key)]["close_price"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤成交價;
                                                                                        x5 = testingData[Base.string(key)]["low_price"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 最低成交價;
                                                                                        x6 = testingData[Base.string(key)]["high_price"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 最高成交價;
                                                                                        x7 = testingData[Base.string(key)]["focus"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 當日成交價重心;
                                                                                        x8 = testingData[Base.string(key)]["amplitude"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 當日成交價絕對振幅;
                                                                                        x9 = testingData[Base.string(key)]["amplitude_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 當日成交價相對振幅（%）;
                                                                                        x10 = testingData[Base.string(key)]["opening_price_Standardization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 日棒缐（K Line Daily）數據交易日首筆成交價（開盤價）標準化值;
                                                                                        x11 = testingData[Base.string(key)]["closing_price_Standardization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 日棒缐（K Line Daily）數據交易日尾筆成交價（收盤價）標準化值;
                                                                                        x12 = testingData[Base.string(key)]["low_price_Standardization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 日棒缐（K Line Daily）數據交易日最低成交價標準化值;
                                                                                        x13 = testingData[Base.string(key)]["high_price_Standardization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 日棒缐（K Line Daily）數據交易日最高成交價標準化值;
                                                                                        x14 = testingData[Base.string(key)]["turnover_volume_growth_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 成交量的成長率;
                                                                                        x15 = testingData[Base.string(key)]["opening_price_growth_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 開盤價的成長率;
                                                                                        x16 = testingData[Base.string(key)]["closing_price_growth_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價的成長率;
                                                                                        x17 = testingData[Base.string(key)]["closing_minus_opening_price_growth_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價減開盤價的成長率;
                                                                                        x18 = testingData[Base.string(key)]["high_price_proportion"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價和開盤價裏的最大值占最高價的比例;
                                                                                        x19 = testingData[Base.string(key)]["low_price_proportion"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 最低價占收盤價和開盤價裏的最小值的比例;
                                                                                        # x20 = testingData[Base.string(key)]["turnover_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 成交量換手率;
                                                                                        # x21 = testingData[Base.string(key)]["price_earnings"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 每股收益（公司經營利潤率 ÷ 股本）;
                                                                                        # x22 = testingData[Base.string(key)]["book_value_per_share"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 每股净值（公司净資產 ÷ 股本）;
                                                                                        # x23 = testingData[Base.string(key)]["capitalization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 總市值;
                                                                                        # x24 = testingData[Base.string(key)]["moving_average_5"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價 5 日滑動平均缐;
                                                                                        # x25 = testingData[Base.string(key)]["moving_average_10"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價 10 日滑動平均缐;
                                                                                        # x26 = testingData[Base.string(key)]["moving_average_20"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價 20 日滑動平均缐;
                                                                                        # x27 = testingData[Base.string(key)]["moving_average_30"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Long_Position"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價 30 日滑動平均缐;
                                                                                        # x_Pdata_0 = testingData[Base.string(key)]["Pdata_0"];
                                                                                        # x_Plower = testingData[Base.string(key)]["Plower"];
                                                                                        # x_Pupper = testingData[Base.string(key)]["Pupper"];
                                                                                        # x_weight = testingData[Base.string(key)]["weight"];

                                                                                        risk_drawdown_loss_Long_Position = Core.Float64(Core.Float64(x3[Core.Int64(Base.length(x3))]) / Core.Float64(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(key)]["Long_Position_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(key)]["Long_Position_date_transaction"]))][3]));  # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                        # risk_threshold_drawdown_loss = Core.Float64(MarketTiming_Parameter_Dict[Base.string(key)]["Long_Position"][4]);  # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                        # risk_drawdown_loss_Long_Position = Core.Float64(Core.Float64(risk_threshold_drawdown_loss) + Core.Float64(0.1));  # 回撤比例初值，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                        # risk_drawdown_loss_Long_Position *= Core.Float64(0.0);
                                                                                        # risk_drawdown_loss_Long_Position += Core.Float64(Core.Float64(x3[Core.Int64(Base.length(x3))]) / Core.Float64(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(key)]["Long_Position_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(key)]["Long_Position_date_transaction"]))][3]));  # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                        # # risk_drawdown_loss_Long_Position += Core.Float64(Core.Float64(Base.abs(Core.Float64(x3[Core.Int64(Base.length(x3))]))) / Core.Float64(Base.abs(Core.Float64(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(key)]["Long_Position_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Long_Position"][Base.string(key)]["Long_Position_date_transaction"]))][3]))));  # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;

                                                                                        # # 記錄做多模式每個交易日的回撤值序列;
                                                                                        # Base.push!(drawdown_Array_Long_Position, risk_drawdown_loss_Long_Position);  # 使用 push! 函數在數組末尾追加推入新元;

                                                                                        # 做多（Long Position）記錄;
                                                                                        if Base.isa(Long_Position_testing_data_transaction_sequence_Dict, Base.Dict) && (!(Base.haskey(Long_Position_testing_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)], Base.Dict)))
                                                                                            Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                                                                        end
                                                                                        if Base.isa(Long_Position_testing_data_transaction_sequence_Dict, Base.Dict) && Base.haskey(Long_Position_testing_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)], Base.Dict)
                                                                                            # 每兩次對衝交易序號標識;
                                                                                            Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)]["Index_date_transaction_Long_Position"] = Core.Int64(k);  # 每兩次對衝交易序號標識;
                                                                                            # 按規則執行第二次對衝賣出（融資做多 buying long）交易的日期;
                                                                                            if !(Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)], "Long_Position_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)]["Long_Position_date_transaction"]) <: Core.Array)
                                                                                                Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)]["Long_Position_date_transaction"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                            end
                                                                                            if Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)], "Long_Position_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)]["Long_Position_date_transaction"]) <: Core.Array
                                                                                                y_F_Long_Position_I = Core.Array{Core.Any, 1}(Core.undef, 16);  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}(Core.undef, 16);
                                                                                                y_F_Long_Position_I[1] = x0[Core.Int64(Base.length(x0))];  # 交易時間日期（Dates.Date 或 Dates.DateTime 類型）;
                                                                                                y_F_Long_Position_I[2] = Base.string("sell");  # 買入或賣出;
                                                                                                y_F_Long_Position_I[3] = x3[Core.Int64(Base.length(x3))];  # 成交價;
                                                                                                if Core.Int64(Base.length(SizePosition_Parameter_Array)) >= Core.Int64(2) && Base.haskey(SizePosition_Parameter_Array[1], Base.string(key)) && Base.haskey(SizePosition_Parameter_Array[1][Base.string(key)], "Long_Position") && Base.haskey(SizePosition_Parameter_Array[2], Base.string(key)) && Base.haskey(SizePosition_Parameter_Array[2][Base.string(key)], "Long_Position")
                                                                                                    y_F_Long_Position_I[4] = [SizePosition_Parameter_Array[1][Base.string(key)]["Long_Position"], SizePosition_Parameter_Array[2][Base.string(key)]["Long_Position"]];  # 倉位;
                                                                                                else
                                                                                                    y_F_Long_Position_I[4] = [Core.Float64(1.0), Core.Float64(1.0)];  # 倉位;
                                                                                                end
                                                                                                if Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)], "Index_date_transaction_Long_Position")
                                                                                                    y_F_Long_Position_I[5] = Core.Int64(Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)]["Index_date_transaction_Long_Position"]);  # 每兩次對衝成交序號標識;
                                                                                                else
                                                                                                    y_F_Long_Position_I[5] = Core.Int64(0);  # 每兩次對衝成交序號標識;
                                                                                                end
                                                                                                y_F_Long_Position_I[6] = Core.Int64(k);  # 交易日期的序列號，用於繪圖可視化;
                                                                                                y_F_Long_Position_I[7] = x0[Core.Int64(Base.length(x0))];  # 交易日（Dates.Date 類型）;
                                                                                                y_F_Long_Position_I[8] = x1[Core.Int64(Base.length(x1))];  # 當日總成交量（turnover volume）;
                                                                                                y_F_Long_Position_I[9] = x3[Core.Int64(Base.length(x3))];  # 當日開盤（opening）成交價;
                                                                                                y_F_Long_Position_I[10] = x4[Core.Int64(Base.length(x4))];  # 當日收盤（closing）成交價;
                                                                                                y_F_Long_Position_I[11] = x5[Core.Int64(Base.length(x5))];  # 當日最低（low）成交價;
                                                                                                y_F_Long_Position_I[12] = x6[Core.Int64(Base.length(x6))];  # 當日最高（high）成交價;
                                                                                                # y_F_Long_Position_I[13] = x2[Core.Int64(Base.length(x2))];  # 當日總成交金額（turnover amount）;
                                                                                                # y_F_Long_Position_I[14] = x20[Core.Int64(Base.length(x20))];  # 當日成交量（turnover volume）換手率（turnover rate）;
                                                                                                # y_F_Long_Position_I[15] = x21[Core.Int64(Base.length(x21))];  # 當日每股收益（price earnings）;
                                                                                                # y_F_Long_Position_I[16] = x22[Core.Int64(Base.length(x22))];  # 當日每股净值（book value per share）;
                                                                                                Base.push!(Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)]["Long_Position_date_transaction"], y_F_Long_Position_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                y_F_Long_Position_I = Core.nothing;  # 釋放内存;
                                                                                            end
                                                                                            # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling）;
                                                                                            if !(Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)], "revenue_and_expenditure_records_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array)
                                                                                                Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)]["revenue_and_expenditure_records_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                            end
                                                                                            if Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)], "revenue_and_expenditure_records_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array
                                                                                                y_G_Long_Position_I = Core.Float64(+Core.Float64(x3[Core.Int64(Base.length(x3))]));
                                                                                                Base.push!(Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)]["revenue_and_expenditure_records_date_transaction"], y_G_Long_Position_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                y_G_Long_Position_I = Core.nothing;  # 釋放内存;
                                                                                            end
                                                                                            # 每兩次對衝交易差價利潤初值;
                                                                                            if !(Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)], "Long_Position_profit_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)]["Long_Position_profit_date_transaction"]) <: Core.Array)
                                                                                                Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)]["Long_Position_profit_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                            end
                                                                                            if Base.haskey(Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)], "Long_Position_profit_date_transaction") && Base.typeof(Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)]["Long_Position_profit_date_transaction"]) <: Core.Array
                                                                                                y_A_Long_Position_I_2 = Core.Float64(+Core.Float64(x3[Core.Int64(Base.length(x3))]));
                                                                                                # y_A_Long_Position_I_2 = Core.Float64(Core.Float64(x3[Core.Int64(Base.length(x3))]) + Core.Float64(y_A_Long_Position_I));
                                                                                                y_A_Long_Position_I = Core.Float64(y_A_Long_Position_I_2);
                                                                                                # y_A_Long_Position_I *= Core.Float64(0.0);
                                                                                                # y_A_Long_Position_I += Core.Float64(y_A_Long_Position_I_2);
                                                                                                # y_A_Long_Position_I += Core.Float64(x3[t + 1] - x3[k + 1]);
                                                                                                # y_A_Long_Position_I = Core.Float64(x3[t + 1] - x3[k + 1]);
                                                                                                Base.push!(Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)]["Long_Position_profit_date_transaction"], y_A_Long_Position_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                y_A_Long_Position_I = Core.nothing;  # 釋放内存;
                                                                                            end

                                                                                            # 記錄做多模式本輪對衝交易的回撤值序列;
                                                                                            if Base.typeof(drawdown_Array_Long_Position) <: Core.Array && Core.Int64(Base.length(drawdown_Array_Long_Position)) >= Core.Int64(0)
                                                                                                Long_Position_testing_data_transaction_sequence_Dict[Base.string(key)]["drawdown"] = drawdown_Array_Long_Position;
                                                                                            end
                                                                                        end

                                                                                        # 釋放内存;
                                                                                        x0 = Core.nothing;
                                                                                        x1 = Core.nothing;
                                                                                        x3 = Core.nothing;
                                                                                        x4 = Core.nothing;
                                                                                        x5 = Core.nothing;
                                                                                        x6 = Core.nothing;
                                                                                        x7 = Core.nothing;
                                                                                        x8 = Core.nothing;
                                                                                        x9 = Core.nothing;
                                                                                        x10 = Core.nothing;
                                                                                        x11 = Core.nothing;
                                                                                        x12 = Core.nothing;
                                                                                        x13 = Core.nothing;
                                                                                        x14 = Core.nothing;
                                                                                        x15 = Core.nothing;
                                                                                        x16 = Core.nothing;
                                                                                        x17 = Core.nothing;
                                                                                        x18 = Core.nothing;
                                                                                        x19 = Core.nothing;
                                                                                        # x20 = Core.nothing;
                                                                                        # x21 = Core.nothing;
                                                                                        # x22 = Core.nothing;
                                                                                        # x23 = Core.nothing;
                                                                                        # x24 = Core.nothing;
                                                                                        # x25 = Core.nothing;
                                                                                        # x26 = Core.nothing;
                                                                                        # x27 = Core.nothing;
                                                                                        # x_Pdata_0 = Core.nothing;
                                                                                        # x_Plower = Core.nothing;
                                                                                        # x_Pupper = Core.nothing;
                                                                                        # x_weight = Core.nothing;
                                                                                    end
                                                                                end
                                                                            end
                                                                            t = Core.nothing;  # 釋放内存;
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                                # 依照選股規則挑選出的股票，計算（融券做空 short selling）交易利潤;
                                                if Base.isa(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"], Base.Dict) && Base.haskey(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"], "Short_Selling")
                                                    if Base.isa(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"], Base.Dict) && Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"])) > Core.Int64(0)
                                                        for (key, value) in stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"]
                                                            if Base.isa(value, Base.Dict) && Base.haskey(value, "Short_Selling_date_transaction")
                                                                if Base.typeof(value["Short_Selling_date_transaction"]) <: Core.Array && Core.Int64(Base.length(value["Short_Selling_date_transaction"])) >= Core.Int64(0)
                                                                    if Base.typeof(value["Short_Selling_date_transaction"][Core.Int64(Base.length(value["Short_Selling_date_transaction"]))]) <: Core.Array && Core.Int64(Base.length(value["Short_Selling_date_transaction"][Core.Int64(Base.length(value["Short_Selling_date_transaction"]))])) >= Core.Int64(3)
                                                                        if Base.string(value["Short_Selling_date_transaction"][Core.Int64(Base.length(value["Short_Selling_date_transaction"]))][2]) === "sell"
                                                                            # 祇取測試數據集的最後一個交易日數據，代入交易規則，判斷交易狀態;
                                                                            # 依照選股規則挑選出的股票，計算（融券做空 short selling）交易利潤;
                                                                            # Short_Selling_testing_data_transaction_sequence_Dict = Base.Dict{Core.String, Core.Any}();  # 記錄按規則篩選股票按照擇時規則交易信息的序列;
                                                                            t = Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling));  # Core.Int64(minimum_dates_transaction_testing_data);  # Core.Int64(maximum_dates_transaction_testing_data);  # Core.Int64(1);
                                                                            if Base.isa(testingData, Base.Dict) && Base.haskey(testingData, Base.string(key)) && Base.isa(testingData[Base.string(key)], Base.Dict) && Base.length(testingData[Base.string(key)]) > 0
                                                                                # 判斷循環遍歷「t」小於序列數據（1 維數組）的最大長度，並跳過超出的部分;
                                                                                if Core.Int64(t) > Core.Int64(0) && Core.Int64(t) <= Core.Int64(Base.findmin([Base.length(testingData[Base.string(key)]["date_transaction"]), Base.length(testingData[Base.string(key)]["turnover_volume"]), Base.length(testingData[Base.string(key)]["opening_price"]), Base.length(testingData[Base.string(key)]["close_price"]), Base.length(testingData[Base.string(key)]["low_price"]), Base.length(testingData[Base.string(key)]["high_price"]), Base.length(testingData[Base.string(key)]["focus"]), Base.length(testingData[Base.string(key)]["amplitude"]), Base.length(testingData[Base.string(key)]["amplitude_rate"]), Base.length(testingData[Base.string(key)]["opening_price_Standardization"]), Base.length(testingData[Base.string(key)]["closing_price_Standardization"]), Base.length(testingData[Base.string(key)]["low_price_Standardization"]), Base.length(testingData[Base.string(key)]["high_price_Standardization"]), Base.length(testingData[Base.string(key)]["turnover_volume_growth_rate"]), Base.length(testingData[Base.string(key)]["opening_price_growth_rate"]), Base.length(testingData[Base.string(key)]["closing_price_growth_rate"]), Base.length(testingData[Base.string(key)]["closing_minus_opening_price_growth_rate"]), Base.length(testingData[Base.string(key)]["high_price_proportion"]), Base.length(testingData[Base.string(key)]["low_price_proportion"])])[1])
                                                                                    if Base.haskey(MarketTiming_Parameter_Dict, Base.string(key)) && Base.haskey(MarketTiming_Parameter_Dict[Base.string(key)], "Short_Selling") && Core.Int64(t) >= Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2))

                                                                                        x0 = testingData[Base.string(key)]["date_transaction"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 交易日期;
                                                                                        x1 = testingData[Base.string(key)]["turnover_volume"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 成交量;
                                                                                        # x2 = testingData[Base.string(key)]["turnover_amount"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 成交總金額;
                                                                                        x3 = testingData[Base.string(key)]["opening_price"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 開盤成交價;
                                                                                        x4 = testingData[Base.string(key)]["close_price"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤成交價;
                                                                                        x5 = testingData[Base.string(key)]["low_price"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 最低成交價;
                                                                                        x6 = testingData[Base.string(key)]["high_price"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 最高成交價;
                                                                                        x7 = testingData[Base.string(key)]["focus"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 當日成交價重心;
                                                                                        x8 = testingData[Base.string(key)]["amplitude"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 當日成交價絕對振幅;
                                                                                        x9 = testingData[Base.string(key)]["amplitude_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 當日成交價相對振幅（%）;
                                                                                        x10 = testingData[Base.string(key)]["opening_price_Standardization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 日棒缐（K Line Daily）數據交易日首筆成交價（開盤價）標準化值;
                                                                                        x11 = testingData[Base.string(key)]["closing_price_Standardization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 日棒缐（K Line Daily）數據交易日尾筆成交價（收盤價）標準化值;
                                                                                        x12 = testingData[Base.string(key)]["low_price_Standardization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 日棒缐（K Line Daily）數據交易日最低成交價標準化值;
                                                                                        x13 = testingData[Base.string(key)]["high_price_Standardization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 日棒缐（K Line Daily）數據交易日最高成交價標準化值;
                                                                                        x14 = testingData[Base.string(key)]["turnover_volume_growth_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 成交量的成長率;
                                                                                        x15 = testingData[Base.string(key)]["opening_price_growth_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 開盤價的成長率;
                                                                                        x16 = testingData[Base.string(key)]["closing_price_growth_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價的成長率;
                                                                                        x17 = testingData[Base.string(key)]["closing_minus_opening_price_growth_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價減開盤價的成長率;
                                                                                        x18 = testingData[Base.string(key)]["high_price_proportion"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價和開盤價裏的最大值占最高價的比例;
                                                                                        x19 = testingData[Base.string(key)]["low_price_proportion"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 最低價占收盤價和開盤價裏的最小值的比例;
                                                                                        # x20 = testingData[Base.string(key)]["turnover_rate"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 成交量換手率;
                                                                                        # x21 = testingData[Base.string(key)]["price_earnings"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 每股收益（公司經營利潤率 ÷ 股本）;
                                                                                        # x22 = testingData[Base.string(key)]["book_value_per_share"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 每股净值（公司净資產 ÷ 股本）;
                                                                                        # x23 = testingData[Base.string(key)]["capitalization"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 總市值;
                                                                                        # x24 = testingData[Base.string(key)]["moving_average_5"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價 5 日滑動平均缐;
                                                                                        # x25 = testingData[Base.string(key)]["moving_average_10"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價 10 日滑動平均缐;
                                                                                        # x26 = testingData[Base.string(key)]["moving_average_20"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價 20 日滑動平均缐;
                                                                                        # x27 = testingData[Base.string(key)]["moving_average_30"][Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # [Core.Int64(Core.Int64(t) - Core.Int64(Core.Int64(PickStock_Parameter_Dict["Short_Selling"][1]) + Core.Int64(2)) + Core.Int64(1)):Core.Int64(1):Core.Int64(t)];  # 收盤價 30 日滑動平均缐;
                                                                                        # x_Pdata_0 = testingData[Base.string(key)]["Pdata_0"];
                                                                                        # x_Plower = testingData[Base.string(key)]["Plower"];
                                                                                        # x_Pupper = testingData[Base.string(key)]["Pupper"];
                                                                                        # x_weight = testingData[Base.string(key)]["weight"];

                                                                                        risk_drawdown_loss_Short_Selling = Core.Float64(Core.Float64(1.0) + Core.Float64(Core.Float64(Core.Float64(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(key)]["Short_Selling_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(key)]["Short_Selling_date_transaction"]))][3]) - Core.Float64(x3[Core.Int64(Base.length(x3))])) / Core.Float64(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(key)]["Short_Selling_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(key)]["Short_Selling_date_transaction"]))][3])));  # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                        # risk_threshold_drawdown_loss = Core.Float64(MarketTiming_Parameter_Dict[Base.string(key)]["Short_Selling"][4]);  # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                        # risk_drawdown_loss_Short_Selling = Core.Float64(Core.Float64(risk_threshold_drawdown_loss) + Core.Float64(0.1));  # 回撤比例初值，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                        # risk_drawdown_loss_Short_Selling *= Core.Float64(0.0);
                                                                                        # risk_drawdown_loss_Short_Selling += Core.Float64(Core.Float64(1.0) + Core.Float64(Core.Float64(Core.Float64(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(key)]["Short_Selling_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(key)]["Short_Selling_date_transaction"]))][3]) - Core.Float64(x3[Core.Int64(Base.length(x3))])) / Core.Float64(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(key)]["Short_Selling_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(key)]["Short_Selling_date_transaction"]))][3])));  # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
                                                                                        # # risk_drawdown_loss_Short_Selling += Core.Float64(Core.Float64(1.0) + Core.Float64(Core.Float64(Core.Float64(Base.abs(Core.Float64(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(key)]["Short_Selling_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(key)]["Short_Selling_date_transaction"]))][3]))) - Core.Float64(Base.abs(Core.Float64(x3[Core.Int64(Base.length(x3))])))) / Core.Float64(Base.abs(Core.Float64(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(key)]["Short_Selling_date_transaction"][Core.Int64(Base.length(stepping_sequence_Array[Core.Int64(Base.length(stepping_sequence_Array))]["testing_transaction"]["Short_Selling"][Base.string(key)]["Short_Selling_date_transaction"]))][3])))));  # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;

                                                                                        # # 記錄做空模式每個交易日的回撤值序列;
                                                                                        # Base.push!(drawdown_Array_Short_Selling, risk_drawdown_loss_Short_Selling);  # 使用 push! 函數在數組末尾追加推入新元;

                                                                                        # 做空（Short Selling）記錄;
                                                                                        if Base.isa(Short_Selling_testing_data_transaction_sequence_Dict, Base.Dict) && (!(Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)], Base.Dict)))
                                                                                            Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                                                                        end
                                                                                        if Base.isa(Short_Selling_testing_data_transaction_sequence_Dict, Base.Dict) && Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)], Base.Dict)
                                                                                            # 每兩次對衝交易序號標識;
                                                                                            Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)]["Index_date_transaction_Short_Selling"] = Core.Int64(k);  # 每兩次對衝交易序號標識;
                                                                                            # 按規則執行第一次對衝賣出（融券做空 short selling）交易的日期;
                                                                                            if !(Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)], "Short_Selling_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling_date_transaction"]) <: Core.Array)
                                                                                                Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling_date_transaction"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                            end
                                                                                            if Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)], "Short_Selling_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling_date_transaction"]) <: Core.Array
                                                                                                y_F_Short_Selling_I = Core.Array{Core.Any, 1}(Core.undef, 16);  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}(Core.undef, 16);
                                                                                                y_F_Short_Selling_I[1] = x0[Core.Int64(Base.length(x0))];  # 交易時間日期（Dates.Date 或 Dates.DateTime 類型）;
                                                                                                y_F_Short_Selling_I[2] = Base.string("buy");  # 買入或賣出;
                                                                                                y_F_Short_Selling_I[3] = x3[Core.Int64(Base.length(x3))];  # 成交價;
                                                                                                if Core.Int64(Base.length(SizePosition_Parameter_Array)) >= Core.Int64(2) && Base.haskey(SizePosition_Parameter_Array[1], Base.string(key)) && Base.haskey(SizePosition_Parameter_Array[1][Base.string(key)], "Short_Selling") && Base.haskey(SizePosition_Parameter_Array[2], Base.string(key)) && Base.haskey(SizePosition_Parameter_Array[2][Base.string(key)], "Short_Selling")
                                                                                                    y_F_Short_Selling_I[4] = [SizePosition_Parameter_Array[1][Base.string(key)]["Short_Selling"], SizePosition_Parameter_Array[2][Base.string(key)]["Short_Selling"]];  # 倉位;
                                                                                                else
                                                                                                    y_F_Short_Selling_I[4] = [Core.Float64(1.0), Core.Float64(1.0)];  # 倉位;
                                                                                                end
                                                                                                if Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)], "Index_date_transaction_Short_Selling")
                                                                                                    y_F_Short_Selling_I[5] = Core.Int64(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)]["Index_date_transaction_Short_Selling"]);  # 每兩次對衝成交序號標識;
                                                                                                else
                                                                                                    y_F_Short_Selling_I[5] = Core.Int64(0);  # 每兩次對衝成交序號標識;
                                                                                                end
                                                                                                y_F_Short_Selling_I[6] = Core.Int64(k);  # 交易日期的序列號，用於繪圖可視化;
                                                                                                y_F_Short_Selling_I[7] = x0[Core.Int64(Base.length(x0))];  # 交易日（Dates.Date 類型）;
                                                                                                y_F_Short_Selling_I[8] = x1[Core.Int64(Base.length(x1))];  # 當日總成交量（turnover volume）;
                                                                                                y_F_Short_Selling_I[9] = x3[Core.Int64(Base.length(x3))];  # 當日開盤（opening）成交價;
                                                                                                y_F_Short_Selling_I[10] = x4[Core.Int64(Base.length(x4))];  # 當日收盤（closing）成交價;
                                                                                                y_F_Short_Selling_I[11] = x5[Core.Int64(Base.length(x5))];  # 當日最低（low）成交價;
                                                                                                y_F_Short_Selling_I[12] = x6[Core.Int64(Base.length(x6))];  # 當日最高（high）成交價;
                                                                                                # y_F_Short_Selling_I[13] = x2[Core.Int64(Base.length(x2))];  # 當日總成交金額（turnover amount）;
                                                                                                # y_F_Short_Selling_I[14] = x20[Core.Int64(Base.length(x20))];  # 當日成交量（turnover volume）換手率（turnover rate）;
                                                                                                # y_F_Short_Selling_I[15] = x21[Core.Int64(Base.length(x21))];  # 當日每股收益（price earnings）;
                                                                                                # y_F_Short_Selling_I[16] = x22[Core.Int64(Base.length(x22))];  # 當日每股净值（book value per share）;
                                                                                                Base.push!(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling_date_transaction"], y_F_Short_Selling_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                y_F_Short_Selling_I = Core.nothing;  # 釋放内存;
                                                                                            end
                                                                                            # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling）;
                                                                                            if !(Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)], "revenue_and_expenditure_records_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array)
                                                                                                Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)]["revenue_and_expenditure_records_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                            end
                                                                                            if Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)], "revenue_and_expenditure_records_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)]["revenue_and_expenditure_records_date_transaction"]) <: Core.Array
                                                                                                y_G_Short_Selling_I = Core.Float64(-Core.Float64(x3[Core.Int64(Base.length(x3))]));
                                                                                                Base.push!(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)]["revenue_and_expenditure_records_date_transaction"], y_G_Short_Selling_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                y_G_Short_Selling_I = Core.nothing;  # 釋放内存;
                                                                                            end
                                                                                            # 每兩次對衝交易差價利潤初值;
                                                                                            if !(Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)], "Short_Selling_profit_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling_profit_date_transaction"]) <: Core.Array)
                                                                                                Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling_profit_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                                                            end
                                                                                            if Base.haskey(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)], "Short_Selling_profit_date_transaction") && Base.typeof(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling_profit_date_transaction"]) <: Core.Array
                                                                                                y_A_Short_Selling_I_2 = Core.Float64(+Core.Float64(x3[Core.Int64(Base.length(x3))]));
                                                                                                # y_A_Short_Selling_I_2 = Core.Float64(Core.Int64(-1) * Core.Float64(Core.Float64(x3[Core.Int64(Base.length(x3))]) + Core.Float64(y_A_Short_Selling_I)));
                                                                                                y_A_Short_Selling_I = Core.Float64(y_A_Short_Selling_I_2);
                                                                                                # y_A_Short_Selling_I *= Core.Float64(0.0);
                                                                                                # y_A_Short_Selling_I += Core.Float64(y_A_Short_Selling_I_2);
                                                                                                # y_A_Short_Selling_I += Core.Float64(-(x3[t + 1] - x3[k + 1]));
                                                                                                # y_A_Short_Selling_I = Core.Float64(-(x3[t + 1] - x3[k + 1]));
                                                                                                Base.push!(Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling_profit_date_transaction"], y_A_Short_Selling_I);  # 使用 push! 函數在數組末尾追加推入新元;
                                                                                                y_A_Short_Selling_I = Core.nothing;  # 釋放内存;
                                                                                            end

                                                                                            # 記錄做空模式本輪對衝交易的回撤值序列;
                                                                                            if Base.typeof(drawdown_Array_Short_Selling) <: Core.Array && Core.Int64(Base.length(drawdown_Array_Short_Selling)) >= Core.Int64(0)
                                                                                                Short_Selling_testing_data_transaction_sequence_Dict[Base.string(key)]["drawdown"] = drawdown_Array_Short_Selling;
                                                                                            end
                                                                                        end

                                                                                        # 釋放内存;
                                                                                        x0 = Core.nothing;
                                                                                        x1 = Core.nothing;
                                                                                        x3 = Core.nothing;
                                                                                        x4 = Core.nothing;
                                                                                        x5 = Core.nothing;
                                                                                        x6 = Core.nothing;
                                                                                        x7 = Core.nothing;
                                                                                        x8 = Core.nothing;
                                                                                        x9 = Core.nothing;
                                                                                        x10 = Core.nothing;
                                                                                        x11 = Core.nothing;
                                                                                        x12 = Core.nothing;
                                                                                        x13 = Core.nothing;
                                                                                        x14 = Core.nothing;
                                                                                        x15 = Core.nothing;
                                                                                        x16 = Core.nothing;
                                                                                        x17 = Core.nothing;
                                                                                        x18 = Core.nothing;
                                                                                        x19 = Core.nothing;
                                                                                        # x20 = Core.nothing;
                                                                                        # x21 = Core.nothing;
                                                                                        # x22 = Core.nothing;
                                                                                        # x23 = Core.nothing;
                                                                                        # x24 = Core.nothing;
                                                                                        # x25 = Core.nothing;
                                                                                        # x26 = Core.nothing;
                                                                                        # x27 = Core.nothing;
                                                                                        # x_Pdata_0 = Core.nothing;
                                                                                        # x_Plower = Core.nothing;
                                                                                        # x_Pupper = Core.nothing;
                                                                                        # x_weight = Core.nothing;
                                                                                    end
                                                                                end
                                                                            end
                                                                            t = Core.nothing;  # 釋放内存;
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end

                                                if Core.Int64(Base.length(Long_Position_testing_data_transaction_sequence_Dict)) > Core.Int64(0) || Core.Int64(Base.length(Short_Selling_testing_data_transaction_sequence_Dict)) > Core.Int64(0)
                                                    stepping_transaction_Dict["testing_transaction"] = Base.Dict{Core.String, Core.Any}();
                                                    if Core.Int64(Base.length(Long_Position_testing_data_transaction_sequence_Dict)) > Core.Int64(0)
                                                        stepping_transaction_Dict["testing_transaction"]["Long_Position"] = Long_Position_testing_data_transaction_sequence_Dict;
                                                    end
                                                    if Core.Int64(Base.length(Short_Selling_testing_data_transaction_sequence_Dict)) > Core.Int64(0)
                                                        stepping_transaction_Dict["testing_transaction"]["Short_Selling"] = Short_Selling_testing_data_transaction_sequence_Dict;
                                                    end
                                                end
                                                Long_Position_testing_data_transaction_sequence_Dict = Core.nothing;  # 釋放内存;
                                                Short_Selling_testing_data_transaction_sequence_Dict = Core.nothing;  # 釋放内存;

                                                if Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position)) > Core.Int64(0) && Base.typeof(PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))]) <: Core.Array
                                                    if Base.haskey(PickStock_Parameter_Dict, "Long_Position")
                                                        g_min = Core.Int64(Base.findmin([Core.Int64(PickStock_Parameter_Dict["Long_Position"][2]), Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))]))])[1]);
                                                    else
                                                        g_min = Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))]));
                                                    end
                                                    if Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))][Core.Int64(1):Core.Int64(1):Core.Int64(g_min)])) > Core.Int64(0)
                                                        if !(Base.haskey(stepping_transaction_Dict, "testing_PickStock_ticker_symbol"))
                                                            stepping_transaction_Dict["testing_PickStock_ticker_symbol"] = Base.Dict{Core.String, Core.Any}();
                                                        end
                                                        if Base.haskey(stepping_transaction_Dict, "testing_PickStock_ticker_symbol") && Base.isa(stepping_transaction_Dict["testing_PickStock_ticker_symbol"], Base.Dict)
                                                            stepping_transaction_Dict["testing_PickStock_ticker_symbol"]["Long_Position"] = PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))][Core.Int64(1):Core.Int64(1):Core.Int64(g_min)];
                                                        end
                                                    end
                                                end
                                                if Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling)) > Core.Int64(0) && Base.typeof(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))]) <: Core.Array
                                                    if Base.haskey(PickStock_Parameter_Dict, "Short_Selling")
                                                        g_max = Core.Int64(Base.findmax([Core.Int64(1), Core.Int64(Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))])) - Core.Int64(PickStock_Parameter_Dict["Short_Selling"][2]) + Core.Int64(1))])[1]);
                                                    else
                                                        g_max = Core.Int64(1);
                                                    end
                                                    if Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))][Core.Int64(g_max):Core.Int64(1):Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))]))])) > Core.Int64(0)
                                                        if !(Base.haskey(stepping_transaction_Dict, "testing_PickStock_ticker_symbol"))
                                                            stepping_transaction_Dict["testing_PickStock_ticker_symbol"] = Base.Dict{Core.String, Core.Any}();
                                                        end
                                                        if Base.haskey(stepping_transaction_Dict, "testing_PickStock_ticker_symbol") && Base.isa(stepping_transaction_Dict["testing_PickStock_ticker_symbol"], Base.Dict)
                                                            stepping_transaction_Dict["testing_PickStock_ticker_symbol"]["Short_Selling"] = PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))][Core.Int64(g_max):Core.Int64(1):Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))]))];
                                                        end
                                                    end
                                                end
                                                # PickStock_ticker_symbol_Array_testing_data_Long_Position = Core.nothing;  # 釋放内存;
                                                # PickStock_ticker_symbol_Array_testing_data_Short_Selling = Core.nothing;  # 釋放内存;

                                                if Base.haskey(stepping_transaction_Dict, "testing_transaction")

                                                    # stepping_transaction_Dict["training_data"] = trainingData;
                                                    # stepping_transaction_Dict["training_MarketTiming_Parameter"] = MarketTiming_Parameter_Dict;
                                                    # stepping_transaction_Dict["training_PickStock_Parameter"] = PickStock_Parameter_Dict;
                                                    # stepping_transaction_Dict["training_PickStock_ticker_symbol"] = PickStock_ticker_symbol_Array;
                                                    # stepping_transaction_Dict["training_SizePosition_Parameter"] = SizePosition_Parameter_Array;

                                                    # stepping_transaction_Dict["testing_data"] = testingData;

                                                    # if Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))][Core.Int64(1):Core.Int64(1):Core.Int64(Base.findmin([Core.Int64(PickStock_Parameter_Dict["Long_Position"][2]), Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))]))])[1])])) > Core.Int64(0) || Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))][Core.Int64(Base.findmax([Core.Int64(1), Core.Int64(Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))])) - Core.Int64(PickStock_Parameter_Dict["Short_Selling"][2]) + Core.Int64(1))])[1]):Core.Int64(1):Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))]))])) > Core.Int64(0)
                                                    #     stepping_transaction_Dict["testing_PickStock_ticker_symbol"] = Base.Dict{Core.String, Core.Any}();
                                                    #     if Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))][Core.Int64(1):Core.Int64(1):Core.Int64(Base.findmin([Core.Int64(PickStock_Parameter_Dict["Long_Position"][2]), Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))]))])[1])])) > Core.Int64(0)
                                                    #         stepping_transaction_Dict["testing_PickStock_ticker_symbol"]["Long_Position"] = PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))][Core.Int64(1):Core.Int64(1):Core.Int64(Base.findmin([Core.Int64(PickStock_Parameter_Dict["Long_Position"][2]), Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Long_Position))]))])[1])];
                                                    #     end
                                                    #     if Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))][Core.Int64(Base.findmax([Core.Int64(1), Core.Int64(Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))])) - Core.Int64(PickStock_Parameter_Dict["Short_Selling"][2]) + Core.Int64(1))])[1]):Core.Int64(1):Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))]))])) > Core.Int64(0)
                                                    #         stepping_transaction_Dict["testing_PickStock_ticker_symbol"]["Short_Selling"] = PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))][Core.Int64(Base.findmax([Core.Int64(1), Core.Int64(Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))])) - Core.Int64(PickStock_Parameter_Dict["Short_Selling"][2]) + Core.Int64(1))])[1]):Core.Int64(1):Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling[Core.Int64(Base.length(PickStock_ticker_symbol_Array_testing_data_Short_Selling))]))];
                                                    #     end
                                                    # end
                                                    # PickStock_ticker_symbol_Array_testing_data_Long_Position = Core.nothing;  # 釋放内存;
                                                    # PickStock_ticker_symbol_Array_testing_data_Short_Selling = Core.nothing;  # 釋放内存;

                                                    Base.push!(stepping_sequence_Array, stepping_transaction_Dict);  # 使用 push! 函數在數組末尾追加推入新元;
                                                    # stepping_transaction_Dict = Core.nothing;  # 釋放内存;
                                                    # testingData = Core.nothing;  # 釋放内存;
                                                end
                                            end
                                        end
                                    end

                                    PickStock_ticker_symbol_Array_testing_data_Long_Position = Core.nothing;  # 釋放内存;
                                    PickStock_ticker_symbol_Array_testing_data_Short_Selling = Core.nothing;  # 釋放内存;

                                    # # 交易信息序列的空值，刪除未曾交易過的股票數據;
                                    # testing_data_transaction_sequence_Dict_2 = Base.Dict{Core.String, Core.Any}(key => value for (key, value) in testing_data_transaction_sequence_Dict);  # 使用 Julia 字典（Dict）的推導式，創建副本;
                                    # for (key, value) in testing_data_transaction_sequence_Dict_2
                                    #     if Base.isa(value, Base.Dict)
                                    #         if (Base.haskey(value, "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position_profit_date_transaction"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position_profit_date_transaction"])) === Core.Int64(0)) && (Base.haskey(value, "Long_Position_price_amplitude_date_transaction") && (Base.typeof(value["Long_Position_price_amplitude_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position_price_amplitude_date_transaction"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position_price_amplitude_date_transaction"])) === Core.Int64(0)) && (Base.haskey(value, "Long_Position_volume_turnover_date_transaction") && (Base.typeof(value["Long_Position_volume_turnover_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position_volume_turnover_date_transaction"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position_volume_turnover_date_transaction"])) === Core.Int64(0)) && (Base.haskey(value, "Long_Position_date_transaction_between") && (Base.typeof(value["Long_Position_date_transaction_between"]) <: Core.Array || Base.typeof(value["Long_Position_date_transaction_between"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position_date_transaction_between"])) === Core.Int64(0)) && (Base.haskey(value, "Long_Position_date_transaction") && (Base.typeof(value["Long_Position_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position_date_transaction"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position_date_transaction"])) === Core.Int64(0)) && (Base.haskey(value, "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling_profit_date_transaction"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling_profit_date_transaction"])) === Core.Int64(0)) && (Base.haskey(value, "Short_Selling_price_amplitude_date_transaction") && (Base.typeof(value["Short_Selling_price_amplitude_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling_price_amplitude_date_transaction"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling_price_amplitude_date_transaction"])) === Core.Int64(0)) && (Base.haskey(value, "Short_Selling_volume_turnover_date_transaction") && (Base.typeof(value["Short_Selling_volume_turnover_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling_volume_turnover_date_transaction"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling_volume_turnover_date_transaction"])) === Core.Int64(0)) && (Base.haskey(value, "Short_Selling_date_transaction_between") && (Base.typeof(value["Short_Selling_date_transaction_between"]) <: Core.Array || Base.typeof(value["Short_Selling_date_transaction_between"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling_date_transaction_between"])) === Core.Int64(0)) && (Base.haskey(value, "Short_Selling_date_transaction") && (Base.typeof(value["Short_Selling_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling_date_transaction"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling_date_transaction"])) === Core.Int64(0)) && (Base.haskey(value, "revenue_and_expenditure_records_date_transaction") && (Base.typeof(value["revenue_and_expenditure_records_date_transaction"]) <: Core.Array || Base.typeof(value["revenue_and_expenditure_records_date_transaction"]) <: Base.Vector) && Core.Int64(Base.length(value["revenue_and_expenditure_records_date_transaction"])) === Core.Int64(0))
                                    #             Base.delete!(testing_data_transaction_sequence_Dict, key);  # 刪除：testing_data_transaction_sequence_Dict 字典（Dict）中的鍵值對：key:value ;
                                    #         end
                                    #     end
                                    # end
                                    # testing_data_transaction_sequence_Dict_2 = Core.nothing;  # 釋放内存;

                                    # # 交易信息序列匯總求和;
                                    # for (key, value) in testing_data_transaction_sequence_Dict
                                    #     if Base.isa(value, Base.Dict)

                                    #         # 交易信息序列數據（融資做多 buying long）的匯總求和;
                                    #         testing_data_transaction_sequence_Dict[key]["Long_Position_profit_total"] = Core.Float64(0.0);  # 每兩次對衝交易利潤，纍加總計;
                                    #         testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive"] = Core.Float64(0.0);  # 每兩次對衝交易收益纍加總計;
                                    #         testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative"] = Core.Float64(0.0);  # 每兩次對衝交易損失纍加總計;
                                    #         testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive_probability"] = Core.Float64(0.0);  # 每兩次對衝交易正利潤概率;
                                    #         testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative_probability"] = Core.Float64(0.0);  # 每兩次對衝交易負利潤概率;
                                    #         testing_data_transaction_sequence_Dict[key]["Long_Position_average_price_amplitude_date_transaction"] = Core.Float64(0.0);  # 兩次對衝交易日成交價振幅平方和，均值;
                                    #         testing_data_transaction_sequence_Dict[key]["Long_Position_average_volume_turnover_date_transaction"] = Core.Float64(0.0);  # 兩次對衝交易日成交量（換手率）均值;
                                    #         testing_data_transaction_sequence_Dict[key]["Long_Position_average_date_transaction_between"] = Core.Float64(0.0);  # 兩次對衝交易間隔日長，均值;
                                    #         testing_data_transaction_sequence_Dict[key]["y_Long_Position"] = Core.Float64(0.0);  # 優化目標變量，做多（Long Position），每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    #         if investment_method === "Long_Position_and_Short_Selling" || investment_method === "Long_Position"

                                    #             if (Base.haskey(value, "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position_profit_date_transaction"]) <: Base.Vector))
                                    #                 # println(value["Long_Position_profit_date_transaction"]);
                                    #                 if Core.Int64(Base.length(value["Long_Position_profit_date_transaction"])) > Core.Int64(0)
                                    #                     testing_data_transaction_sequence_Dict[key]["Long_Position_profit_total"] = Core.Float64(Base.sum([Core.Float64(value["Long_Position_profit_date_transaction"][i]) for i in 1:Base.length(value["Long_Position_profit_date_transaction"])]));  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                    #                 end
                                    #             end

                                    #             if (Base.haskey(value, "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position_profit_date_transaction"]) <: Base.Vector))
                                    #                 # println(value["Long_Position_profit_date_transaction"]);
                                    #                 if Core.Int64(Base.length(value["Long_Position_profit_date_transaction"])) > Core.Int64(0)
                                    #                     if Core.Int64(Base.length([(Core.Float64(value["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(value["Long_Position_profit_date_transaction"][i]) : Core.Float64(0.0) for i in 1:Base.length(value["Long_Position_profit_date_transaction"])])) > Core.Int64(0)
                                    #                         # testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive"] = Core.Float64(Base.sum([if Core.Float64(value["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0) Core.Float64(value["Long_Position_profit_date_transaction"][i]) else Core.Float64(0.0) end for i in 1:Base.length(value["Long_Position_profit_date_transaction"])]));
                                    #                         testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive"] = Core.Float64(Base.sum([(Core.Float64(value["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(value["Long_Position_profit_date_transaction"][i]) : Core.Float64(0.0) for i in 1:Base.length(value["Long_Position_profit_date_transaction"])]));
                                    #                     end
                                    #                     if Core.Int64(Base.length([(Core.Float64(value["Long_Position_profit_date_transaction"][i]) < Core.Float64(0.0)) ? Core.Float64(value["Long_Position_profit_date_transaction"][i]) : Core.Float64(0.0) for i in 1:Base.length(value["Long_Position_profit_date_transaction"])])) > Core.Int64(0)
                                    #                         # testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative"] = Core.Float64(Base.sum([if Core.Float64(value["Long_Position_profit_date_transaction"][i]) < Core.Float64(0.0) Core.Float64(value["Long_Position_profit_date_transaction"][i]) else Core.Float64(0.0) end for i in 1:Base.length(value["Long_Position_profit_date_transaction"])]));
                                    #                         testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative"] = Core.Float64(Base.sum([(Core.Float64(value["Long_Position_profit_date_transaction"][i]) < Core.Float64(0.0)) ? Core.Float64(value["Long_Position_profit_date_transaction"][i]) : Core.Float64(0.0) for i in 1:Base.length(value["Long_Position_profit_date_transaction"])]));
                                    #                     end

                                    #                     # testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive"] = Core.Float64(0.0);  # 交易規則正利潤纍計;
                                    #                     # testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative"] = Core.Float64(0.0);  # 交易規則負利潤纍計;
                                    #                     # for i = 1:Base.length(value["Long_Position_profit_date_transaction"])
                                    #                     #     if Core.Int64(value["Long_Position_profit_date_transaction"][i]) > Core.Float64(0)
                                    #                     #         testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive"] = Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive"] + value["Long_Position_profit_date_transaction"][i]);
                                    #                     #     elseif Core.Int64(value["Long_Position_profit_date_transaction"][i]) < Core.Float64(0)
                                    #                     #         testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative"] = Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative"] + value["Long_Position_profit_date_transaction"][i]);
                                    #                     #     else
                                    #                     #     end
                                    #                     # end
                                    #                 end
                                    #             end

                                    #             if (Base.haskey(value, "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position_profit_date_transaction"]) <: Base.Vector))
                                    #                 # println(value["Long_Position_profit_date_transaction"]);
                                    #                 if Core.Int64(Base.length(value["Long_Position_profit_date_transaction"])) > Core.Int64(0)
                                    #                     # testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive_probability"] = Core.Float64(Core.Int64(Base.sum([if Core.Float64(value["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Long_Position_profit_date_transaction"])])) / Core.Int64(Base.length(value["Long_Position_profit_date_transaction"])));
                                    #                     testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive_probability"] = Core.Float64(Core.Int64(Base.sum([(Core.Float64(value["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Long_Position_profit_date_transaction"])])) / Core.Int64(Base.length(value["Long_Position_profit_date_transaction"])));
                                    #                     # testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative_probability"] = Core.Float64(Core.Int64(Base.sum([if Core.Float64(value["Long_Position_profit_date_transaction"][i]) < Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Long_Position_profit_date_transaction"])])) / Core.Int64(Base.length(value["Long_Position_profit_date_transaction"])));
                                    #                     testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative_probability"] = Core.Float64(Core.Int64(Base.sum([(Core.Float64(value["Long_Position_profit_date_transaction"][i]) < Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Long_Position_profit_date_transaction"])])) / Core.Int64(Base.length(value["Long_Position_profit_date_transaction"])));

                                    #                     # testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive_probability"] = Core.Int64(0);  # Core.Float64(0.0);  # 交易規則正利潤頻率;
                                    #                     # testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative_probability"] = Core.Int64(0);  # Core.Float64(0.0);  # 交易規則負利潤頻率;
                                    #                     # for i = 1:Base.length(value["Long_Position_profit_date_transaction"])
                                    #                     #     if Core.Float64(value["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0)
                                    #                     #         testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive_probability"] = Core.Int64(Core.Int64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive_probability"]) + Core.Int64(1));
                                    #                     #     elseif Core.Float64(value["Long_Position_profit_date_transaction"][i]) < Core.Float64(0.0)
                                    #                     #         testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative_probability"] = Core.Int64(Core.Int64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative_probability"]) + Core.Int64(1));
                                    #                     #     else
                                    #                     #     end
                                    #                     # end
                                    #                     # if Core.Int64(Base.length(value["Long_Position_profit_date_transaction"])) > Core.Int64(0)
                                    #                     #     testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive_probability"] = Core.Float64(Core.Int64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive_probability"]) / Core.Int64(Base.length(value["Long_Position_profit_date_transaction"])));
                                    #                     #     testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative_probability"] = Core.Float64(Core.Int64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative_probability"]) / Core.Int64(Base.length(value["Long_Position_profit_date_transaction"])));
                                    #                     # end
                                    #                 end
                                    #             end

                                    #             # # y = Core.Float64(y_Positive_Long_Position * y_P_Positive_Long_Position);  # 每兩次對衝交易正利潤 × 頻率，纍加總計;
                                    #             # # y = Core.Float64(y_Negative_Long_Position * y_P_Negative_Long_Position);  # 每兩次對衝交易負利潤 × 頻率，纍加總計;
                                    #             # y = Core.Float64(y_Positive_Long_Position * y_P_Positive_Long_Position) - Core.Float64(y_Negative_Long_Position * y_P_Negative_Long_Position);

                                    #             if (Base.haskey(value, "Long_Position_price_amplitude_date_transaction") && (Base.typeof(value["Long_Position_price_amplitude_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position_price_amplitude_date_transaction"]) <: Base.Vector))
                                    #                 # println(value["Long_Position_price_amplitude_date_transaction"]);
                                    #                 if Core.Int64(Base.length(value["Long_Position_price_amplitude_date_transaction"])) > Core.Int64(0)
                                    #                     testing_data_transaction_sequence_Dict[key]["Long_Position_average_price_amplitude_date_transaction"] = Core.Float64(Statistics.mean(value["Long_Position_price_amplitude_date_transaction"]));  # amplitude_rate;
                                    #                 end
                                    #             end

                                    #             if (Base.haskey(value, "Long_Position_volume_turnover_date_transaction") && (Base.typeof(value["Long_Position_volume_turnover_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position_volume_turnover_date_transaction"]) <: Base.Vector))
                                    #                 # println(value["Long_Position_volume_turnover_date_transaction"]);
                                    #                 if Core.Int64(Base.length(value["Long_Position_volume_turnover_date_transaction"])) > Core.Int64(0)
                                    #                     testing_data_transaction_sequence_Dict[key]["Long_Position_average_volume_turnover_date_transaction"] = Core.Float64(Statistics.mean(value["Long_Position_volume_turnover_date_transaction"]));  # turnover_volume; turnover_rate;
                                    #                 end
                                    #             end

                                    #             if (Base.haskey(value, "Long_Position_date_transaction_between") && (Base.typeof(value["Long_Position_date_transaction_between"]) <: Core.Array || Base.typeof(value["Long_Position_date_transaction_between"]) <: Base.Vector))
                                    #                 # println(value["Long_Position_date_transaction_between"]);
                                    #                 if Core.Int64(Base.length(value["Long_Position_date_transaction_between"])) > Core.Int64(0)
                                    #                     testing_data_transaction_sequence_Dict[key]["Long_Position_average_date_transaction_between"] = Core.Float64(Statistics.mean(value["Long_Position_date_transaction_between"]));  # Between two date_transaction;
                                    #                 end
                                    #             end

                                    #             weight_Long_Position = Core.Array{Core.Float64, 1}();
                                    #             if (Base.haskey(value, "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position_profit_date_transaction"]) <: Base.Vector))
                                    #                 # println(value["Long_Position_profit_date_transaction"]);
                                    #                 if Core.Int64(Base.length(value["Long_Position_profit_date_transaction"])) > Core.Int64(0)
                                    #                     if Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive_probability"]) > Core.Float64(0.0) && Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative_probability"]) > Core.Float64(0.0)
                                    #                         weight_Long_Position = [(Core.Float64(value["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive_probability"]) : Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative_probability"]) for i in 1:Base.length(value["Long_Position_profit_date_transaction"])];
                                    #                     elseif Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive_probability"]) > Core.Float64(0.0) && Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative_probability"]) <= Core.Float64(0.0)
                                    #                         weight_Long_Position = [(Core.Float64(value["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive_probability"]) : Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative_probability"]) for i in 1:Base.length(value["Long_Position_profit_date_transaction"])];
                                    #                     elseif Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive_probability"]) <= Core.Float64(0.0) && Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative_probability"]) > Core.Float64(0.0)
                                    #                         weight_Long_Position = [(Core.Float64(value["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive_probability"]) : Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative_probability"]) for i in 1:Base.length(value["Long_Position_profit_date_transaction"])];
                                    #                     else
                                    #                         weight_Long_Position = [Core.Float64(1.0) for i in 1:Base.length(value["Long_Position_profit_date_transaction"])];
                                    #                     end
                                    #                 end
                                    #             end
                                    #             # if (Base.haskey(value, "Long_Position_date_transaction_between") && (Base.typeof(value["Long_Position_date_transaction_between"]) <: Core.Array || Base.typeof(value["Long_Position_date_transaction_between"]) <: Base.Vector))
                                    #             #     # println(value["Long_Position_date_transaction_between"]);
                                    #             #     if Core.Int64(Base.length(value["Long_Position_date_transaction_between"])) > Core.Int64(0)
                                    #             #         weight_Long_Position = [Core.Float64(Core.Int64(1) / Core.Int64(value["Long_Position_date_transaction_between"][i])) for i in 1:Base.length(value["Long_Position_date_transaction_between"])];  # 每兩次對衝交易間隔日長的倒數;
                                    #             #     end
                                    #             # end
                                    #             # if (Base.haskey(value, "Long_Position_price_amplitude_date_transaction") && (Base.typeof(value["Long_Position_price_amplitude_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position_price_amplitude_date_transaction"]) <: Base.Vector))
                                    #             #     # println(value["Long_Position_price_amplitude_date_transaction"]);
                                    #             #     if Core.Int64(Base.length(value["Long_Position_price_amplitude_date_transaction"])) > Core.Int64(0)
                                    #             #         weight_Long_Position = [Core.Float64(Core.Int64(1) / Core.Float64(value["Long_Position_price_amplitude_date_transaction"][i])) for i in 1:Base.length(value["Long_Position_price_amplitude_date_transaction"])];  # 兩次對衝交易日成交價振幅平方和的倒數;
                                    #             #     end
                                    #             # end
                                    #             # if (Base.haskey(value, "Long_Position_volume_turnover_date_transaction") && (Base.typeof(value["Long_Position_volume_turnover_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position_volume_turnover_date_transaction"]) <: Base.Vector))
                                    #             #     # println(value["Long_Position_volume_turnover_date_transaction"]);
                                    #             #     if Core.Int64(Base.length(value["Long_Position_volume_turnover_date_transaction"])) > Core.Int64(0)
                                    #             #         weight_Long_Position = [Core.Float64(value["Long_Position_volume_turnover_date_transaction"][i]) for i in 1:Base.length(value["Long_Position_volume_turnover_date_transaction"])];  # 兩次對衝交易日成交量（換手率）均值;
                                    #             #     end
                                    #             # end

                                    #             if (Base.haskey(value, "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position_profit_date_transaction"]) <: Base.Vector))
                                    #                 # println(value["Long_Position_profit_date_transaction"]);
                                    #                 if Core.Int64(Base.length(value["Long_Position_profit_date_transaction"])) > Core.Int64(0)
                                    #                     if Core.Int64(Base.length(weight_Long_Position)) > Core.Int64(0)
                                    #                         testing_data_transaction_sequence_Dict[key]["y_Long_Position"] = Core.Float64(Base.sum([Core.Float64(Core.Float64(weight_Long_Position[i]) * Core.Float64(value["Long_Position_profit_date_transaction"][i])) for i in 1:Base.length(value["Long_Position_profit_date_transaction"])]));  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    #                         # testing_data_transaction_sequence_Dict[key]["y_Long_Position"] = Core.Float64(0.0);  # 每兩次對衝交易利潤 × 權重，纍加總計;
                                    #                         # for i = 1:Base.length(value["Long_Position_profit_date_transaction"])
                                    #                         #     testing_data_transaction_sequence_Dict[key]["y_Long_Position"] = Core.Float64(testing_data_transaction_sequence_Dict[key]["y_Long_Position"]) + Core.Float64(weight_Long_Position[i] * value["Long_Position_profit_date_transaction"][i]);
                                    #                         # end
                                    #                     elseif Core.Int64(Base.length(weight_Long_Position)) <= Core.Int64(0)
                                    #                         testing_data_transaction_sequence_Dict[key]["y_Long_Position"] = Core.Float64(Base.sum([Core.Float64(value["Long_Position_profit_date_transaction"][i]) for i in 1:Base.length(value["Long_Position_profit_date_transaction"])]));  # 每兩次對衝交易利潤，加權纍加總計;
                                    #                         # testing_data_transaction_sequence_Dict[key]["y_Long_Position"] = Core.Float64(0.0);  # 每兩次對衝交易利潤，纍加總計;
                                    #                         # for i = 1:Base.length(value["Long_Position_profit_date_transaction"])
                                    #                         #     testing_data_transaction_sequence_Dict[key]["y_Long_Position"] = Core.Float64(testing_data_transaction_sequence_Dict[key]["y_Long_Position"]) + Core.Float64(value["Long_Position_profit_date_transaction"][i]);
                                    #                         # end
                                    #                     else
                                    #                     end
                                    #                 end
                                    #             end

                                    #             # 優化目標變量合入風險因素;
                                    #             # if Core.Float64(y_P_Negative_Long_Position) === Core.Float64(0.0)
                                    #             #     y_Long_Position = Core.Float64(y_Long_Position * y_P_Positive_Long_Position);  # 每次交易利潤 × 頻率 × 權重，加權纍加總計，然後再 × 正利潤概率，叠加不確定風險效果;
                                    #             # else
                                    #             #     y_Long_Position = Core.Float64(y_Long_Position * Core.Float64(y_P_Positive_Long_Position / y_P_Negative_Long_Position));  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計，然後再 × 正利潤概率，叠加不確定風險效果;
                                    #             # end
                                    #         end

                                    #         # 交易信息序列數據（融券做空 short selling）的匯總求和;
                                    #         testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_total"] = Core.Float64(0.0);  # 每兩次對衝交易利潤，纍加總計;
                                    #         testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive"] = Core.Float64(0.0);  # 每兩次對衝交易收益纍加總計;
                                    #         testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative"] = Core.Float64(0.0);  # 每兩次對衝交易損失纍加總計;
                                    #         testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive_probability"] = Core.Float64(0.0);  # 每兩次對衝交易正利潤概率;
                                    #         testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative_probability"] = Core.Float64(0.0);  # 每兩次對衝交易負利潤概率;
                                    #         testing_data_transaction_sequence_Dict[key]["Short_Selling_average_price_amplitude_date_transaction"] = Core.Float64(0.0);  # 兩次對衝交易日成交價振幅平方和，均值;
                                    #         testing_data_transaction_sequence_Dict[key]["Short_Selling_average_volume_turnover_date_transaction"] = Core.Float64(0.0);  # 兩次對衝交易日成交量（換手率）均值;
                                    #         testing_data_transaction_sequence_Dict[key]["Short_Selling_average_date_transaction_between"] = Core.Float64(0.0);  # 兩次對衝交易間隔日長，均值;
                                    #         testing_data_transaction_sequence_Dict[key]["y_Short_Selling"] = Core.Float64(0.0);  # 優化目標變量，做空（Short Selling），每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    #         if investment_method === "Long_Position_and_Short_Selling" || investment_method === "Short_Selling"

                                    #             if (Base.haskey(value, "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling_profit_date_transaction"]) <: Base.Vector))
                                    #                 # println(value["Short_Selling_profit_date_transaction"]);
                                    #                 if Core.Int64(Base.length(value["Short_Selling_profit_date_transaction"])) > Core.Int64(0)
                                    #                     testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_total"] = Core.Float64(Base.sum([Core.Float64(value["Short_Selling_profit_date_transaction"][i]) for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])]));  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                                    #                 end
                                    #             end

                                    #             if (Base.haskey(value, "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling_profit_date_transaction"]) <: Base.Vector))
                                    #                 # println(value["Short_Selling_profit_date_transaction"]);
                                    #                 if Core.Int64(Base.length(value["Short_Selling_profit_date_transaction"])) > Core.Int64(0)
                                    #                     if Core.Int64(Base.length([(Core.Float64(value["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(value["Short_Selling_profit_date_transaction"][i]) : Core.Float64(0.0) for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])])) > Core.Int64(0)
                                    #                         # testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive"] = Core.Float64(Base.sum([if Core.Float64(value["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0) Core.Float64(value["Short_Selling_profit_date_transaction"][i]) else Core.Float64(0.0) end for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])]));
                                    #                         testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive"] = Core.Float64(Base.sum([(Core.Float64(value["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(value["Short_Selling_profit_date_transaction"][i]) : Core.Float64(0.0) for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])]));
                                    #                     end
                                    #                     if Core.Int64(Base.length([(Core.Float64(value["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0.0)) ? Core.Float64(value["Short_Selling_profit_date_transaction"][i]) : Core.Float64(0.0) for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])])) > Core.Int64(0)
                                    #                         # testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative"] = Core.Float64(Base.sum([if Core.Float64(value["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0.0) Core.Float64(value["Short_Selling_profit_date_transaction"][i]) else Core.Float64(0.0) end for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])]));
                                    #                         testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative"] = Core.Float64(Base.sum([(Core.Float64(value["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0.0)) ? Core.Float64(value["Short_Selling_profit_date_transaction"][i]) : Core.Float64(0.0) for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])]));
                                    #                     end

                                    #                     # testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive"] = Core.Float64(0.0);  # 交易規則正利潤纍計;
                                    #                     # testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative"] = Core.Float64(0.0);  # 交易規則負利潤纍計;
                                    #                     # for i = 1:Base.length(value["Short_Selling_profit_date_transaction"])
                                    #                     #     if Core.Int64(value["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0)
                                    #                     #         testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive"] = Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive"] + value["Short_Selling_profit_date_transaction"][i]);
                                    #                     #     elseif Core.Int64(value["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0)
                                    #                     #         testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative"] = Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative"] + value["Short_Selling_profit_date_transaction"][i]);
                                    #                     #     else
                                    #                     #     end
                                    #                     # end
                                    #                 end
                                    #             end

                                    #             if (Base.haskey(value, "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling_profit_date_transaction"]) <: Base.Vector))
                                    #                 # println(value["Short_Selling_profit_date_transaction"]);
                                    #                 if Core.Int64(Base.length(value["Short_Selling_profit_date_transaction"])) > Core.Int64(0)
                                    #                     # testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive_probability"] = Core.Float64(Core.Int64(Base.sum([if Core.Float64(value["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])])) / Core.Int64(Base.length(value["Short_Selling_profit_date_transaction"])));
                                    #                     testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive_probability"] = Core.Float64(Core.Int64(Base.sum([(Core.Float64(value["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])])) / Core.Int64(Base.length(value["Short_Selling_profit_date_transaction"])));
                                    #                     # testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative_probability"] = Core.Float64(Core.Int64(Base.sum([if Core.Float64(value["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])])) / Core.Int64(Base.length(value["Short_Selling_profit_date_transaction"])));
                                    #                     testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative_probability"] = Core.Float64(Core.Int64(Base.sum([(Core.Float64(value["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])])) / Core.Int64(Base.length(value["Short_Selling_profit_date_transaction"])));

                                    #                     # testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive_probability"] = Core.Int64(0);  # Core.Float64(0.0);  # 交易規則正利潤頻率;
                                    #                     # testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative_probability"] = Core.Int64(0);  # Core.Float64(0.0);  # 交易規則負利潤頻率;
                                    #                     # for i = 1:Base.length(value["Short_Selling_profit_date_transaction"])
                                    #                     #     if Core.Float64(value["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0)
                                    #                     #         testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive_probability"] = Core.Int64(Core.Int64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive_probability"]) + Core.Int64(1));
                                    #                     #     elseif Core.Float64(value["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0.0)
                                    #                     #         testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative_probability"] = Core.Int64(Core.Int64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative_probability"]) + Core.Int64(1));
                                    #                     #     else
                                    #                     #     end
                                    #                     # end
                                    #                     # if Core.Int64(Base.length(value["Short_Selling_profit_date_transaction"])) > Core.Int64(0)
                                    #                     #     testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive_probability"] = Core.Float64(Core.Int64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive_probability"]) / Core.Int64(Base.length(value["Short_Selling_profit_date_transaction"])));
                                    #                     #     testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative_probability"] = Core.Float64(Core.Int64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative_probability"]) / Core.Int64(Base.length(value["Short_Selling_profit_date_transaction"])));
                                    #                     # end
                                    #                 end
                                    #             end

                                    #             # # y = Core.Float64(y_Positive_Short_Selling * y_P_Positive_Short_Selling);  # 每兩次對衝交易正利潤 × 頻率，纍加總計;
                                    #             # # y = Core.Float64(y_Negative_Short_Selling * y_P_Negative_Short_Selling);  # 每兩次對衝交易負利潤 × 頻率，纍加總計;
                                    #             # y = Core.Float64(y_Positive_Short_Selling * y_P_Positive_Short_Selling) - Core.Float64(y_Negative_Short_Selling * y_P_Negative_Short_Selling);

                                    #             if (Base.haskey(value, "Short_Selling_price_amplitude_date_transaction") && (Base.typeof(value["Short_Selling_price_amplitude_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling_price_amplitude_date_transaction"]) <: Base.Vector))
                                    #                 # println(value["Short_Selling_price_amplitude_date_transaction"]);
                                    #                 if Core.Int64(Base.length(value["Short_Selling_price_amplitude_date_transaction"])) > Core.Int64(0)
                                    #                     testing_data_transaction_sequence_Dict[key]["Short_Selling_average_price_amplitude_date_transaction"] = Core.Float64(Statistics.mean(value["Short_Selling_price_amplitude_date_transaction"]));  # amplitude_rate;
                                    #                 end
                                    #             end

                                    #             if (Base.haskey(value, "Short_Selling_volume_turnover_date_transaction") && (Base.typeof(value["Short_Selling_volume_turnover_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling_volume_turnover_date_transaction"]) <: Base.Vector))
                                    #                 # println(value["Short_Selling_volume_turnover_date_transaction"]);
                                    #                 if Core.Int64(Base.length(value["Short_Selling_volume_turnover_date_transaction"])) > Core.Int64(0)
                                    #                     testing_data_transaction_sequence_Dict[key]["Short_Selling_average_volume_turnover_date_transaction"] = Core.Float64(Statistics.mean(value["Short_Selling_volume_turnover_date_transaction"]));  # turnover_volume; turnover_rate;
                                    #                 end
                                    #             end

                                    #             if (Base.haskey(value, "Short_Selling_date_transaction_between") && (Base.typeof(value["Short_Selling_date_transaction_between"]) <: Core.Array || Base.typeof(value["Short_Selling_date_transaction_between"]) <: Base.Vector))
                                    #                 # println(value["Short_Selling_date_transaction_between"]);
                                    #                 if Core.Int64(Base.length(value["Short_Selling_date_transaction_between"])) > Core.Int64(0)
                                    #                     testing_data_transaction_sequence_Dict[key]["Short_Selling_average_date_transaction_between"] = Core.Float64(Statistics.mean(value["Short_Selling_date_transaction_between"]));  # Between two date_transaction;
                                    #                 end
                                    #             end

                                    #             weight_Short_Selling = Core.Array{Core.Float64, 1}();
                                    #             if (Base.haskey(value, "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling_profit_date_transaction"]) <: Base.Vector))
                                    #                 # println(value["Short_Selling_profit_date_transaction"]);
                                    #                 if Core.Int64(Base.length(value["Short_Selling_profit_date_transaction"])) > Core.Int64(0)
                                    #                     if Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive_probability"]) > Core.Float64(0.0) && Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative_probability"]) > Core.Float64(0.0)
                                    #                         weight_Short_Selling = [(Core.Float64(value["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive_probability"]) : Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative_probability"]) for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])];
                                    #                     elseif Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive_probability"]) > Core.Float64(0.0) && Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative_probability"]) <= Core.Float64(0.0)
                                    #                         weight_Short_Selling = [(Core.Float64(value["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive_probability"]) : Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative_probability"]) for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])];
                                    #                     elseif Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive_probability"]) <= Core.Float64(0.0) && Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative_probability"]) > Core.Float64(0.0)
                                    #                         weight_Short_Selling = [(Core.Float64(value["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive_probability"]) : Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative_probability"]) for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])];
                                    #                     else
                                    #                         weight_Short_Selling = [Core.Float64(1.0) for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])];
                                    #                     end
                                    #                 end
                                    #             end
                                    #             # if (Base.haskey(value, "Short_Selling_date_transaction_between") && (Base.typeof(value["Short_Selling_date_transaction_between"]) <: Core.Array || Base.typeof(value["Short_Selling_date_transaction_between"]) <: Base.Vector))
                                    #             #     # println(value["Short_Selling_date_transaction_between"]);
                                    #             #     if Core.Int64(Base.length(value["Short_Selling_date_transaction_between"])) > Core.Int64(0)
                                    #             #         weight_Short_Selling = [Core.Float64(Core.Int64(1) / Core.Int64(value["Short_Selling_date_transaction_between"][i])) for i in 1:Base.length(value["Short_Selling_date_transaction_between"])];  # 每兩次對衝交易間隔日長的倒數;
                                    #             #     end
                                    #             # end
                                    #             # if (Base.haskey(value, "Short_Selling_price_amplitude_date_transaction") && (Base.typeof(value["Short_Selling_price_amplitude_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling_price_amplitude_date_transaction"]) <: Base.Vector))
                                    #             #     # println(value["Short_Selling_price_amplitude_date_transaction"]);
                                    #             #     if Core.Int64(Base.length(value["Short_Selling_price_amplitude_date_transaction"])) > Core.Int64(0)
                                    #             #         weight_Short_Selling = [Core.Float64(Core.Int64(1) / Core.Float64(value["Short_Selling_price_amplitude_date_transaction"][i])) for i in 1:Base.length(value["Short_Selling_price_amplitude_date_transaction"])];  # 兩次對衝交易日成交價振幅平方和的倒數;
                                    #             #     end
                                    #             # end
                                    #             # if (Base.haskey(value, "Short_Selling_volume_turnover_date_transaction") && (Base.typeof(value["Short_Selling_volume_turnover_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling_volume_turnover_date_transaction"]) <: Base.Vector))
                                    #             #     # println(value["Short_Selling_volume_turnover_date_transaction"]);
                                    #             #     if Core.Int64(Base.length(value["Short_Selling_volume_turnover_date_transaction"])) > Core.Int64(0)
                                    #             #         weight_Short_Selling = [Core.Float64(value["Short_Selling_volume_turnover_date_transaction"][i]) for i in 1:Base.length(value["Short_Selling_volume_turnover_date_transaction"])];  # 兩次對衝交易日成交量（換手率）均值;
                                    #             #     end
                                    #             # end

                                    #             if (Base.haskey(value, "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling_profit_date_transaction"]) <: Base.Vector))
                                    #                 # println(value["Short_Selling_profit_date_transaction"]);
                                    #                 if Core.Int64(Base.length(value["Short_Selling_profit_date_transaction"])) > Core.Int64(0)
                                    #                     if Core.Int64(Base.length(weight_Short_Selling)) > Core.Int64(0)
                                    #                         testing_data_transaction_sequence_Dict[key]["y_Short_Selling"] = Core.Float64(Base.sum([Core.Float64(Core.Float64(weight_Short_Selling[i]) * Core.Float64(value["Short_Selling_profit_date_transaction"][i])) for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])]));  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    #                         # testing_data_transaction_sequence_Dict[key]["y_Short_Selling"] = Core.Float64(0.0);  # 每兩次對衝交易利潤 × 權重，纍加總計;
                                    #                         # for i = 1:Base.length(value["Short_Selling_profit_date_transaction"])
                                    #                         #     testing_data_transaction_sequence_Dict[key]["y_Short_Selling"] = Core.Float64(testing_data_transaction_sequence_Dict[key]["y_Short_Selling"]) + Core.Float64(weight_Short_Selling[i] * value["Short_Selling_profit_date_transaction"][i]);
                                    #                         # end
                                    #                     elseif Core.Int64(Base.length(weight_Short_Selling)) <= Core.Int64(0)
                                    #                         testing_data_transaction_sequence_Dict[key]["y_Short_Selling"] = Core.Float64(Base.sum([Core.Float64(value["Short_Selling_profit_date_transaction"][i]) for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])]));  # 每兩次對衝交易利潤，加權纍加總計;
                                    #                         # testing_data_transaction_sequence_Dict[key]["y_Short_Selling"] = Core.Float64(0.0);  # 每兩次對衝交易利潤，纍加總計;
                                    #                         # for i = 1:Base.length(value["Short_Selling_profit_date_transaction"])
                                    #                         #     testing_data_transaction_sequence_Dict[key]["y_Short_Selling"] = Core.Float64(testing_data_transaction_sequence_Dict[key]["y_Short_Selling"]) + Core.Float64(value["Short_Selling_profit_date_transaction"][i]);
                                    #                         # end
                                    #                     else
                                    #                     end
                                    #                 end
                                    #             end

                                    #             # 優化目標變量合入風險因素;
                                    #             # if Core.Float64(y_P_Negative_Short_Selling) === Core.Float64(0.0)
                                    #             #     y_Short_Selling = Core.Float64(y_Short_Selling * y_P_Positive_Short_Selling);  # 每次交易利潤 × 頻率 × 權重，加權纍加總計，然後再 × 正利潤概率，叠加不確定風險效果;
                                    #             # else
                                    #             #     y_Short_Selling = Core.Float64(y_Short_Selling * Core.Float64(y_P_Positive_Short_Selling / y_P_Negative_Short_Selling));  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計，然後再 × 正利潤概率，叠加不確定風險效果;
                                    #             # end
                                    #         end

                                    #         # 交易信息序列數據（融資做多 buying long）+（融券做空 short selling）的匯總求和;
                                    #         testing_data_transaction_sequence_Dict[key]["profit_total"] = Core.Float64(Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_total"]) + Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_total"]));  # 每兩次對衝交易利潤，纍加總計;
                                    #         testing_data_transaction_sequence_Dict[key]["profit_Positive"] = Core.Float64(Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Positive"]) + Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Positive"]));  # 每兩次對衝交易收益纍加總計;
                                    #         testing_data_transaction_sequence_Dict[key]["profit_Negative"] = Core.Float64(Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_profit_Negative"]) + Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_profit_Negative"]));  # 每兩次對衝交易損失纍加總計;
                                    #         testing_data_transaction_sequence_Dict[key]["profit_Positive_probability"] = Core.Float64(0.0);  # 每兩次對衝交易正利潤概率;
                                    #         testing_data_transaction_sequence_Dict[key]["profit_Negative_probability"] = Core.Float64(0.0);  # 每兩次對衝交易負利潤概率;
                                    #         if ((Base.haskey(value, "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position_profit_date_transaction"]) <: Base.Vector)) && Core.Int64(Base.length(value["Long_Position_profit_date_transaction"])) > Core.Int64(0)) || ((Base.haskey(value, "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling_profit_date_transaction"]) <: Base.Vector)) && Core.Int64(Base.length(value["Short_Selling_profit_date_transaction"])) > Core.Int64(0))
                                    #             y_Positive_count_Long_Position = Core.Int64(0);
                                    #             y_Negative_count_Long_Position = Core.Int64(0);
                                    #             y_Positive_count_Short_Selling = Core.Int64(0);
                                    #             y_Negative_count_Short_Selling = Core.Int64(0);
                                    #             if (Base.haskey(value, "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position_profit_date_transaction"]) <: Base.Vector))
                                    #                 if Core.Int64(Base.length(value["Long_Position_profit_date_transaction"])) > Core.Int64(0)
                                    #                     # y_Positive_count_Long_Position = Core.Int64(Base.sum([if Core.Float64(value["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Long_Position_profit_date_transaction"])]));
                                    #                     y_Positive_count_Long_Position = Core.Int64(Base.sum([(Core.Float64(value["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Long_Position_profit_date_transaction"])]));
                                    #                     # y_Negative_count_Long_Position = Core.Int64(Base.sum([if Core.Float64(value["Long_Position_profit_date_transaction"][i]) < Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Long_Position_profit_date_transaction"])]));
                                    #                     y_Negative_count_Long_Position = Core.Int64(Base.sum([(Core.Float64(value["Long_Position_profit_date_transaction"][i]) < Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Long_Position_profit_date_transaction"])]));
                                    #                 end
                                    #             end
                                    #             if (Base.haskey(value, "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling_profit_date_transaction"]) <: Base.Vector))
                                    #                 if Core.Int64(Base.length(value["Short_Selling_profit_date_transaction"])) > Core.Int64(0)
                                    #                     # y_Positive_count_Short_Selling = Core.Int64(Base.sum([if Core.Float64(value["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])]));
                                    #                     y_Positive_count_Short_Selling = Core.Int64(Base.sum([(Core.Float64(value["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])]));
                                    #                     # y_Negative_count_Short_Selling = Core.Int64(Base.sum([if Core.Float64(value["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])]));
                                    #                     y_Negative_count_Short_Selling = Core.Int64(Base.sum([(Core.Float64(value["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Short_Selling_profit_date_transaction"])]));
                                    #                 end
                                    #             end
                                    #             testing_data_transaction_sequence_Dict[key]["profit_Positive_probability"] = Core.Float64(Core.Int64(Core.Int64(y_Positive_count_Long_Position) + Core.Int64(y_Positive_count_Short_Selling)) / Core.Int64(Core.Int64(Base.length(value["Long_Position_profit_date_transaction"])) + Core.Int64(Base.length(value["Short_Selling_profit_date_transaction"]))));
                                    #             testing_data_transaction_sequence_Dict[key]["profit_Negative_probability"] = Core.Float64(Core.Int64(Core.Int64(y_Negative_count_Long_Position) + Core.Int64(y_Negative_count_Short_Selling)) / Core.Int64(Core.Int64(Base.length(value["Long_Position_profit_date_transaction"])) + Core.Int64(Base.length(value["Short_Selling_profit_date_transaction"]))));
                                    #         end
                                    #         testing_data_transaction_sequence_Dict[key]["average_price_amplitude_date_transaction"] = Core.Float64(Core.Float64(Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_average_price_amplitude_date_transaction"]) + Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_average_price_amplitude_date_transaction"])) / Core.Int64(2));  # 兩次對衝交易日成交價振幅平方和，均值;
                                    #         testing_data_transaction_sequence_Dict[key]["average_volume_turnover_date_transaction"] = Core.Float64(Core.Float64(Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_average_volume_turnover_date_transaction"]) + Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_average_volume_turnover_date_transaction"])) / Core.Int64(2));  # 兩次對衝交易日成交量（換手率）均值;
                                    #         testing_data_transaction_sequence_Dict[key]["average_date_transaction_between"] = Core.Float64(Core.Float64(Core.Float64(testing_data_transaction_sequence_Dict[key]["Long_Position_average_date_transaction_between"]) + Core.Float64(testing_data_transaction_sequence_Dict[key]["Short_Selling_average_date_transaction_between"])) / Core.Int64(2));  # 兩次對衝交易間隔日長，均值，Between two date_transaction;
                                    #         testing_data_transaction_sequence_Dict[key]["y"] = Core.Float64(Core.Float64(testing_data_transaction_sequence_Dict[key]["y_Long_Position"]) + Core.Float64(testing_data_transaction_sequence_Dict[key]["y_Short_Selling"]));  # 優化目標變量，每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    #     end
                                    # end

                                    # # 清洗交易信息序列數據，刪除無意義數據;
                                    # # for (key, value) in testing_data_transaction_sequence_Dict
                                    # #     if Base.isa(value, Base.Dict)
                                    # #         if Base.haskey(value, "Index_date_transaction_Long_Position")
                                    # #             # if Base.typeof(value["Index_date_transaction_Long_Position"]) <: Core.Int || Base.typeof(value["Index_date_transaction_Long_Position"]) <: Core.UInt || Base.typeof(value["Index_date_transaction_Long_Position"]) <: Core.Float64 || Base.typeof(value["Index_date_transaction_Long_Position"]) <: Core.Float64
                                    # #             Base.delete!(testing_data_transaction_sequence_Dict[key], "Index_date_transaction_Long_Position");  # 刪除：testing_data_transaction_sequence_Dict[key] 字典（Dict）中的鍵值對："Index_date_transaction_Long_Position" ;
                                    # #         end
                                    # #         if Base.haskey(value, "y_B_Long_Position")
                                    # #             # if Base.typeof(value["y_B_Long_Position"]) <: Core.Array || Base.typeof(value["y_B_Long_Position"]) <: Base.Vector
                                    # #             Base.delete!(testing_data_transaction_sequence_Dict[key], "y_B_Long_Position");  # 刪除：testing_data_transaction_sequence_Dict[key] 字典（Dict）中的鍵值對："y_B_Long_Position" ;
                                    # #         end
                                    # #         if Base.haskey(value, "Index_date_transaction_Short_Selling")
                                    # #             # if Base.typeof(value["Index_date_transaction_Short_Selling"]) <: Core.Int || Base.typeof(value["Index_date_transaction_Short_Selling"]) <: Core.UInt || Base.typeof(value["Index_date_transaction_Short_Selling"]) <: Core.Float64 || Base.typeof(value["Index_date_transaction_Short_Selling"]) <: Core.Float64
                                    # #             Base.delete!(testing_data_transaction_sequence_Dict[key], "Index_date_transaction_Short_Selling");  # 刪除：testing_data_transaction_sequence_Dict[key] 字典（Dict）中的鍵值對："Index_date_transaction_Short_Selling" ;
                                    # #         end
                                    # #         if Base.haskey(value, "y_B_Short_Selling")
                                    # #             # if Base.typeof(value["y_B_Short_Selling"]) <: Core.Array || Base.typeof(value["y_B_Short_Selling"]) <: Base.Vector
                                    # #             Base.delete!(testing_data_transaction_sequence_Dict[key], "y_B_Short_Selling");  # 刪除：testing_data_transaction_sequence_Dict[key] 字典（Dict）中的鍵值對："y_B_Short_Selling" ;
                                    # #         end
                                    # #     end
                                    # # end
                                    # testing_data_transaction_sequence_Dict_2 = Base.Dict{Core.String, Core.Any}(key => value for (key, value) in testing_data_transaction_sequence_Dict);  # 使用 Julia 字典（Dict）的推導式，創建副本;
                                    # for (key, value) in testing_data_transaction_sequence_Dict_2
                                    #     if Base.isa(value, Base.Dict)
                                    #         if Base.haskey(value, "Index_date_transaction_Long_Position")
                                    #             # if Base.typeof(value["Index_date_transaction_Long_Position"]) <: Core.Int || Base.typeof(value["Index_date_transaction_Long_Position"]) <: Core.UInt || Base.typeof(value["Index_date_transaction_Long_Position"]) <: Core.Float64 || Base.typeof(value["Index_date_transaction_Long_Position"]) <: Core.Float64
                                    #             Base.delete!(testing_data_transaction_sequence_Dict[key], "Index_date_transaction_Long_Position");  # 刪除：testing_data_transaction_sequence_Dict[key] 字典（Dict）中的鍵值對："Index_date_transaction_Long_Position" ;
                                    #         end
                                    #         if Base.haskey(value, "y_B_Long_Position")
                                    #             # if Base.typeof(value["y_B_Long_Position"]) <: Core.Array || Base.typeof(value["y_B_Long_Position"]) <: Base.Vector
                                    #             Base.delete!(testing_data_transaction_sequence_Dict[key], "y_B_Long_Position");  # 刪除：testing_data_transaction_sequence_Dict[key] 字典（Dict）中的鍵值對："y_B_Long_Position" ;
                                    #         end
                                    #         if Base.haskey(value, "Index_date_transaction_Short_Selling")
                                    #             # if Base.typeof(value["Index_date_transaction_Short_Selling"]) <: Core.Int || Base.typeof(value["Index_date_transaction_Short_Selling"]) <: Core.UInt || Base.typeof(value["Index_date_transaction_Short_Selling"]) <: Core.Float64 || Base.typeof(value["Index_date_transaction_Short_Selling"]) <: Core.Float64
                                    #             Base.delete!(testing_data_transaction_sequence_Dict[key], "Index_date_transaction_Short_Selling");  # 刪除：testing_data_transaction_sequence_Dict[key] 字典（Dict）中的鍵值對："Index_date_transaction_Short_Selling" ;
                                    #         end
                                    #         if Base.haskey(value, "y_B_Short_Selling")
                                    #             # if Base.typeof(value["y_B_Short_Selling"]) <: Core.Array || Base.typeof(value["y_B_Short_Selling"]) <: Base.Vector
                                    #             Base.delete!(testing_data_transaction_sequence_Dict[key], "y_B_Short_Selling");  # 刪除：testing_data_transaction_sequence_Dict[key] 字典（Dict）中的鍵值對："y_B_Short_Selling" ;
                                    #         end
                                    #     end
                                    # end
                                    # testing_data_transaction_sequence_Dict_2 = Core.nothing;  # 釋放内存;
                                    # # # 每一股票（ticker symbol）函數返回值;
                                    # # testing_data_transaction_sequence_Dict === Base.Dict{Core.String, Core.Any}(
                                    # #     "ticker_symbol" => Base.Dict{Core.String, Core.Any}(
                                    # #         "y" => y,  # 優化目標變量，每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    # #         "y_Long_Position" => y_Long_Position,  # 優化目標變量，做多（Long Position），每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    # #         "y_Short_Selling" => y_Short_Selling,  # 優化目標變量，做空（Short Selling），每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    # #         "profit_total" => y_total,  # 每兩次對衝交易利潤 × 權重，纍加總計;
                                    # #         "Long_Position_profit_total" => y_total_Long_Position,  # 每兩次對衝交易利潤 × 權重，纍加總計;
                                    # #         "Short_Selling_profit_total" => y_total_Short_Selling,  # 每兩次對衝交易利潤 × 權重，纍加總計;
                                    # #         "profit_Positive" => y_Positive,  # 每兩次對衝交易收益纍加總計;
                                    # #         "Long_Position_profit_Positive" => y_Positive_Long_Position,  # 每兩次對衝交易收益纍加總計;
                                    # #         "Short_Selling_profit_Positive" => y_Positive_Short_Selling,  # 每兩次對衝交易收益纍加總計;
                                    # #         "profit_Positive_probability" => y_P_Positive,  # 每兩次對衝交易正利潤概率;
                                    # #         "Long_Position_profit_Positive_probability" => y_P_Positive_Long_Position,  # 每兩次對衝交易正利潤概率;
                                    # #         "Short_Selling_profit_Positive_probability" => y_P_Positive_Short_Selling,  # 每兩次對衝交易正利潤概率;
                                    # #         "profit_Negative" => y_Negative,  # 每兩次對衝交易損失纍加總計;
                                    # #         "Long_Position_profit_Negative" => y_Negative_Long_Position,  # 每兩次對衝交易損失纍加總計;
                                    # #         "Short_Selling_profit_Negative" => y_Negative_Short_Selling,  # 每兩次對衝交易損失纍加總計;
                                    # #         "profit_Negative_probability" => y_P_Negative,  # 每兩次對衝交易負利潤概率;
                                    # #         "Long_Position_profit_Negative_probability" => y_P_Negative_Long_Position,  # 每兩次對衝交易負利潤概率;
                                    # #         "Short_Selling_profit_Negative_probability" => y_P_Negative_Short_Selling,  # 每兩次對衝交易負利潤概率;
                                    # #         "Long_Position_profit_date_transaction" => y_A_Long_Position,  # 每兩次對衝交易利潤，向量;
                                    # #         "Short_Selling_profit_date_transaction" => y_A_Short_Selling,  # 每兩次對衝交易利潤，向量;
                                    # #         "average_price_amplitude_date_transaction" => y_amplitude,  # 兩次對衝交易日成交價振幅平方和，均值;
                                    # #         "Long_Position_average_price_amplitude_date_transaction" => y_amplitude_Long_Position,  # 兩次對衝交易日成交價振幅平方和，均值;
                                    # #         "Short_Selling_average_price_amplitude_date_transaction" => y_amplitude_Short_Selling,  # 兩次對衝交易日成交價振幅平方和，均值;
                                    # #         "Long_Position_price_amplitude_date_transaction" => y_D_Long_Position,  # 兩次對衝交易日成交價振幅平方和，向量;
                                    # #         "Short_Selling_price_amplitude_date_transaction" => y_D_Short_Selling,  # 兩次對衝交易日成交價振幅平方和，向量;
                                    # #         "average_volume_turnover_date_transaction" => y_turnover,  # 兩次對衝交易日成交量（換手率）均值;
                                    # #         "Long_Position_average_volume_turnover_date_transaction" => y_turnover_Long_Position,  # 兩次對衝交易日成交量（換手率）均值;
                                    # #         "Short_Selling_average_volume_turnover_date_transaction" => y_turnover_Short_Selling,  # 兩次對衝交易日成交量（換手率）均值;
                                    # #         "Long_Position_volume_turnover_date_transaction" => y_E_Long_Position,  # 兩次對衝交易日成交量（換手率）向量;
                                    # #         "Short_Selling_volume_turnover_date_transaction" => y_E_Short_Selling,  # 兩次對衝交易日成交量（換手率）向量;
                                    # #         "average_date_transaction_between" => y_date_transaction_between,  # 兩次對衝交易間隔日長，均值;
                                    # #         "Long_Position_average_date_transaction_between" => y_date_transaction_between_Long_Position,  # 兩次對衝交易間隔日長，均值;
                                    # #         "Short_Selling_average_date_transaction_between" => y_date_transaction_between_Short_Selling,  # 兩次對衝交易間隔日長，均值;
                                    # #         "Long_Position_date_transaction_between" => y_C_Long_Position,  # 兩次對衝交易間隔日長，向量;
                                    # #         "Short_Selling_date_transaction_between" => y_C_Short_Selling,  # 兩次對衝交易間隔日長，向量;
                                    # #         "Long_Position_date_transaction" => y_F_Long_Position,  # 按規則執行交易的日期，向量;
                                    # #         "Short_Selling_date_transaction" => y_F_Short_Selling,  # 按規則執行交易的日期，向量;
                                    # #         "P1_Array" => P1_Array,  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
                                    # #         "revenue_and_expenditure_records_date_transaction" => y_G  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
                                    # #     )
                                    # # );

                                    # # 交易過股票的總隻數，函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
                                    # number_PickStock_transaction = Core.Int64(Base.length(Base.keys(testing_data_transaction_sequence_Dict)));  # 交易過股票的總隻數;

                                    # # 盈利概率相對化（正減負）;
                                    # total_ticker_symbol_Long_Position_profit_Positive_probability = Core.Float64(0.0);
                                    # total_ticker_symbol_Long_Position_profit_Negative_probability = Core.Float64(0.0);
                                    # Long_Position_probability_Positive_minus_Negative = Core.Array{Core.Any, 1}();
                                    # total_ticker_symbol_Short_Selling_profit_Positive_probability = Core.Float64(0.0);
                                    # total_ticker_symbol_Short_Selling_profit_Negative_probability = Core.Float64(0.0);
                                    # Short_Selling_probability_Positive_minus_Negative = Core.Array{Core.Any, 1}();
                                    # for (key, value) in PickStock_transaction_sequence_Dict
                                    #     # 取總和;
                                    #     if Base.haskey(value, "Long_Position_profit_Positive_probability")
                                    #         total_ticker_symbol_Long_Position_profit_Positive_probability_2 = Core.Float64(Core.Float64(total_ticker_symbol_Long_Position_profit_Positive_probability) + Core.Float64(value["Long_Position_profit_Positive_probability"]));
                                    #         total_ticker_symbol_Long_Position_profit_Positive_probability *= Core.Float64(0.0);
                                    #         total_ticker_symbol_Long_Position_profit_Positive_probability += Core.Float64(total_ticker_symbol_Long_Position_profit_Positive_probability_2);
                                    #     end
                                    #     if Base.haskey(value, "Long_Position_profit_Negative_probability")
                                    #         total_ticker_symbol_Long_Position_profit_Negative_probability_2 = Core.Float64(Core.Float64(total_ticker_symbol_Long_Position_profit_Negative_probability) + Core.Float64(value["Long_Position_profit_Negative_probability"]));
                                    #         total_ticker_symbol_Long_Position_profit_Negative_probability *= Core.Float64(0.0);
                                    #         total_ticker_symbol_Long_Position_profit_Negative_probability += Core.Float64(total_ticker_symbol_Long_Position_profit_Negative_probability_2);
                                    #     end
                                    #     if Base.haskey(value, "Long_Position_profit_Positive_probability") && Base.haskey(value, "Long_Position_profit_Negative_probability")
                                    #         Base.push!(Long_Position_probability_Positive_minus_Negative, Core.Float64(Core.Float64(value["Long_Position_profit_Positive_probability"]) - Core.Float64(value["Long_Position_profit_Negative_probability"])));  # 使用 push! 函數在數組末尾追加推入新元;
                                    #     end
                                    #     if Base.haskey(value, "Short_Selling_profit_Positive_probability")
                                    #         total_ticker_symbol_Short_Selling_profit_Positive_probability_2 = Core.Float64(Core.Float64(total_ticker_symbol_Short_Selling_profit_Positive_probability) + Core.Float64(value["Short_Selling_profit_Positive_probability"]));
                                    #         total_ticker_symbol_Short_Selling_profit_Positive_probability *= Core.Float64(0.0);
                                    #         total_ticker_symbol_Short_Selling_profit_Positive_probability += Core.Float64(total_ticker_symbol_Short_Selling_profit_Positive_probability_2);
                                    #     end
                                    #     if Base.haskey(value, "Short_Selling_profit_Negative_probability")
                                    #         total_ticker_symbol_Short_Selling_profit_Negative_probability_2 = Core.Float64(Core.Float64(total_ticker_symbol_Short_Selling_profit_Negative_probability) + Core.Float64(value["Short_Selling_profit_Negative_probability"]));
                                    #         total_ticker_symbol_Short_Selling_profit_Negative_probability *= Core.Float64(0.0);
                                    #         total_ticker_symbol_Short_Selling_profit_Negative_probability += Core.Float64(total_ticker_symbol_Short_Selling_profit_Negative_probability_2);
                                    #     end
                                    #     if Base.haskey(value, "Short_Selling_profit_Positive_probability") && Base.haskey(value, "Short_Selling_profit_Negative_probability")
                                    #         Base.push!(Short_Selling_probability_Positive_minus_Negative, Core.Float64(Core.Float64(value["Short_Selling_profit_Positive_probability"]) - Core.Float64(value["Short_Selling_profit_Negative_probability"])));  # 使用 push! 函數在數組末尾追加推入新元;
                                    #     end
                                    # end
                                    # # 盈利概率歸一化（Normalized）;
                                    # range_Long_Position_probability_Positive_minus_Negative = Core.Float64(0.0);
                                    # if Core.Int64(Base.length(Long_Position_probability_Positive_minus_Negative)) > Core.Int64(0)
                                    #     range_Long_Position_probability_Positive_minus_Negative = Core.Float64(Core.Float64(Base.findmax(Long_Position_probability_Positive_minus_Negative)[1]) - Core.Float64(Base.findmin(Long_Position_probability_Positive_minus_Negative)[1]));
                                    # end
                                    # range_Short_Selling_probability_Positive_minus_Negative = Core.Float64(0.0);
                                    # if Core.Int64(Base.length(Short_Selling_probability_Positive_minus_Negative)) > Core.Int64(0)
                                    #     range_Short_Selling_probability_Positive_minus_Negative = Core.Float64(Core.Float64(Base.findmax(Short_Selling_probability_Positive_minus_Negative)[1]) - Core.Float64(Base.findmin(Short_Selling_probability_Positive_minus_Negative)[1]));
                                    # end
                                    # Long_Position_probability_Positive_minus_Negative_Normalized = Base.Dict{Core.String, Core.Any}();
                                    # Short_Selling_probability_Positive_minus_Negative_Normalized = Base.Dict{Core.String, Core.Any}();
                                    # for (key, value) in PickStock_transaction_sequence_Dict
                                    #     if Base.haskey(value, "Long_Position_profit_Positive_probability") && Base.haskey(value, "Long_Position_profit_Negative_probability")
                                    #         if Core.Float64(range_Long_Position_probability_Positive_minus_Negative) > Core.Float64(0.0)
                                    #             Long_Position_probability_Positive_minus_Negative_Normalized[Base.string(key)] = Core.Float64(Core.Float64(Core.Float64(Core.Float64(value["Long_Position_profit_Positive_probability"]) - Core.Float64(value["Long_Position_profit_Negative_probability"])) - Core.Float64(Base.findmin(Long_Position_probability_Positive_minus_Negative)[1])) / Core.Float64(range_Long_Position_probability_Positive_minus_Negative));
                                    #         else
                                    #             Long_Position_probability_Positive_minus_Negative_Normalized[Base.string(key)] = Core.Float64(1.0);
                                    #         end
                                    #     end
                                    #     if Base.haskey(value, "Short_Selling_profit_Positive_probability") && Base.haskey(value, "Short_Selling_profit_Negative_probability")
                                    #         if Core.Float64(range_Short_Selling_probability_Positive_minus_Negative) > Core.Float64(0.0)
                                    #             Short_Selling_probability_Positive_minus_Negative_Normalized[Base.string(key)] = Core.Float64(Core.Float64(Core.Float64(Core.Float64(value["Short_Selling_profit_Positive_probability"]) - Core.Float64(value["Short_Selling_profit_Negative_probability"])) - Core.Float64(Base.findmin(Short_Selling_probability_Positive_minus_Negative)[1])) / Core.Float64(range_Short_Selling_probability_Positive_minus_Negative));
                                    #         else
                                    #             Short_Selling_probability_Positive_minus_Negative_Normalized[Base.string(key)] = Core.Float64(1.0);
                                    #         end
                                    #     end
                                    # end
                                    # # 選股權重，每隻股票的盈利概率占比;
                                    # total_ticker_symbol_Long_Position_probability_Positive_minus_Negative_Normalized = Core.Float64(0.0);
                                    # for (key, value) in Long_Position_probability_Positive_minus_Negative_Normalized
                                    #     # 取總和;
                                    #     total_ticker_symbol_Long_Position_probability_Positive_minus_Negative_Normalized_2 = Core.Float64(Core.Float64(total_ticker_symbol_Long_Position_probability_Positive_minus_Negative_Normalized) + Core.Float64(value));
                                    #     total_ticker_symbol_Long_Position_probability_Positive_minus_Negative_Normalized *= Core.Float64(0.0);
                                    #     total_ticker_symbol_Long_Position_probability_Positive_minus_Negative_Normalized += Core.Float64(total_ticker_symbol_Long_Position_probability_Positive_minus_Negative_Normalized_2);
                                    # end
                                    # total_ticker_symbol_Short_Selling_probability_Positive_minus_Negative_Normalized = Core.Float64(0.0);
                                    # for (key, value) in Short_Selling_probability_Positive_minus_Negative_Normalized
                                    #     # 取總和;
                                    #     total_ticker_symbol_Short_Selling_probability_Positive_minus_Negative_Normalized_2 = Core.Float64(Core.Float64(total_ticker_symbol_Short_Selling_probability_Positive_minus_Negative_Normalized) + Core.Float64(value));
                                    #     total_ticker_symbol_Short_Selling_probability_Positive_minus_Negative_Normalized *= Core.Float64(0.0);
                                    #     total_ticker_symbol_Short_Selling_probability_Positive_minus_Negative_Normalized += Core.Float64(total_ticker_symbol_Short_Selling_probability_Positive_minus_Negative_Normalized_2);
                                    # end
                                    # weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
                                    # for (key, value) in PickStock_transaction_sequence_Dict
                                    #     if Base.haskey(Long_Position_probability_Positive_minus_Negative_Normalized, Base.string(key)) || Base.haskey(Short_Selling_probability_Positive_minus_Negative_Normalized, Base.string(key))
                                    #         if !Base.haskey(weight_PickStock_Dict, Base.string(key))
                                    #             weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
                                    #         end
                                    #     end
                                    # end
                                    # for (key, value) in Long_Position_probability_Positive_minus_Negative_Normalized
                                    #     if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict)
                                    #         if Core.Float64(total_ticker_symbol_Long_Position_probability_Positive_minus_Negative_Normalized) > Core.Float64(0.0)
                                    #             weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(Core.Float64(value) / Core.Float64(total_ticker_symbol_Long_Position_probability_Positive_minus_Negative_Normalized));
                                    #         else
                                    #             weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
                                    #         end
                                    #     end
                                    # end
                                    # for (key, value) in Short_Selling_probability_Positive_minus_Negative_Normalized
                                    #     if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict)
                                    #         if Core.Float64(total_ticker_symbol_Short_Selling_probability_Positive_minus_Negative_Normalized) > Core.Float64(0.0)
                                    #             weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(Core.Float64(value) / Core.Float64(total_ticker_symbol_Short_Selling_probability_Positive_minus_Negative_Normalized));
                                    #         else
                                    #             weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
                                    #         end
                                    #     end
                                    # end
                                    # # println(weight_PickStock_Dict);

                                    # # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
                                    # # 做多（Long Position）記錄;
                                    # y_total_Long_Position = Core.Float64(0.0);  # 每兩次對衝交易利潤，纍加總計;
                                    # y_Positive_Long_Position = Core.Float64(0.0);  # 交易規則正利潤纍計;
                                    # y_Negative_Long_Position = Core.Float64(0.0);  # 交易規則負利潤纍計;
                                    # y_P_Positive_Long_Position = Core.Float64(0.0);  # 交易規則正利潤出現頻率;
                                    # y_P_Negative_Long_Position = Core.Float64(0.0);  # 交易規則負利潤出現頻率;
                                    # y_amplitude_Long_Position = Core.Float64(0.0);  # amplitude_rate;
                                    # y_turnover_Long_Position = Core.Float64(0.0);  # turnover_volume; turnover_rate;
                                    # y_date_transaction_between_Long_Position = Core.Float64(0.0);  # Between two date_transaction;
                                    # y_Long_Position = Core.Float64(0.0);  # 優化目標變量，利潤 × 權重;
                                    # # 做空（Short Selling）記錄;
                                    # y_total_Short_Selling = Core.Float64(0.0);  # 每兩次對衝交易利潤，纍加總計;
                                    # y_Positive_Short_Selling = Core.Float64(0.0);  # 交易規則正利潤纍計;
                                    # y_Negative_Short_Selling = Core.Float64(0.0);  # 交易規則負利潤纍計;
                                    # y_P_Positive_Short_Selling = Core.Float64(0.0);  # 交易規則正利潤出現頻率;
                                    # y_P_Negative_Short_Selling = Core.Float64(0.0);  # 交易規則負利潤出現頻率;
                                    # y_amplitude_Short_Selling = Core.Float64(0.0);  # amplitude_rate;
                                    # y_turnover_Short_Selling = Core.Float64(0.0);  # turnover_volume; turnover_rate;
                                    # y_date_transaction_between_Short_Selling = Core.Float64(0.0);  # Between two date_transaction;
                                    # y_Short_Selling = Core.Float64(0.0);  # 優化目標變量，利潤 × 權重;
                                    # # 做多（Long Position）記錄 + 做空（Short Selling）記錄，纍計求和;
                                    # y_total = Core.Float64(0.0);  # Core.Float64(y_total_Long_Position + y_total_Short_Selling);  # 每兩次對衝交易利潤，纍加總計;
                                    # y_Positive = Core.Float64(0.0);  # Core.Float64(y_Positive_Long_Position + y_Positive_Short_Selling);  # 交易規則正利潤纍計;
                                    # y_Negative = Core.Float64(0.0);  # Core.Float64(y_Negative_Long_Position + y_Negative_Short_Selling);  # 交易規則負利潤纍計;
                                    # y_P_Positive = Core.Float64(0.0);  # 交易規則正利潤出現頻率;
                                    # y_P_Negative = Core.Float64(0.0);  # 交易規則負利潤出現頻率;
                                    # # if Core.Int64(Base.length(y_A_Long_Position)) > Core.Int64(0) || Core.Int64(Base.length(y_A_Short_Selling)) > Core.Int64(0)
                                    # #     y_Positive_count_Long_Position = Core.Int64(0);
                                    # #     y_Negative_count_Long_Position = Core.Int64(0);
                                    # #     y_Positive_count_Short_Selling = Core.Int64(0);
                                    # #     y_Negative_count_Short_Selling = Core.Int64(0);
                                    # #     if Core.Int64(Base.length(y_A_Long_Position)) > Core.Int64(0)
                                    # #         # y_Positive_count_Long_Position = Core.Int64(Base.sum([if Core.Float64(y_A_Long_Position[i]) > Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(y_A_Long_Position)]));
                                    # #         y_Positive_count_Long_Position = Core.Int64(Base.sum([(Core.Float64(y_A_Long_Position[i]) > Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(y_A_Long_Position)]));
                                    # #         # y_Negative_count_Long_Position = Core.Int64(Base.sum([if Core.Float64(y_A_Long_Position[i]) < Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(y_A_Long_Position)]));
                                    # #         y_Negative_count_Long_Position = Core.Int64(Base.sum([(Core.Float64(y_A_Long_Position[i]) < Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(y_A_Long_Position)]));
                                    # #     end
                                    # #     if Core.Int64(Base.length(y_A_Short_Selling)) > Core.Int64(0)
                                    # #         # y_Positive_count_Short_Selling = Core.Int64(Base.sum([if Core.Float64(y_A_Short_Selling[i]) > Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(y_A_Short_Selling)]));
                                    # #         y_Positive_count_Short_Selling = Core.Int64(Base.sum([(Core.Float64(y_A_Short_Selling[i]) > Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(y_A_Short_Selling)]));
                                    # #         # y_Negative_count_Short_Selling = Core.Int64(Base.sum([if Core.Float64(y_A_Short_Selling[i]) < Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(y_A_Short_Selling)]));
                                    # #         y_Negative_count_Short_Selling = Core.Int64(Base.sum([(Core.Float64(y_A_Short_Selling[i]) < Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(y_A_Short_Selling)]));
                                    # #     end
                                    # #     y_P_Positive = Core.Float64(Core.Int64(Core.Int64(y_Positive_count_Long_Position) + Core.Int64(y_Positive_count_Short_Selling)) / Core.Int64(Core.Int64(Base.length(y_A_Long_Position)) + Core.Int64(Base.length(y_A_Short_Selling))));
                                    # #     y_P_Negative = Core.Float64(Core.Int64(Core.Int64(y_Negative_count_Long_Position) + Core.Int64(y_Negative_count_Short_Selling)) / Core.Int64(Core.Int64(Base.length(y_A_Long_Position)) + Core.Int64(Base.length(y_A_Short_Selling))));
                                    # # end
                                    # y_amplitude = Core.Float64(0.0);  # Core.Float64(Core.Float64(y_amplitude_Long_Position + y_amplitude_Short_Selling) / Core.Int64(2));  # amplitude_rate;
                                    # y_turnover = Core.Float64(0.0);  # Core.Float64(Core.Float64(y_turnover_Long_Position + y_turnover_Short_Selling) / Core.Int64(2));  # turnover_volume; turnover_rate;
                                    # y_date_transaction_between = Core.Float64(0.0);  # Core.Float64(Core.Float64(y_date_transaction_between_Long_Position + y_date_transaction_between_Short_Selling) / Core.Int64(2));  # Between two date_transaction;
                                    # y = Core.Float64(0.0);  # Core.Float64(y_Long_Position + y_Short_Selling);  # 優化目標變量，利潤 × 權重;
                                    # for (key, value) in PickStock_transaction_sequence_Dict
                                    #     if Base.isa(value, Base.Dict)

                                    #         # 做多（Long Position）記錄;
                                    #         if Base.haskey(value, "Long_Position_profit_total")
                                    #             # 取總和;
                                    #             y_total_Long_Position_2 = Core.Float64(Core.Float64(y_total_Long_Position) + Core.Float64(value["Long_Position_profit_total"]));
                                    #             y_total_Long_Position *= Core.Float64(0.0);
                                    #             y_total_Long_Position += Core.Float64(y_total_Long_Position_2);
                                    #         end
                                    #         if Base.haskey(value, "Long_Position_profit_Positive")
                                    #             # 取總和;
                                    #             y_Positive_Long_Position_2 = Core.Float64(Core.Float64(y_Positive_Long_Position) + Core.Float64(value["Long_Position_profit_Positive"]));
                                    #             y_Positive_Long_Position *= Core.Float64(0.0);
                                    #             y_Positive_Long_Position += Core.Float64(y_Positive_Long_Position_2);
                                    #         end
                                    #         if Base.haskey(value, "Long_Position_profit_Negative")
                                    #             # 取總和;
                                    #             y_Negative_Long_Position_2 = Core.Float64(Core.Float64(y_Negative_Long_Position) + Core.Float64(value["Long_Position_profit_Negative"]));
                                    #             y_Negative_Long_Position *= Core.Float64(0.0);
                                    #             y_Negative_Long_Position += Core.Float64(y_Negative_Long_Position_2);
                                    #         end
                                    #         if Base.haskey(value, "Long_Position_profit_Positive_probability")
                                    #             # 取均值;
                                    #             y_P_Positive_Long_Position_2 = Core.Float64(Core.Float64(Core.Float64(y_P_Positive_Long_Position) + Core.Float64(value["Long_Position_profit_Positive_probability"])) / Core.Int64(2));
                                    #             # # 取最大值;
                                    #             # y_P_Positive_Long_Position_2 = Core.Float64(Base.findmax([Core.Float64(y_P_Positive_Long_Position), Core.Float64(value["Long_Position_profit_Positive_probability"])])[1]);
                                    #             # # 取最小值;
                                    #             # y_P_Positive_Long_Position_2 = Core.Float64(Base.findmin([Core.Float64(y_P_Positive_Long_Position), Core.Float64(value["Long_Position_profit_Positive_probability"])])[1]);
                                    #             y_P_Positive_Long_Position *= Core.Float64(0.0);
                                    #             y_P_Positive_Long_Position += Core.Float64(y_P_Positive_Long_Position_2);
                                    #         end
                                    #         if Base.haskey(value, "Long_Position_profit_Negative_probability")
                                    #             # # 取均值;
                                    #             # y_P_Negative_Long_Position_2 = Core.Float64(Core.Float64(Core.Float64(y_P_Negative_Long_Position) + Core.Float64(value["Long_Position_profit_Negative_probability"])) / Core.Int64(2));
                                    #             # 取最大值;
                                    #             y_P_Negative_Long_Position_2 = Core.Float64(Base.findmax([Core.Float64(y_P_Negative_Long_Position), Core.Float64(value["Long_Position_profit_Negative_probability"])])[1]);
                                    #             # # 取最小值;
                                    #             # y_P_Negative_Long_Position_2 = Core.Float64(Base.findmin([Core.Float64(y_P_Negative_Long_Position), Core.Float64(value["Long_Position_profit_Negative_probability"])])[1]);
                                    #             y_P_Negative_Long_Position *= Core.Float64(0.0);
                                    #             y_P_Negative_Long_Position += Core.Float64(y_P_Negative_Long_Position_2);
                                    #         end
                                    #         if Base.haskey(value, "Long_Position_average_price_amplitude_date_transaction")
                                    #             # # 取均值;
                                    #             # y_amplitude_Long_Position_2 = Core.Float64(Core.Float64(Core.Float64(y_amplitude_Long_Position) + Core.Float64(value["Long_Position_average_price_amplitude_date_transaction"])) / Core.Int64(2));
                                    #             # 取最大值;
                                    #             y_amplitude_Long_Position_2 = Core.Float64(Base.findmax([Core.Float64(y_amplitude_Long_Position), Core.Float64(value["Long_Position_average_price_amplitude_date_transaction"])])[1]);
                                    #             # # 取最小值;
                                    #             # y_amplitude_Long_Position_2 = Core.Float64(Base.findmin([Core.Float64(y_amplitude_Long_Position), Core.Float64(value["Long_Position_average_price_amplitude_date_transaction"])])[1]);
                                    #             y_amplitude_Long_Position *= Core.Float64(0.0);
                                    #             y_amplitude_Long_Position += Core.Float64(y_amplitude_Long_Position_2);
                                    #         end
                                    #         if Base.haskey(value, "Long_Position_average_volume_turnover_date_transaction")
                                    #             # # 取均值;
                                    #             # y_turnover_Long_Position_2 = Core.Float64(Core.Float64(Core.Float64(y_turnover_Long_Position) + Core.Float64(value["Long_Position_average_volume_turnover_date_transaction"])) / Core.Int64(2));
                                    #             # # 取最大值;
                                    #             # y_turnover_Long_Position_2 = Core.Float64(Base.findmax([Core.Float64(y_turnover_Long_Position), Core.Float64(value["Long_Position_average_volume_turnover_date_transaction"])])[1]);
                                    #             # 取最小值;
                                    #             y_turnover_Long_Position_2 = Core.Float64(Base.findmin([Core.Float64(y_turnover_Long_Position), Core.Float64(value["Long_Position_average_volume_turnover_date_transaction"])])[1]);
                                    #             y_turnover_Long_Position *= Core.Float64(0.0);
                                    #             y_turnover_Long_Position += Core.Float64(y_turnover_Long_Position_2);
                                    #         end
                                    #         if Base.haskey(value, "Long_Position_average_date_transaction_between")
                                    #             # # 取均值;
                                    #             # y_date_transaction_between_Long_Position_2 = Core.Float64(Core.Float64(Core.Float64(y_date_transaction_between_Long_Position) + Core.Float64(value["Long_Position_average_date_transaction_between"])) / Core.Int64(2));
                                    #             # 取最大值;
                                    #             y_date_transaction_between_Long_Position_2 = Core.Float64(Base.findmax([Core.Float64(y_date_transaction_between_Long_Position), Core.Float64(value["Long_Position_average_date_transaction_between"])])[1]);
                                    #             # # 取最小值;
                                    #             # y_date_transaction_between_Long_Position_2 = Core.Float64(Base.findmin([Core.Float64(y_date_transaction_between_Long_Position), Core.Float64(value["Long_Position_average_date_transaction_between"])])[1]);
                                    #             y_date_transaction_between_Long_Position *= Core.Float64(0.0);
                                    #             y_date_transaction_between_Long_Position += Core.Float64(y_date_transaction_between_Long_Position_2);
                                    #         end
                                    #         if Base.haskey(value, "y_Long_Position")
                                    #             # 取總和;
                                    #             if Core.Int64(Base.length(weight_PickStock_Dict)) > Core.Int64(0)
                                    #                 if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Long_Position")
                                    #                     y_Long_Position += Core.Float64(Core.Float64(value["y_Long_Position"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Long_Position"]));
                                    #                 else
                                    #                     y_Long_Position += Core.Float64(value["y_Long_Position"]);
                                    #                 end
                                    #             else
                                    #                 y_Long_Position += Core.Float64(value["y_Long_Position"]);
                                    #             end
                                    #         end

                                    #         # 做空（Short Selling）記錄;
                                    #         if Base.haskey(value, "Short_Selling_profit_total")
                                    #             # 取總和;
                                    #             y_total_Short_Selling_2 = Core.Float64(Core.Float64(y_total_Short_Selling) + Core.Float64(value["Short_Selling_profit_total"]));
                                    #             y_total_Short_Selling *= Core.Float64(0.0);
                                    #             y_total_Short_Selling += Core.Float64(y_total_Short_Selling_2);
                                    #         end
                                    #         if Base.haskey(value, "Short_Selling_profit_Positive")
                                    #             # 取總和;
                                    #             y_Positive_Short_Selling_2 = Core.Float64(Core.Float64(y_Positive_Short_Selling) + Core.Float64(value["Short_Selling_profit_Positive"]));
                                    #             y_Positive_Short_Selling *= Core.Float64(0.0);
                                    #             y_Positive_Short_Selling += Core.Float64(y_Positive_Short_Selling_2);
                                    #         end
                                    #         if Base.haskey(value, "Short_Selling_profit_Negative")
                                    #             # 取總和;
                                    #             y_Negative_Short_Selling_2 = Core.Float64(Core.Float64(y_Negative_Short_Selling) + Core.Float64(value["Short_Selling_profit_Negative"]));
                                    #             y_Negative_Short_Selling *= Core.Float64(0.0);
                                    #             y_Negative_Short_Selling += Core.Float64(y_Negative_Short_Selling_2);
                                    #         end
                                    #         if Base.haskey(value, "Short_Selling_profit_Positive_probability")
                                    #             # 取均值;
                                    #             y_P_Positive_Short_Selling_2 = Core.Float64(Core.Float64(Core.Float64(y_P_Positive_Short_Selling) + Core.Float64(value["Short_Selling_profit_Positive_probability"])) / Core.Int64(2));
                                    #             # # 取最大值;
                                    #             # y_P_Positive_Short_Selling_2 = Core.Float64(Base.findmax([Core.Float64(y_P_Positive_Short_Selling), Core.Float64(value["Short_Selling_profit_Positive_probability"])])[1]);
                                    #             # # 取最小值;
                                    #             # y_P_Positive_Short_Selling_2 = Core.Float64(Base.findmin([Core.Float64(y_P_Positive_Short_Selling), Core.Float64(value["Short_Selling_profit_Positive_probability"])])[1]);
                                    #             y_P_Positive_Short_Selling *= Core.Float64(0.0);
                                    #             y_P_Positive_Short_Selling += Core.Float64(y_P_Positive_Short_Selling_2);
                                    #         end
                                    #         if Base.haskey(value, "Short_Selling_profit_Negative_probability")
                                    #             # # 取均值;
                                    #             # y_P_Negative_Short_Selling_2 = Core.Float64(Core.Float64(Core.Float64(y_P_Negative_Short_Selling) + Core.Float64(value["Short_Selling_profit_Negative_probability"])) / Core.Int64(2));
                                    #             # 取最大值;
                                    #             y_P_Negative_Short_Selling_2 = Core.Float64(Base.findmax([Core.Float64(y_P_Negative_Short_Selling), Core.Float64(value["Short_Selling_profit_Negative_probability"])])[1]);
                                    #             # # 取最小值;
                                    #             # y_P_Negative_Short_Selling_2 = Core.Float64(Base.findmin([Core.Float64(y_P_Negative_Short_Selling), Core.Float64(value["Short_Selling_profit_Negative_probability"])])[1]);
                                    #             y_P_Negative_Short_Selling *= Core.Float64(0.0);
                                    #             y_P_Negative_Short_Selling += Core.Float64(y_P_Negative_Short_Selling_2);
                                    #         end
                                    #         if Base.haskey(value, "Short_Selling_average_price_amplitude_date_transaction")
                                    #             # # 取均值;
                                    #             # y_amplitude_Short_Selling_2 = Core.Float64(Core.Float64(Core.Float64(y_amplitude_Short_Selling) + Core.Float64(value["Short_Selling_average_price_amplitude_date_transaction"])) / Core.Int64(2));
                                    #             # 取最大值;
                                    #             y_amplitude_Short_Selling_2 = Core.Float64(Base.findmax([Core.Float64(y_amplitude_Short_Selling), Core.Float64(value["Short_Selling_average_price_amplitude_date_transaction"])])[1]);
                                    #             # # 取最小值;
                                    #             # y_amplitude_Short_Selling_2 = Core.Float64(Base.findmin([Core.Float64(y_amplitude_Short_Selling), Core.Float64(value["Short_Selling_average_price_amplitude_date_transaction"])])[1]);
                                    #             y_amplitude_Short_Selling *= Core.Float64(0.0);
                                    #             y_amplitude_Short_Selling += Core.Float64(y_amplitude_Short_Selling_2);
                                    #         end
                                    #         if Base.haskey(value, "Short_Selling_average_volume_turnover_date_transaction")
                                    #             # # 取均值;
                                    #             # y_turnover_Short_Selling_2 = Core.Float64(Core.Float64(Core.Float64(y_turnover_Short_Selling) + Core.Float64(value["Short_Selling_average_volume_turnover_date_transaction"])) / Core.Int64(2));
                                    #             # # 取最大值;
                                    #             # y_turnover_Short_Selling_2 = Core.Float64(Base.findmax([Core.Float64(y_turnover_Short_Selling), Core.Float64(value["Short_Selling_average_volume_turnover_date_transaction"])])[1]);
                                    #             # 取最小值;
                                    #             y_turnover_Short_Selling_2 = Core.Float64(Base.findmin([Core.Float64(y_turnover_Short_Selling), Core.Float64(value["Short_Selling_average_volume_turnover_date_transaction"])])[1]);
                                    #             y_turnover_Short_Selling *= Core.Float64(0.0);
                                    #             y_turnover_Short_Selling += Core.Float64(y_turnover_Short_Selling_2);
                                    #         end
                                    #         if Base.haskey(value, "Short_Selling_average_date_transaction_between")
                                    #             # # 取均值;
                                    #             # y_date_transaction_between_Short_Selling_2 = Core.Float64(Core.Float64(Core.Float64(y_date_transaction_between_Short_Selling) + Core.Float64(value["Short_Selling_average_date_transaction_between"])) / Core.Int64(2));
                                    #             # 取最大值;
                                    #             y_date_transaction_between_Short_Selling_2 = Core.Float64(Base.findmax([Core.Float64(y_date_transaction_between_Short_Selling), Core.Float64(value["Short_Selling_average_date_transaction_between"])])[1]);
                                    #             # # 取最小值;
                                    #             # y_date_transaction_between_Short_Selling_2 = Core.Float64(Base.findmin([Core.Float64(y_date_transaction_between_Short_Selling), Core.Float64(value["Short_Selling_average_date_transaction_between"])])[1]);
                                    #             y_date_transaction_between_Short_Selling *= Core.Float64(0.0);
                                    #             y_date_transaction_between_Short_Selling += Core.Float64(y_date_transaction_between_Short_Selling_2);
                                    #         end
                                    #         if Base.haskey(value, "y_Short_Selling")
                                    #             # 取總和;
                                    #             if Core.Int64(Base.length(weight_PickStock_Dict)) > Core.Int64(0)
                                    #                 if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Short_Selling")
                                    #                     y_Short_Selling += Core.Float64(Core.Float64(value["y_Short_Selling"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Short_Selling"]));
                                    #                 else
                                    #                     y_Short_Selling += Core.Float64(value["y_Short_Selling"]);
                                    #                 end
                                    #             else
                                    #                 y_Short_Selling += Core.Float64(value["y_Short_Selling"]);
                                    #             end
                                    #         end

                                    #         # 做多（Long Position）記錄 + 做空（Short Selling）記錄，纍計求和;
                                    #         if Base.haskey(value, "profit_total")
                                    #             # 取總和;
                                    #             y_total_2 = Core.Float64(Core.Float64(y_total) + Core.Float64(value["profit_total"]));
                                    #             # # 取均值;
                                    #             # y_total_2 = Core.Float64(Core.Float64(Core.Float64(y_total) + Core.Float64(value["profit_total"])) / Core.Int64(2));
                                    #             # # 取極大值;
                                    #             # y_total_2 = Core.Float64(Base.findmax([Core.Float64(y_total), Core.Float64(value["profit_total"])])[1]);
                                    #             # # 取極小值;
                                    #             # y_total_2 = Core.Float64(Base.findmin([Core.Float64(y_total), Core.Float64(value["profit_total"])])[1]);
                                    #             y_total *= Core.Float64(0.0);
                                    #             y_total += Core.Float64(y_total_2);
                                    #         end
                                    #         if Base.haskey(value, "profit_Positive")
                                    #             # 取總和;
                                    #             y_Positive_2 = Core.Float64(Core.Float64(y_Positive) + Core.Float64(value["profit_Positive"]));
                                    #             # # 取均值;
                                    #             # y_Positive_2 = Core.Float64(Core.Float64(Core.Float64(y_Positive) + Core.Float64(value["profit_Positive"])) / Core.Int64(2));
                                    #             # # 取極大值;
                                    #             # y_Positive_2 = Core.Float64(Base.findmax([Core.Float64(y_Positive), Core.Float64(value["profit_Positive"])])[1]);
                                    #             # # 取極小值;
                                    #             # y_Positive_2 = Core.Float64(Base.findmin([Core.Float64(y_Positive), Core.Float64(value["profit_Positive"])])[1]);
                                    #             y_Positive *= Core.Float64(0.0);
                                    #             y_Positive += Core.Float64(y_Positive_2);
                                    #         end
                                    #         if Base.haskey(value, "profit_Negative")
                                    #             # 取總和;
                                    #             y_Negative_2 = Core.Float64(Core.Float64(y_Negative) + Core.Float64(value["profit_Negative"]));
                                    #             # # 取均值;
                                    #             # y_Negative_2 = Core.Float64(Core.Float64(Core.Float64(y_Negative) + Core.Float64(value["profit_Negative"])) / Core.Int64(2));
                                    #             # # 取極大值;
                                    #             # y_Negative_2 = Core.Float64(Base.findmax([Core.Float64(y_Negative), Core.Float64(value["profit_Negative"])])[1]);
                                    #             # # 取極小值;
                                    #             # y_Negative_2 = Core.Float64(Base.findmin([Core.Float64(y_Negative), Core.Float64(value["profit_Negative"])])[1]);
                                    #             y_Negative *= Core.Float64(0.0);
                                    #             y_Negative += Core.Float64(y_Negative_2);
                                    #         end
                                    #         if Base.haskey(value, "profit_Positive_probability")
                                    #             # # 取總和;
                                    #             # y_P_Positive_2 = Core.Float64(Core.Float64(y_P_Positive) + Core.Float64(value["profit_Positive_probability"]));
                                    #             # 取均值;
                                    #             y_P_Positive_2 = Core.Float64(Core.Float64(Core.Float64(y_P_Positive) + Core.Float64(value["profit_Positive_probability"])) / Core.Int64(2));
                                    #             # # 取極大值;
                                    #             # y_P_Positive_2 = Core.Float64(Base.findmax([Core.Float64(y_P_Positive), Core.Float64(value["profit_Positive_probability"])])[1]);
                                    #             # # 取極小值;
                                    #             # y_P_Positive_2 = Core.Float64(Base.findmin([Core.Float64(y_P_Positive), Core.Float64(value["profit_Positive_probability"])])[1]);
                                    #             y_P_Positive *= Core.Float64(0.0);
                                    #             y_P_Positive += Core.Float64(y_P_Positive_2);
                                    #         end
                                    #         if Base.haskey(value, "profit_Negative_probability")
                                    #             # # 取總和;
                                    #             # y_P_Negative_2 = Core.Float64(Core.Float64(y_P_Negative) + Core.Float64(value["profit_Negative_probability"]));
                                    #             # # 取均值;
                                    #             # y_P_Negative_2 = Core.Float64(Core.Float64(Core.Float64(y_P_Negative) + Core.Float64(value["profit_Negative_probability"])) / Core.Int64(2));
                                    #             # 取極大值;
                                    #             y_P_Negative_2 = Core.Float64(Base.findmax([Core.Float64(y_P_Negative), Core.Float64(value["profit_Negative_probability"])])[1]);
                                    #             # # 取極小值;
                                    #             # y_P_Negative_2 = Core.Float64(Base.findmin([Core.Float64(y_P_Negative), Core.Float64(value["profit_Negative_probability"])])[1]);
                                    #             y_P_Negative *= Core.Float64(0.0);
                                    #             y_P_Negative += Core.Float64(y_P_Negative_2);
                                    #         end
                                    #         if Base.haskey(value, "average_price_amplitude_date_transaction")
                                    #             # # 取總和;
                                    #             # y_amplitude_2 = Core.Float64(Core.Float64(y_amplitude) + Core.Float64(value["average_price_amplitude_date_transaction"]));
                                    #             # # 取均值;
                                    #             # y_amplitude_2 = Core.Float64(Core.Float64(Core.Float64(y_amplitude) + Core.Float64(value["average_price_amplitude_date_transaction"])) / Core.Int64(2));
                                    #             # 取極大值;
                                    #             y_amplitude_2 = Core.Float64(Base.findmax([Core.Float64(y_amplitude), Core.Float64(value["average_price_amplitude_date_transaction"])])[1]);
                                    #             # # 取極小值;
                                    #             # y_amplitude_2 = Core.Float64(Base.findmin([Core.Float64(y_amplitude), Core.Float64(value["average_price_amplitude_date_transaction"])])[1]);
                                    #             y_amplitude *= Core.Float64(0.0);
                                    #             y_amplitude += Core.Float64(y_amplitude_2);
                                    #         end
                                    #         if Base.haskey(value, "average_volume_turnover_date_transaction")
                                    #             # # 取總和;
                                    #             # y_turnover_2 = Core.Float64(Core.Float64(y_turnover) + Core.Float64(value["average_volume_turnover_date_transaction"]));
                                    #             # # 取均值;
                                    #             # y_turnover_2 = Core.Float64(Core.Float64(Core.Float64(y_turnover) + Core.Float64(value["average_volume_turnover_date_transaction"])) / Core.Int64(2));
                                    #             # # 取極大值;
                                    #             # y_turnover_2 = Core.Float64(Base.findmax([Core.Float64(y_turnover), Core.Float64(value["average_volume_turnover_date_transaction"])])[1]);
                                    #             # 取極小值;
                                    #             y_turnover_2 = Core.Float64(Base.findmin([Core.Float64(y_turnover), Core.Float64(value["average_volume_turnover_date_transaction"])])[1]);
                                    #             y_turnover *= Core.Float64(0.0);
                                    #             y_turnover += Core.Float64(y_turnover_2);
                                    #         end
                                    #         if Base.haskey(value, "average_date_transaction_between")
                                    #             # # 取總和;
                                    #             # y_date_transaction_between_2 = Core.Float64(Core.Float64(y_date_transaction_between) + Core.Float64(value["average_date_transaction_between"]));
                                    #             # # 取均值;
                                    #             # y_date_transaction_between_2 = Core.Float64(Core.Float64(Core.Float64(y_date_transaction_between) + Core.Float64(value["average_date_transaction_between"])) / Core.Int64(2));
                                    #             # 取極大值;
                                    #             y_date_transaction_between_2 = Core.Float64(Base.findmax([Core.Float64(y_date_transaction_between), Core.Float64(value["average_date_transaction_between"])])[1]);
                                    #             # # 取極小值;
                                    #             # y_date_transaction_between_2 = Core.Float64(Base.findmin([Core.Float64(y_date_transaction_between), Core.Float64(value["average_date_transaction_between"])])[1]);
                                    #             y_date_transaction_between *= Core.Float64(0.0);
                                    #             y_date_transaction_between += Core.Float64(y_date_transaction_between_2);
                                    #         end
                                    #         if Base.haskey(value, "y")
                                    #             # 取總和;
                                    #             if Core.Int64(Base.length(weight_PickStock_Dict)) > Core.Int64(0)
                                    #                 if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Long_Position") && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Short_Selling")
                                    #                     y_2 = Core.Float64(Core.Float64(y) + Core.Float64(Core.Float64(value["y"]) * Core.Float64(Core.Float64(weight_PickStock_Dict[Base.string(key)]["Long_Position"]) + Core.Float64(weight_PickStock_Dict[Base.string(key)]["Short_Selling"]))));
                                    #                 elseif Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Long_Position") && (!Base.haskey(weight_PickStock_Dict[Base.string(key)], "Short_Selling"))
                                    #                     y_2 = Core.Float64(Core.Float64(y) + Core.Float64(Core.Float64(value["y"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Long_Position"])));
                                    #                 elseif Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && (!Base.haskey(weight_PickStock_Dict[Base.string(key)], "Long_Position")) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Short_Selling")
                                    #                     y_2 = Core.Float64(Core.Float64(y) + Core.Float64(Core.Float64(value["y"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Short_Selling"])));
                                    #                 else
                                    #                     y_2 = Core.Float64(Core.Float64(y) + Core.Float64(value["y"]));
                                    #                 end
                                    #             else
                                    #                 y_2 = Core.Float64(Core.Float64(y) + Core.Float64(value["y"]));
                                    #             end
                                    #             # # 取總和;
                                    #             # y_2 = Core.Float64(Core.Float64(y) + Core.Float64(value["y"]));
                                    #             # # 取均值;
                                    #             # y_2 = Core.Float64(Core.Float64(Core.Float64(y) + Core.Float64(value["y"])) / Core.Int64(2));
                                    #             # # 取極大值;
                                    #             # y_2 = Core.Float64(Base.findmax([Core.Float64(y), Core.Float64(value["y"])])[1]);
                                    #             # # 取極小值;
                                    #             # y_2 = Core.Float64(Base.findmin([Core.Float64(y), Core.Float64(value["y"])])[1]);
                                    #             y *= Core.Float64(0.0);
                                    #             y += Core.Float64(y_2);
                                    #         end
                                    #     end
                                    # end
                                    # y = Core.Float64(y_Long_Position + y_Short_Selling);  # 優化目標變量;

                                    # # 測試數據集依據量化規則執行的交易信息;
                                    # stepping_transaction_Dict["testing_transaction"] = Base.Dict{Core.String, Core.Any}(
                                    #     "y" => y,  # 優化目標變量，每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    #     "y_Long_Position" => y_Long_Position,  # 優化目標變量，做多（Long Position），每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    #     "y_Short_Selling" => y_Short_Selling,  # 優化目標變量，做空（Short Selling），每兩次對衝交易利潤 × 權重，加權纍加總計;
                                    #     "profit_total" => y_total,  # 每兩次對衝交易利潤 × 權重，纍加總計;
                                    #     "Long_Position_profit_total" => y_total_Long_Position,  # 每兩次對衝交易利潤 × 權重，纍加總計;
                                    #     "Short_Selling_profit_total" => y_total_Short_Selling,  # 每兩次對衝交易利潤 × 權重，纍加總計;
                                    #     "profit_Positive" => y_Positive,  # 每兩次對衝交易收益纍加總計;
                                    #     "Long_Position_profit_Positive" => y_Positive_Long_Position,  # 每兩次對衝交易收益纍加總計;
                                    #     "Short_Selling_profit_Positive" => y_Positive_Short_Selling,  # 每兩次對衝交易收益纍加總計;
                                    #     "profit_Positive_probability" => y_P_Positive,  # 每兩次對衝交易正利潤概率;
                                    #     "Long_Position_profit_Positive_probability" => y_P_Positive_Long_Position,  # 每兩次對衝交易正利潤概率;
                                    #     "Short_Selling_profit_Positive_probability" => y_P_Positive_Short_Selling,  # 每兩次對衝交易正利潤概率;
                                    #     "profit_Negative" => y_Negative,  # 每兩次對衝交易損失纍加總計;
                                    #     "Long_Position_profit_Negative" => y_Negative_Long_Position,  # 每兩次對衝交易損失纍加總計;
                                    #     "Short_Selling_profit_Negative" => y_Negative_Short_Selling,  # 每兩次對衝交易損失纍加總計;
                                    #     "profit_Negative_probability" => y_P_Negative,  # 每兩次對衝交易負利潤概率;
                                    #     "Long_Position_profit_Negative_probability" => y_P_Negative_Long_Position,  # 每兩次對衝交易負利潤概率;
                                    #     "Short_Selling_profit_Negative_probability" => y_P_Negative_Short_Selling,  # 每兩次對衝交易負利潤概率;
                                    #     "average_price_amplitude_date_transaction" => y_amplitude,  # 兩次對衝交易日成交價振幅平方和，均值;
                                    #     "Long_Position_average_price_amplitude_date_transaction" => y_amplitude_Long_Position,  # 兩次對衝交易日成交價振幅平方和，均值;
                                    #     "Short_Selling_average_price_amplitude_date_transaction" => y_amplitude_Short_Selling,  # 兩次對衝交易日成交價振幅平方和，均值;
                                    #     "average_volume_turnover_date_transaction" => y_turnover,  # 兩次對衝交易日成交量（換手率）均值;
                                    #     "Long_Position_average_volume_turnover_date_transaction" => y_turnover_Long_Position,  # 兩次對衝交易日成交量（換手率）均值;
                                    #     "Short_Selling_average_volume_turnover_date_transaction" => y_turnover_Short_Selling,  # 兩次對衝交易日成交量（換手率）均值;
                                    #     "average_date_transaction_between" => y_date_transaction_between,  # 兩次對衝交易間隔日長，均值;
                                    #     "Long_Position_average_date_transaction_between" => y_date_transaction_between_Long_Position,  # 兩次對衝交易間隔日長，均值;
                                    #     "Short_Selling_average_date_transaction_between" => y_date_transaction_between_Short_Selling,  # 兩次對衝交易間隔日長，均值;
                                    #     "number_PickStock_transaction" => number_PickStock_transaction,  # 交易過的股票總支數;
                                    #     "testing_transaction_sequence" => testing_data_transaction_sequence_Dict,  # 記錄按規則篩選股票按照擇時規則交易信息的序列;
                                    #     "PickStock_sort" => Base.Dict{Core.String, Core.Any}(
                                    #         "ticker_symbol" => PickStock_ticker_symbol_Array,  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;
                                    #         "score" => PickStock_score_Array  # 依照選股規則排序篩選出的股票得分值存儲數組;
                                    #     )  # 依照選股規則排序篩選出的股票代碼字符串和得分存儲字典（Dict）;
                                    # );

                                    # Base.push!(stepping_sequence_Array, stepping_transaction_Dict);  # 使用 push! 函數在數組末尾追加推入新元;

                                    # # 釋放内存;
                                    # testing_data_transaction_sequence_Dict = Core.nothing;
                                    # stepping_transaction_Dict = Core.nothing;
                                    # testingData = Core.nothing;  # 釋放内存;
                                end

                                # 釋放内存;
                                testingData = Core.nothing;
                            end
                        end
                    end
                    k = Core.nothing;  # 釋放内存;

                    # 釋放内存;
                    trainingData = Core.nothing;
                    MarketTiming_Parameter_Dict = Core.nothing;
                    weight_MarketTiming_Dict = Core.nothing;
                    Plower_weight_MarketTiming_Dict = Core.nothing;
                    Pupper_weight_MarketTiming_Dict = Core.nothing;
                    PickStock_Parameter_Dict = Core.nothing;
                    weight_PickStock_Dict = Core.nothing;
                    Plower_weight_PickStock_Dict = Core.nothing;
                    Pupper_weight_PickStock_Dict = Core.nothing;
                    PickStock_ticker_symbol_Array = Core.nothing;
                    PickStock_ticker_symbol_Array_testing_data_Long_Position = Core.nothing;
                    PickStock_ticker_symbol_Array_testing_data_Short_Selling = Core.nothing;
                    SizePosition_Parameter_Array = Core.nothing;
                end

                # 釋放内存;
                stepping_transaction_Dict = Core.nothing;
            end
        end

        return_stepping_Dict["stepping_sequence"] = stepping_sequence_Array;

        # stepping_sequence_Array::Core.Array{Core.Any, 1} === Core.Array{Base.Dict{Core.String, Core.Any}, 1}()[
        #     stepping_transaction_Dict === Base.Dict{Core.String, Core.Any}(
        #         "training_data" => trainingData === Base.Dict{Core.String, Core.Any}(
        #             "ticker_symbol" => Base.Dict{Core.String, Core.Any}(
        #                 "date_transaction" => Core.Array{Dates.Date, 1}(),
        #                 "turnover_volume" => Core.Array{Core.Int64, 1}(),
        #                 "opening_price" => Core.Array{Core.Float64, 1}(),
        #                 "close_price" => Core.Array{Core.Float64, 1}(),
        #                 "low_price" => Core.Array{Core.Float64, 1}(),
        #                 "high_price" => Core.Array{Core.Float64, 1}()
        #             )
        #         ),
        #         "training_MarketTiming_Parameter" => MarketTiming_Parameter_Dict === Base.Dict{Core.String, Core.Any}(
        #             "ticker_symbol" => Base.Dict{Core.String, Core.Any}(
        #                 "Long_Position" => Core.Float64(),
        #                 "Short_Selling" => Core.Float64()
        #             )
        #         ),
        #         "training_PickStock_Parameter" => PickStock_Parameter_Dict === Base.Dict{Core.String, Core.Any}(
        #             "ticker_symbol" => Base.Dict{Core.String, Core.Any}(
        #                 "Long_Position" => Core.Float64(),
        #                 "Short_Selling" => Core.Float64()
        #             )
        #         ),
        #         "training_PickStock_ticker_symbol" => PickStock_ticker_symbol_Array::Core.Array{Core.Any, 1} === Core.Array{Core.Array{Core.String, 1}, 1}()[
        #             [
        #                 Base.string()
        #             ]
        #         ],
        #         "training_SizePosition_Parameter" => SizePosition_Parameter_Array::Core.Array{Core.Any, 1} === Core.Array{Base.Dict{Core.String, Core.Any}, 1}()[
        #             weight_MarketTiming_Dict === Base.Dict{Core.String, Core.Any}(
        #                 "ticker_symbol" => Base.Dict{Core.String, Core.Any}(
        #                     "Long_Position" => Core.Float64(),
        #                     "Short_Selling" => Core.Float64()
        #                 )
        #             ),
        #             weight_PickStock_Dict === Base.Dict{Core.String, Core.Any}(
        #                 "ticker_symbol" => Base.Dict{Core.String, Core.Any}(
        #                     "Long_Position" => Core.Float64(),
        #                     "Short_Selling" => Core.Float64()
        #                 )
        #             )
        #         ],
        #         "testing_data" => testingData === Base.Dict{Core.String, Core.Any}(
        #             "ticker_symbol" => Base.Dict{Core.String, Core.Any}(
        #                 "date_transaction" => Core.Array{Dates.Date, 1}(),
        #                 "turnover_volume" => Core.Array{Core.Int64, 1}(),
        #                 "opening_price" => Core.Array{Core.Float64, 1}(),
        #                 "close_price" => Core.Array{Core.Float64, 1}(),
        #                 "low_price" => Core.Array{Core.Float64, 1}(),
        #                 "high_price" => Core.Array{Core.Float64, 1}()
        #             )
        #         ),
        #         "testing_PickStock_ticker_symbol" => Base.Dict{Core.String, Core.Any}(
        #             "Long_Position" => PickStock_ticker_symbol_Array_testing_data_Long_Position::Core.Array{Core.String, 1} === Core.Array{Core.String, 1}()[Base.string()],
        #             "Short_Selling" => PickStock_ticker_symbol_Array_testing_data_Short_Selling::Core.Array{Core.String, 1} === Core.Array{Core.String, 1}()[Base.string()]
        #         ),
        #         "testing_transaction" => Base.Dict{Core.String, Core.Any}(
        #             "Long_Position" => Long_Position_testing_data_transaction_sequence_Dict === Base.Dict{Core.String, Core.Any}(
        #                 "ticker_symbol" => Base.Dict{Core.String, Core.Any}(
        #                     "revenue_and_expenditure_records_date_transaction" => Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}()[Core.Float64()],
        #                     "Long_Position_profit_date_transaction" => Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}()[Core.Float64()],
        #                     "Index_date_transaction_Long_Position" => Core.Int64(),
        #                     "Long_Position_date_transaction" => Core.Array{Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}, 1}()[
        #                         Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}(Core.undef, 16)[
        #                             ::Dates.Date,  # 交易時間日期（Dates.Date 或 Dates.DateTime 類型）;
        #                             ::Core.String,  # Base.string("buy"), Base.string("sell"),  # 買入或賣出標識;
        #                             ::Core.Float64,  # 成交價;
        #                             ::Core.Float64,  # 倉位;
        #                             ::Core.Int64,  # 每次成交序號標識;
        #                             ::Core.Int64,  # 交易日期的序列號，用於繪圖可視化;
        #                             ::Dates.Date,  # 交易日（Dates.Date 類型）;
        #                             ::Core.Int64,  # 當日總成交量（turnover volume）;
        #                             ::Core.Float64,  # 當日開盤（opening）成交價;
        #                             ::Core.Float64,  # 當日收盤（closing）成交價;
        #                             ::Core.Float64,  # 當日最低（low）成交價;
        #                             ::Core.Float64,  # 當日最高（high）成交價;
        #                             # ::Core.Float64,  # 當日總成交金額（turnover amount）;
        #                             # ::Core.Int64,  # 當日成交量（turnover volume）換手率（turnover rate）;
        #                             # ::Core.Float64,  # 當日每股收益（price earnings）;
        #                             # ::Core.Float64,  # 當日每股净值（book value per share）;
        #                         ]
        #                     ],
        #                     "drawdown" => drawdown_Array_Long_Position::Core.Array{Core.Float64, 1} === Core.Array{Core.Float64, 1}()[Core.Float64()]
        #                 )
        #             ),
        #             "Short_Selling" => Short_Selling_testing_data_transaction_sequence_Dict === Base.Dict{Core.String, Core.Any}(
        #                 "ticker_symbol" => Base.Dict{Core.String, Core.Any}(
        #                     "revenue_and_expenditure_records_date_transaction" => Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}()[Core.Float64()],
        #                     "Short_Selling_profit_date_transaction" => Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}()[Core.Float64()],
        #                     "Index_date_transaction_Short_Selling" => Core.Int64(),
        #                     "Short_Selling_date_transaction" => Core.Array{Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}, 1}()[
        #                         Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}(Core.undef, 16)[
        #                             ::Dates.Date,  # 交易時間日期（Dates.Date 或 Dates.DateTime 類型）;
        #                             ::Core.String,  # Base.string("buy"), Base.string("sell"),  # 買入或賣出標識;
        #                             ::Core.Float64,  # 成交價;
        #                             ::Core.Float64,  # 倉位;
        #                             ::Core.Int64,  # 每次成交序號標識;
        #                             ::Core.Int64,  # 交易日期的序列號，用於繪圖可視化;
        #                             ::Dates.Date,  # 交易日（Dates.Date 類型）;
        #                             ::Core.Int64,  # 當日總成交量（turnover volume）;
        #                             ::Core.Float64,  # 當日開盤（opening）成交價;
        #                             ::Core.Float64,  # 當日收盤（closing）成交價;
        #                             ::Core.Float64,  # 當日最低（low）成交價;
        #                             ::Core.Float64,  # 當日最高（high）成交價;
        #                             # ::Core.Float64,  # 當日總成交金額（turnover amount）;
        #                             # ::Core.Int64,  # 當日成交量（turnover volume）換手率（turnover rate）;
        #                             # ::Core.Float64,  # 當日每股收益（price earnings）;
        #                             # ::Core.Float64,  # 當日每股净值（book value per share）;
        #                         ]
        #                     ],
        #                     "drawdown" => drawdown_Array_Short_Selling::Core.Array{Core.Float64, 1} === Core.Array{Core.Float64, 1}()[Core.Float64()]
        #                 )
        #             )
        #         )
        #     )
        # ];

        data_transaction_sequence_Dict = Base.Dict{Core.String, Core.Any}();  # 記錄按規則篩選股票按照擇時規則交易信息的序列;
        # if Base.typeof(stepping_sequence_Array) <: Core.Array && Base.length(stepping_sequence_Array) > 0
        #     for i = Core.Int64(1):Core.Int64(Base.length(stepping_sequence_Array))
        #         if Base.isa(stepping_sequence_Array[i], Base.Dict) && Base.haskey(stepping_sequence_Array[i], "testing_transaction")
        #             if Base.isa(stepping_sequence_Array[i]["testing_transaction"], Base.Dict)
        #                 # 做多（Long Position）記錄;
        #                 if Base.haskey(stepping_sequence_Array[i]["testing_transaction"], "Long_Position") && Base.isa(stepping_sequence_Array[i]["testing_transaction"]["Long_Position"], Base.Dict) && Core.Int64(Base.length(stepping_sequence_Array[i]["testing_transaction"]["Long_Position"])) > Core.Int64(0)
        #                     for (key, value) in stepping_sequence_Array[i]["testing_transaction"]["Long_Position"]
        #                         if !(Base.haskey(data_transaction_sequence_Dict, Base.string(key)))
        #                             data_transaction_sequence_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}("Long_Position" => Base.Dict{Core.String, Core.Any}());
        #                         elseif Base.haskey(data_transaction_sequence_Dict, Base.string(key)) && Base.isa(data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && (!(Base.haskey(data_transaction_sequence_Dict[Base.string(key)], "Long_Position")))
        #                             data_transaction_sequence_Dict[Base.string(key)]["Long_Position"] = Base.Dict{Core.String, Core.Any}();
        #                         else
        #                         end
        #                         if Base.haskey(data_transaction_sequence_Dict, Base.string(key)) && Base.isa(data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && Base.haskey(data_transaction_sequence_Dict[Base.string(key)], "Long_Position") && Base.isa(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], Base.Dict) && Core.Int64(Base.length(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"])) <= Core.Int64(0)
        #                             # 做多（Long Position）記錄;
        #                             data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["index"] = Core.Array{Core.Int64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["direction"] = Core.Array{Core.String, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["SizePosition"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["focus"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["amplitude"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["turnover_volume"] = Core.Array{Core.Int64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["opening_price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["close_price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["low_price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["high_price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["drawdown"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                         end
        #                     end
        #                 end
        #                 # 做空（Short Selling）記錄;
        #                 if Base.haskey(stepping_sequence_Array[i]["testing_transaction"], "Short_Selling") && Base.isa(stepping_sequence_Array[i]["testing_transaction"]["Short_Selling"], Base.Dict) && Core.Int64(Base.length(stepping_sequence_Array[i]["testing_transaction"]["Short_Selling"])) > Core.Int64(0)
        #                     for (key, value) in stepping_sequence_Array[i]["testing_transaction"]["Short_Selling"]
        #                         if !(Base.haskey(data_transaction_sequence_Dict, Base.string(key)))
        #                             data_transaction_sequence_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}("Short_Selling" => Base.Dict{Core.String, Core.Any}());
        #                         elseif Base.haskey(data_transaction_sequence_Dict, Base.string(key)) && Base.isa(data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && (!(Base.haskey(data_transaction_sequence_Dict[Base.string(key)], "Short_Selling")))
        #                             data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"] = Base.Dict{Core.String, Core.Any}();
        #                         else
        #                         end
        #                         if Base.haskey(data_transaction_sequence_Dict, Base.string(key)) && Base.isa(data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && Base.haskey(data_transaction_sequence_Dict[Base.string(key)], "Short_Selling") && Base.isa(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], Base.Dict) && Core.Int64(Base.length(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"])) <= Core.Int64(0)
        #                             # 做空（Short Selling）記錄;
        #                             data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["index"] = Core.Array{Core.Int64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["direction"] = Core.Array{Core.String, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["SizePosition"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["focus"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["amplitude"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["turnover_volume"] = Core.Array{Core.Int64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["opening_price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["close_price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["low_price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["high_price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                             data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["drawdown"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
        #                         end
        #                     end
        #                 end
        #             end
        #         end
        #     end
        # end
        if ((Base.typeof(stepping_sequence_Array) <: Core.Array) || (Base.typeof(stepping_sequence_Array) <: Base.Vector)) && Core.Int64(Base.length(stepping_sequence_Array)) > Core.Int64(0)
            for i = Core.Int64(1):Core.Int64(Base.length(stepping_sequence_Array))
                if Base.isa(stepping_sequence_Array[i], Base.Dict) && Base.haskey(stepping_sequence_Array[i], "testing_transaction")
                    if Base.isa(stepping_sequence_Array[i]["testing_transaction"], Base.Dict)
                        # 做多（Long Position）記錄;
                        if Base.haskey(stepping_sequence_Array[i]["testing_transaction"], "Long_Position") && Base.isa(stepping_sequence_Array[i]["testing_transaction"]["Long_Position"], Base.Dict) && Core.Int64(Base.length(stepping_sequence_Array[i]["testing_transaction"]["Long_Position"])) > Core.Int64(0)
                            for (key, value) in stepping_sequence_Array[i]["testing_transaction"]["Long_Position"]
                                if Base.isa(value, Base.Dict) && Base.haskey(value, "Long_Position_date_transaction") && ((Base.typeof(value["Long_Position_date_transaction"]) <: Core.Array) || (Base.typeof(value["Long_Position_date_transaction"]) <: Base.Vector))
                                    for j = Core.Int64(1):Core.Int64(Base.length(value["Long_Position_date_transaction"]))
                                        if ((Base.typeof(value["Long_Position_date_transaction"][j]) <: Core.Array) || (Base.typeof(value["Long_Position_date_transaction"][j]) <: Base.Vector)) && Core.Int64(Base.length(value["Long_Position_date_transaction"][j])) >= Core.Int64(12)
                                            if !(Base.haskey(data_transaction_sequence_Dict, Base.string(key)))
                                                data_transaction_sequence_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}("Long_Position" => Base.Dict{Core.String, Core.Any}());
                                            elseif Base.haskey(data_transaction_sequence_Dict, Base.string(key)) && Base.isa(data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && (!(Base.haskey(data_transaction_sequence_Dict[Base.string(key)], "Long_Position")))
                                                data_transaction_sequence_Dict[Base.string(key)]["Long_Position"] = Base.Dict{Core.String, Core.Any}();
                                            else
                                            end
                                            if Base.haskey(data_transaction_sequence_Dict, Base.string(key)) && Base.isa(data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && Base.haskey(data_transaction_sequence_Dict[Base.string(key)], "Long_Position") && Base.isa(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], Base.Dict)
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "index"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["index"] = Core.Array{Core.Int64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "direction"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["direction"] = Core.Array{Core.String, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "price"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "SizePosition"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["SizePosition"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "focus"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["focus"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "amplitude"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["amplitude"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "date_transaction"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "turnover_volume"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["turnover_volume"] = Core.Array{Core.Int64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "opening_price"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["opening_price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "close_price"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["close_price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "low_price"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["low_price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "high_price"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["high_price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "MarketTiming_Parameter"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["MarketTiming_Parameter"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "PickStock_Parameter"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["PickStock_Parameter"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "SizePosition_Parameter"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["SizePosition_Parameter"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "PickStock_ticker"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["PickStock_ticker"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end

                                                # 做多（Long Position）記錄;
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "index") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["index"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["index"], Core.Int64(value["Long_Position_date_transaction"][j][6]));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "direction") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["direction"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["direction"], Base.string(value["Long_Position_date_transaction"][j][2]));
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "price") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["price"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["price"], Core.Float64(value["Long_Position_date_transaction"][j][3]));
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "SizePosition") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["SizePosition"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["SizePosition"], value["Long_Position_date_transaction"][j][4]);
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "focus") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["focus"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["focus"], Core.Float64(Statistics.mean([Core.Float64(value["Long_Position_date_transaction"][j][9]), Core.Float64(value["Long_Position_date_transaction"][j][10]), Core.Float64(value["Long_Position_date_transaction"][j][11]), Core.Float64(value["Long_Position_date_transaction"][j][12])])));
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "amplitude") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["amplitude"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["amplitude"], Core.Float64(Statistics.std([Core.Float64(value["Long_Position_date_transaction"][j][9]), Core.Float64(value["Long_Position_date_transaction"][j][10]), Core.Float64(value["Long_Position_date_transaction"][j][11]), Core.Float64(value["Long_Position_date_transaction"][j][12])]; corrected = false)));
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "date_transaction") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["date_transaction"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["date_transaction"], value["Long_Position_date_transaction"][j][1]);
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "turnover_volume") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["turnover_volume"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["turnover_volume"], Core.Int64(value["Long_Position_date_transaction"][j][8]));
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "opening_price") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["opening_price"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["opening_price"], Core.Float64(value["Long_Position_date_transaction"][j][9]));
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "close_price") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["close_price"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["close_price"], Core.Float64(value["Long_Position_date_transaction"][j][10]));
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "low_price") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["low_price"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["low_price"], Core.Float64(value["Long_Position_date_transaction"][j][11]));
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "high_price") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["high_price"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["high_price"], Core.Float64(value["Long_Position_date_transaction"][j][12]));
                                                end

                                                # 記錄該輪對衝交易的回撤值序列;
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "drawdown"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["drawdown"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "drawdown") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["drawdown"]) <: Core.Array
                                                    if Base.string(value["Long_Position_date_transaction"][j][2]) === "buy"
                                                        Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["drawdown"], Base.missing);  # Base.missing;  # Core.nothing;  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                        # if Base.haskey(value, "drawdown")
                                                        #     # Base.isa(value, Base.Dict) && Base.haskey(value, "drawdown") && Base.typeof(value["drawdown"]) <: Core.Array
                                                        #     Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["drawdown"], value["drawdown"]);  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                        # else
                                                        #     Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["drawdown"], Base.missing);  # Base.missing;  # Core.nothing;  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                        # end
                                                    end
                                                    if Base.string(value["Long_Position_date_transaction"][j][2]) === "sell"
                                                        if Base.haskey(value, "drawdown")
                                                            # Base.isa(value, Base.Dict) && Base.haskey(value, "drawdown") && Base.typeof(value["drawdown"]) <: Core.Array
                                                            Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["drawdown"], value["drawdown"]);  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                        else
                                                            Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["drawdown"], Base.missing);  # Base.missing;  # Core.nothing;  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                        end
                                                    end
                                                end

                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "MarketTiming_Parameter") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["MarketTiming_Parameter"]) <: Core.Array
                                                    MarketTiming_Parameter_Index = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                    if Base.haskey(stepping_sequence_Array[i], "training_MarketTiming_Parameter") && Base.isa(stepping_sequence_Array[i]["training_MarketTiming_Parameter"], Base.Dict)
                                                        if Base.haskey(stepping_sequence_Array[i]["training_MarketTiming_Parameter"], key) && Base.isa(stepping_sequence_Array[i]["training_MarketTiming_Parameter"][key], Base.Dict)
                                                            if Base.haskey(stepping_sequence_Array[i]["training_MarketTiming_Parameter"][key], "Long_Position") && ((Base.typeof(stepping_sequence_Array[i]["training_MarketTiming_Parameter"][key]["Long_Position"]) <: Core.Array) || (Base.typeof(stepping_sequence_Array[i]["training_MarketTiming_Parameter"][key]["Long_Position"]) <: Base.Vector)) && Core.Int64(Base.length(stepping_sequence_Array[i]["training_MarketTiming_Parameter"][key]["Long_Position"])) > Core.Int64(0)
                                                                k = Core.Int64(0);
                                                                for k = Core.Int64(1):Core.Int64(Base.length(stepping_sequence_Array[i]["training_MarketTiming_Parameter"][key]["Long_Position"]))
                                                                    Base.push!(MarketTiming_Parameter_Index, stepping_sequence_Array[i]["training_MarketTiming_Parameter"][key]["Long_Position"][k]);
                                                                end
                                                                k = Core.nothing;
                                                            end
                                                        end
                                                    end
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["MarketTiming_Parameter"], MarketTiming_Parameter_Index);
                                                    MarketTiming_Parameter_Index = Core.nothing;
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "PickStock_Parameter") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["PickStock_Parameter"]) <: Core.Array
                                                    PickStock_Parameter_Index = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                    if Base.haskey(stepping_sequence_Array[i], "training_PickStock_Parameter") && Base.isa(stepping_sequence_Array[i]["training_PickStock_Parameter"], Base.Dict)
                                                        if Base.haskey(stepping_sequence_Array[i]["training_PickStock_Parameter"], "Long_Position") && ((Base.typeof(stepping_sequence_Array[i]["training_PickStock_Parameter"]["Long_Position"]) <: Core.Array) || (Base.typeof(stepping_sequence_Array[i]["training_PickStock_Parameter"]["Long_Position"]) <: Base.Vector)) && Core.Int64(Base.length(stepping_sequence_Array[i]["training_PickStock_Parameter"]["Long_Position"])) > Core.Int64(0)
                                                            k = Core.Int64(0);
                                                            for k = Core.Int64(1):Core.Int64(Base.length(stepping_sequence_Array[i]["training_PickStock_Parameter"]["Long_Position"]))
                                                                Base.push!(PickStock_Parameter_Index, stepping_sequence_Array[i]["training_PickStock_Parameter"]["Long_Position"][k]);
                                                            end
                                                            k = Core.nothing;
                                                        end
                                                    end
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["PickStock_Parameter"], PickStock_Parameter_Index);
                                                    PickStock_Parameter_Index = Core.nothing;
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "SizePosition_Parameter") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["SizePosition_Parameter"]) <: Core.Array
                                                    SizePosition_Parameter_Index = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                    if Base.haskey(stepping_sequence_Array[i], "training_SizePosition_Parameter") && ((Base.typeof(stepping_sequence_Array[i]["training_SizePosition_Parameter"]) <: Core.Array) || (Base.typeof(stepping_sequence_Array[i]["training_SizePosition_Parameter"]) <: Base.Vector))
                                                        if (Base.length(stepping_sequence_Array[i]["training_SizePosition_Parameter"]) >= 1) && Base.isa(stepping_sequence_Array[i]["training_SizePosition_Parameter"][1], Base.Dict)
                                                            if Base.haskey(stepping_sequence_Array[i]["training_SizePosition_Parameter"][1], key) && Base.isa(stepping_sequence_Array[i]["training_SizePosition_Parameter"][1][key], Base.Dict)
                                                                if Base.haskey(stepping_sequence_Array[i]["training_SizePosition_Parameter"][1][key], "Long_Position")
                                                                    if Base.length(SizePosition_Parameter_Index) >= 1
                                                                        SizePosition_Parameter_Index[1] = stepping_sequence_Array[i]["training_SizePosition_Parameter"][1][key]["Long_Position"];
                                                                    elseif Base.length(SizePosition_Parameter_Index) === 0
                                                                        Base.push!(SizePosition_Parameter_Index, stepping_sequence_Array[i]["training_SizePosition_Parameter"][1][key]["Long_Position"]);  # 使用 push! 函數在數組末尾追加推入新元素;
                                                                    else
                                                                    end
                                                                end
                                                            end
                                                        end
                                                        if (Base.length(stepping_sequence_Array[i]["training_SizePosition_Parameter"]) >= 2) && Base.isa(stepping_sequence_Array[i]["training_SizePosition_Parameter"][2], Base.Dict)
                                                            if Base.haskey(stepping_sequence_Array[i]["training_SizePosition_Parameter"][2], key) && Base.isa(stepping_sequence_Array[i]["training_SizePosition_Parameter"][2][key], Base.Dict)
                                                                if Base.haskey(stepping_sequence_Array[i]["training_SizePosition_Parameter"][2][key], "Long_Position")
                                                                    if Base.length(SizePosition_Parameter_Index) >= 2
                                                                        SizePosition_Parameter_Index[2] = stepping_sequence_Array[i]["training_SizePosition_Parameter"][2][key]["Long_Position"];
                                                                    elseif Base.length(SizePosition_Parameter_Index) === 1
                                                                        Base.push!(SizePosition_Parameter_Index, stepping_sequence_Array[i]["training_SizePosition_Parameter"][2][key]["Long_Position"]);
                                                                    elseif Base.length(SizePosition_Parameter_Index) === 0
                                                                        Base.push!(SizePosition_Parameter_Index, Base.missing);  # Core.nothing;
                                                                        Base.push!(SizePosition_Parameter_Index, stepping_sequence_Array[i]["training_SizePosition_Parameter"][2][key]["Long_Position"]);  # 使用 push! 函數在數組末尾追加推入新元素;
                                                                    else
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["SizePosition_Parameter"], SizePosition_Parameter_Index);
                                                    SizePosition_Parameter_Index = Core.nothing;
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "PickStock_ticker") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["PickStock_ticker"]) <: Core.Array
                                                    PickStock_ticker_Index = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                    if Base.haskey(stepping_sequence_Array[i], "training_PickStock_ticker_symbol") && ((Base.typeof(stepping_sequence_Array[i]["training_PickStock_ticker_symbol"]) <: Core.Array) || (Base.typeof(stepping_sequence_Array[i]["training_PickStock_ticker_symbol"]) <: Base.Vector)) && Core.Int64(Base.length(stepping_sequence_Array[i]["training_PickStock_ticker_symbol"])) > Core.Int64(0)
                                                        k = Core.Int64(0);
                                                        for k = Core.Int64(1):Core.Int64(Base.length(stepping_sequence_Array[i]["training_PickStock_ticker_symbol"]))
                                                            Base.push!(PickStock_ticker_Index, stepping_sequence_Array[i]["training_PickStock_ticker_symbol"][k]);
                                                        end
                                                        k = Core.nothing;
                                                    end
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["PickStock_ticker"], PickStock_ticker_Index);
                                                    PickStock_ticker_Index = Core.nothing;
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end

                        # 做空（Short Selling）記錄;
                        if Base.haskey(stepping_sequence_Array[i]["testing_transaction"], "Short_Selling") && Base.isa(stepping_sequence_Array[i]["testing_transaction"]["Short_Selling"], Base.Dict) && Core.Int64(Base.length(stepping_sequence_Array[i]["testing_transaction"]["Short_Selling"])) > Core.Int64(0)
                            for (key, value) in stepping_sequence_Array[i]["testing_transaction"]["Short_Selling"]
                                if Base.isa(value, Base.Dict) && Base.haskey(value, "Short_Selling_date_transaction") && ((Base.typeof(value["Short_Selling_date_transaction"]) <: Core.Array) || (Base.typeof(value["Short_Selling_date_transaction"]) <: Base.Vector))
                                    for j = Core.Int64(1):Core.Int64(Base.length(value["Short_Selling_date_transaction"]))
                                        if ((Base.typeof(value["Short_Selling_date_transaction"][j]) <: Core.Array) || (Base.typeof(value["Short_Selling_date_transaction"][j]) <: Base.Vector)) && Core.Int64(Base.length(value["Short_Selling_date_transaction"][j])) >= Core.Int64(12)
                                            if !(Base.haskey(data_transaction_sequence_Dict, Base.string(key)))
                                                data_transaction_sequence_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}("Short_Selling" => Base.Dict{Core.String, Core.Any}());
                                            elseif Base.haskey(data_transaction_sequence_Dict, Base.string(key)) && Base.isa(data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && (!(Base.haskey(data_transaction_sequence_Dict[Base.string(key)], "Short_Selling")))
                                                data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"] = Base.Dict{Core.String, Core.Any}();
                                            else
                                            end
                                            if Base.haskey(data_transaction_sequence_Dict, Base.string(key)) && Base.isa(data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && Base.haskey(data_transaction_sequence_Dict[Base.string(key)], "Short_Selling") && Base.isa(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], Base.Dict)
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "index"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["index"] = Core.Array{Core.Int64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "direction"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["direction"] = Core.Array{Core.String, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "price"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "SizePosition"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["SizePosition"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "focus"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["focus"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "amplitude"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["amplitude"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "date_transaction"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "turnover_volume"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["turnover_volume"] = Core.Array{Core.Int64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "opening_price"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["opening_price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "close_price"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["close_price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "low_price"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["low_price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "high_price"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["high_price"] = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "MarketTiming_Parameter"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["MarketTiming_Parameter"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "PickStock_Parameter"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["PickStock_Parameter"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "SizePosition_Parameter"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["SizePosition_Parameter"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "PickStock_ticker"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["PickStock_ticker"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end

                                                # 做空（Short Selling）記錄;
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "index") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["index"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["index"], Core.Int64(value["Short_Selling_date_transaction"][j][6]));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "direction") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["direction"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["direction"], Base.string(value["Short_Selling_date_transaction"][j][2]));
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "price") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["price"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["price"], Core.Float64(value["Short_Selling_date_transaction"][j][3]));
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "SizePosition") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["SizePosition"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["SizePosition"], value["Short_Selling_date_transaction"][j][4]);
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "focus") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["focus"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["focus"], Core.Float64(Statistics.mean([Core.Float64(value["Short_Selling_date_transaction"][j][9]), Core.Float64(value["Short_Selling_date_transaction"][j][10]), Core.Float64(value["Short_Selling_date_transaction"][j][11]), Core.Float64(value["Short_Selling_date_transaction"][j][12])])));
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "amplitude") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["amplitude"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["amplitude"], Core.Float64(Statistics.std([Core.Float64(value["Short_Selling_date_transaction"][j][9]), Core.Float64(value["Short_Selling_date_transaction"][j][10]), Core.Float64(value["Short_Selling_date_transaction"][j][11]), Core.Float64(value["Short_Selling_date_transaction"][j][12])]; corrected = false)));
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "date_transaction") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["date_transaction"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["date_transaction"], value["Short_Selling_date_transaction"][j][1]);
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "turnover_volume") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["turnover_volume"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["turnover_volume"], Core.Int64(value["Short_Selling_date_transaction"][j][8]));
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "opening_price") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["opening_price"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["opening_price"], Core.Float64(value["Short_Selling_date_transaction"][j][9]));
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "close_price") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["close_price"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["close_price"], Core.Float64(value["Short_Selling_date_transaction"][j][10]));
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "low_price") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["low_price"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["low_price"], Core.Float64(value["Short_Selling_date_transaction"][j][11]));
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "high_price") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["high_price"]) <: Core.Array
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["high_price"], Core.Float64(value["Short_Selling_date_transaction"][j][12]));
                                                end

                                                # 記錄該輪對衝交易的回撤值序列;
                                                if !(Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "drawdown"))
                                                    data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["drawdown"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "drawdown") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["drawdown"]) <: Core.Array
                                                    if Base.string(value["Short_Selling_date_transaction"][j][2]) === "sell"
                                                        Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["drawdown"], Base.missing);  # Base.missing;  # Core.nothing;  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                        # if Base.haskey(value, "drawdown")
                                                        #     # Base.isa(value, Base.Dict) && Base.haskey(value, "drawdown") && Base.typeof(value["drawdown"]) <: Core.Array
                                                        #     Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["drawdown"], value["drawdown"]);  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                        # else
                                                        #     Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["drawdown"], Base.missing);  # Base.missing;  # Core.nothing;  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                        # end
                                                    end
                                                    if Base.string(value["Short_Selling_date_transaction"][j][2]) === "buy"
                                                        if Base.haskey(value, "drawdown")
                                                            # Base.isa(value, Base.Dict) && Base.haskey(value, "drawdown") && Base.typeof(value["drawdown"]) <: Core.Array
                                                            Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["drawdown"], value["drawdown"]);  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                        else
                                                            Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["drawdown"], Base.missing);  # Base.missing;  # Core.nothing;  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                        end
                                                    end
                                                end

                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "MarketTiming_Parameter") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["MarketTiming_Parameter"]) <: Core.Array
                                                    MarketTiming_Parameter_Index = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                    if Base.haskey(stepping_sequence_Array[i], "training_MarketTiming_Parameter") && Base.isa(stepping_sequence_Array[i]["training_MarketTiming_Parameter"], Base.Dict)
                                                        if Base.haskey(stepping_sequence_Array[i]["training_MarketTiming_Parameter"], key) && Base.isa(stepping_sequence_Array[i]["training_MarketTiming_Parameter"][key], Base.Dict)
                                                            if Base.haskey(stepping_sequence_Array[i]["training_MarketTiming_Parameter"][key], "Short_Selling") && ((Base.typeof(stepping_sequence_Array[i]["training_MarketTiming_Parameter"][key]["Short_Selling"]) <: Core.Array) || (Base.typeof(stepping_sequence_Array[i]["training_MarketTiming_Parameter"][key]["Short_Selling"]) <: Base.Vector)) && Core.Int64(Base.length(stepping_sequence_Array[i]["training_MarketTiming_Parameter"][key]["Short_Selling"])) > Core.Int64(0)
                                                                k = Core.Int64(0);
                                                                for k = Core.Int64(1):Core.Int64(Base.length(stepping_sequence_Array[i]["training_MarketTiming_Parameter"][key]["Short_Selling"]))
                                                                    Base.push!(MarketTiming_Parameter_Index, stepping_sequence_Array[i]["training_MarketTiming_Parameter"][key]["Short_Selling"][k]);
                                                                end
                                                                k = Core.nothing;
                                                            end
                                                        end
                                                    end
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["MarketTiming_Parameter"], MarketTiming_Parameter_Index);
                                                    MarketTiming_Parameter_Index = Core.nothing;
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "PickStock_Parameter") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["PickStock_Parameter"]) <: Core.Array
                                                    PickStock_Parameter_Index = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                    if Base.haskey(stepping_sequence_Array[i], "training_PickStock_Parameter") && Base.isa(stepping_sequence_Array[i]["training_PickStock_Parameter"], Base.Dict)
                                                        if Base.haskey(stepping_sequence_Array[i]["training_PickStock_Parameter"], "Short_Selling") && ((Base.typeof(stepping_sequence_Array[i]["training_PickStock_Parameter"]["Short_Selling"]) <: Core.Array) || (Base.typeof(stepping_sequence_Array[i]["training_PickStock_Parameter"]["Short_Selling"]) <: Base.Vector)) && Core.Int64(Base.length(stepping_sequence_Array[i]["training_PickStock_Parameter"]["Short_Selling"])) > Core.Int64(0)
                                                            k = Core.Int64(0);
                                                            for k = Core.Int64(1):Core.Int64(Base.length(stepping_sequence_Array[i]["training_PickStock_Parameter"]["Short_Selling"]))
                                                                Base.push!(PickStock_Parameter_Index, stepping_sequence_Array[i]["training_PickStock_Parameter"]["Short_Selling"][k]);
                                                            end
                                                            k = Core.nothing;
                                                        end
                                                    end
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["PickStock_Parameter"], PickStock_Parameter_Index);
                                                    PickStock_Parameter_Index = Core.nothing;
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "SizePosition_Parameter") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["SizePosition_Parameter"]) <: Core.Array
                                                    SizePosition_Parameter_Index = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                    if Base.haskey(stepping_sequence_Array[i], "training_SizePosition_Parameter") && ((Base.typeof(stepping_sequence_Array[i]["training_SizePosition_Parameter"]) <: Core.Array) || (Base.typeof(stepping_sequence_Array[i]["training_SizePosition_Parameter"]) <: Base.Vector))
                                                        if (Base.length(stepping_sequence_Array[i]["training_SizePosition_Parameter"]) >= 1) && Base.isa(stepping_sequence_Array[i]["training_SizePosition_Parameter"][1], Base.Dict)
                                                            if Base.haskey(stepping_sequence_Array[i]["training_SizePosition_Parameter"][1], key) && Base.isa(stepping_sequence_Array[i]["training_SizePosition_Parameter"][1][key], Base.Dict)
                                                                if Base.haskey(stepping_sequence_Array[i]["training_SizePosition_Parameter"][1][key], "Short_Selling")
                                                                    if Base.length(SizePosition_Parameter_Index) >= 1
                                                                        SizePosition_Parameter_Index[1] = stepping_sequence_Array[i]["training_SizePosition_Parameter"][1][key]["Short_Selling"];
                                                                    elseif Base.length(SizePosition_Parameter_Index) === 0
                                                                        Base.push!(SizePosition_Parameter_Index, stepping_sequence_Array[i]["training_SizePosition_Parameter"][1][key]["Short_Selling"]);  # 使用 push! 函數在數組末尾追加推入新元素;
                                                                    else
                                                                    end
                                                                end
                                                            end
                                                        end
                                                        if (Base.length(stepping_sequence_Array[i]["training_SizePosition_Parameter"]) >= 2) && Base.isa(stepping_sequence_Array[i]["training_SizePosition_Parameter"][2], Base.Dict)
                                                            if Base.haskey(stepping_sequence_Array[i]["training_SizePosition_Parameter"][2], key) && Base.isa(stepping_sequence_Array[i]["training_SizePosition_Parameter"][2][key], Base.Dict)
                                                                if Base.haskey(stepping_sequence_Array[i]["training_SizePosition_Parameter"][2][key], "Short_Selling")
                                                                    if Base.length(SizePosition_Parameter_Index) >= 2
                                                                        SizePosition_Parameter_Index[2] = stepping_sequence_Array[i]["training_SizePosition_Parameter"][2][key]["Short_Selling"];
                                                                    elseif Base.length(SizePosition_Parameter_Index) === 1
                                                                        Base.push!(SizePosition_Parameter_Index, stepping_sequence_Array[i]["training_SizePosition_Parameter"][2][key]["Short_Selling"]);
                                                                    elseif Base.length(SizePosition_Parameter_Index) === 0
                                                                        Base.push!(SizePosition_Parameter_Index, Base.missing);  # Core.nothing;
                                                                        Base.push!(SizePosition_Parameter_Index, stepping_sequence_Array[i]["training_SizePosition_Parameter"][2][key]["Short_Selling"]);  # 使用 push! 函數在數組末尾追加推入新元素;
                                                                    else
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["SizePosition_Parameter"], SizePosition_Parameter_Index);
                                                    SizePosition_Parameter_Index = Core.nothing;
                                                end
                                                if Base.haskey(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "PickStock_ticker") && Base.typeof(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["PickStock_ticker"]) <: Core.Array
                                                    PickStock_ticker_Index = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();
                                                    if Base.haskey(stepping_sequence_Array[i], "training_PickStock_ticker_symbol") && ((Base.typeof(stepping_sequence_Array[i]["training_PickStock_ticker_symbol"]) <: Core.Array) || (Base.typeof(stepping_sequence_Array[i]["training_PickStock_ticker_symbol"]) <: Base.Vector)) && Core.Int64(Base.length(stepping_sequence_Array[i]["training_PickStock_ticker_symbol"])) > Core.Int64(0)
                                                        k = Core.Int64(0);
                                                        for k = Core.Int64(1):Core.Int64(Base.length(stepping_sequence_Array[i]["training_PickStock_ticker_symbol"]))
                                                            Base.push!(PickStock_ticker_Index, stepping_sequence_Array[i]["training_PickStock_ticker_symbol"][k]);
                                                        end
                                                        k = Core.nothing;
                                                    end
                                                    Base.push!(data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["PickStock_ticker"], PickStock_ticker_Index);
                                                    PickStock_ticker_Index = Core.nothing;
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        # 交易信息序列的空值，刪除未曾交易過的股票數據;
        data_transaction_sequence_Dict_2 = Base.Dict{Core.String, Core.Any}(key => value for (key, value) in data_transaction_sequence_Dict);  # 使用 Julia 字典（Dict）的推導式，創建副本;
        for (key, value) in data_transaction_sequence_Dict_2
            if Base.isa(value, Base.Dict)
                if Base.haskey(value, "Long_Position") && Base.isa(value["Long_Position"], Base.Dict) && Core.Int64(Base.length(value["Long_Position"])) <= Core.Int64(0)
                    Base.delete!(data_transaction_sequence_Dict[Base.string(key)], "Long_Position");  # 刪除：data_transaction_sequence_Dict 字典（Dict）中的鍵值對：key:value ;
                end
                if Base.haskey(value, "Long_Position") && Base.isa(value["Long_Position"], Base.Dict) && Core.Int64(Base.length(value["Long_Position"])) > Core.Int64(0)
                    if (Base.haskey(value["Long_Position"], "index") && (Base.typeof(value["Long_Position"]["index"]) <: Core.Array || Base.typeof(value["Long_Position"]["index"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position"]["index"])) === Core.Int64(0)) && (Base.haskey(value["Long_Position"], "direction") && (Base.typeof(value["Long_Position"]["direction"]) <: Core.Array || Base.typeof(value["Long_Position"]["direction"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position"]["direction"])) === Core.Int64(0)) && (Base.haskey(value["Long_Position"], "price") && (Base.typeof(value["Long_Position"]["price"]) <: Core.Array || Base.typeof(value["Long_Position"]["price"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position"]["price"])) === Core.Int64(0)) && (Base.haskey(value["Long_Position"], "SizePosition") && (Base.typeof(value["Long_Position"]["SizePosition"]) <: Core.Array || Base.typeof(value["Long_Position"]["SizePosition"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position"]["SizePosition"])) === Core.Int64(0)) && (Base.haskey(value["Long_Position"], "focus") && (Base.typeof(value["Long_Position"]["focus"]) <: Core.Array || Base.typeof(value["Long_Position"]["focus"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position"]["focus"])) === Core.Int64(0)) && (Base.haskey(value["Long_Position"], "amplitude") && (Base.typeof(value["Long_Position"]["amplitude"]) <: Core.Array || Base.typeof(value["Long_Position"]["amplitude"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position"]["amplitude"])) === Core.Int64(0)) && (Base.haskey(value["Long_Position"], "date_transaction") && (Base.typeof(value["Long_Position"]["date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position"]["date_transaction"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position"]["date_transaction"])) === Core.Int64(0)) && (Base.haskey(value["Long_Position"], "turnover_volume") && (Base.typeof(value["Long_Position"]["turnover_volume"]) <: Core.Array || Base.typeof(value["Long_Position"]["turnover_volume"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position"]["turnover_volume"])) === Core.Int64(0)) && (Base.haskey(value["Long_Position"], "opening_price") && (Base.typeof(value["Long_Position"]["opening_price"]) <: Core.Array || Base.typeof(value["Long_Position"]["opening_price"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position"]["opening_price"])) === Core.Int64(0)) && (Base.haskey(value["Long_Position"], "close_price") && (Base.typeof(value["Long_Position"]["close_price"]) <: Core.Array || Base.typeof(value["Long_Position"]["close_price"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position"]["close_price"])) === Core.Int64(0)) && (Base.haskey(value["Long_Position"], "low_price") && (Base.typeof(value["Long_Position"]["low_price"]) <: Core.Array || Base.typeof(value["Long_Position"]["low_price"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position"]["low_price"])) === Core.Int64(0)) && (Base.haskey(value["Long_Position"], "high_price") && (Base.typeof(value["Long_Position"]["high_price"]) <: Core.Array || Base.typeof(value["Long_Position"]["high_price"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position"]["high_price"])) === Core.Int64(0))
                        Base.delete!(data_transaction_sequence_Dict[Base.string(key)], "Long_Position");  # 刪除：data_transaction_sequence_Dict 字典（Dict）中的鍵值對：key:value ;
                    end
                end
                if Base.haskey(value, "Short_Selling") && Base.isa(value["Short_Selling"], Base.Dict) && Core.Int64(Base.length(value["Short_Selling"])) <= Core.Int64(0)
                    Base.delete!(data_transaction_sequence_Dict[Base.string(key)], "Short_Selling");  # 刪除：data_transaction_sequence_Dict 字典（Dict）中的鍵值對：key:value ;
                end
                if Base.haskey(value, "Short_Selling") && Base.isa(value["Short_Selling"], Base.Dict) && Core.Int64(Base.length(value["Short_Selling"])) > Core.Int64(0)
                    if (Base.haskey(value["Short_Selling"], "index") && (Base.typeof(value["Short_Selling"]["index"]) <: Core.Array || Base.typeof(value["Short_Selling"]["index"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling"]["index"])) === Core.Int64(0)) && (Base.haskey(value["Short_Selling"], "direction") && (Base.typeof(value["Short_Selling"]["direction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["direction"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling"]["direction"])) === Core.Int64(0)) && (Base.haskey(value["Short_Selling"], "price") && (Base.typeof(value["Short_Selling"]["price"]) <: Core.Array || Base.typeof(value["Short_Selling"]["price"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling"]["price"])) === Core.Int64(0)) && (Base.haskey(value["Short_Selling"], "SizePosition") && (Base.typeof(value["Short_Selling"]["SizePosition"]) <: Core.Array || Base.typeof(value["Short_Selling"]["SizePosition"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling"]["SizePosition"])) === Core.Int64(0)) && (Base.haskey(value["Short_Selling"], "focus") && (Base.typeof(value["Short_Selling"]["focus"]) <: Core.Array || Base.typeof(value["Short_Selling"]["focus"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling"]["focus"])) === Core.Int64(0)) && (Base.haskey(value["Short_Selling"], "amplitude") && (Base.typeof(value["Short_Selling"]["amplitude"]) <: Core.Array || Base.typeof(value["Short_Selling"]["amplitude"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling"]["amplitude"])) === Core.Int64(0)) && (Base.haskey(value["Short_Selling"], "date_transaction") && (Base.typeof(value["Short_Selling"]["date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["date_transaction"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling"]["date_transaction"])) === Core.Int64(0)) && (Base.haskey(value["Short_Selling"], "turnover_volume") && (Base.typeof(value["Short_Selling"]["turnover_volume"]) <: Core.Array || Base.typeof(value["Short_Selling"]["turnover_volume"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling"]["turnover_volume"])) === Core.Int64(0)) && (Base.haskey(value["Short_Selling"], "opening_price") && (Base.typeof(value["Short_Selling"]["opening_price"]) <: Core.Array || Base.typeof(value["Short_Selling"]["opening_price"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling"]["opening_price"])) === Core.Int64(0)) && (Base.haskey(value["Short_Selling"], "close_price") && (Base.typeof(value["Short_Selling"]["close_price"]) <: Core.Array || Base.typeof(value["Short_Selling"]["close_price"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling"]["close_price"])) === Core.Int64(0)) && (Base.haskey(value["Short_Selling"], "low_price") && (Base.typeof(value["Short_Selling"]["low_price"]) <: Core.Array || Base.typeof(value["Short_Selling"]["low_price"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling"]["low_price"])) === Core.Int64(0)) && (Base.haskey(value["Short_Selling"], "high_price") && (Base.typeof(value["Short_Selling"]["high_price"]) <: Core.Array || Base.typeof(value["Short_Selling"]["high_price"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling"]["high_price"])) === Core.Int64(0))
                        Base.delete!(data_transaction_sequence_Dict[Base.string(key)], "Short_Selling");  # 刪除：data_transaction_sequence_Dict 字典（Dict）中的鍵值對：key:value ;
                    end
                end
                # if Core.Int64(Base.length(value)) <= Core.Int64(0)
                #     Base.delete!(data_transaction_sequence_Dict, key);  # 刪除：data_transaction_sequence_Dict 字典（Dict）中的鍵值對：key:value ;
                # end
            end
        end
        data_transaction_sequence_Dict_2 = Core.nothing;  # 釋放内存;
        data_transaction_sequence_Dict_2 = Base.Dict{Core.String, Core.Any}(key => value for (key, value) in data_transaction_sequence_Dict);  # 使用 Julia 字典（Dict）的推導式，創建副本;
        for (key, value) in data_transaction_sequence_Dict_2
            if Base.isa(value, Base.Dict)
                if Core.Int64(Base.length(value)) <= Core.Int64(0)
                    Base.delete!(data_transaction_sequence_Dict, key);  # 刪除：data_transaction_sequence_Dict 字典（Dict）中的鍵值對：key:value ;
                end
            end
        end
        data_transaction_sequence_Dict_2 = Core.nothing;  # 釋放内存;

        return_stepping_Dict["transaction_sequence"] = data_transaction_sequence_Dict;

        profit_paired_data_transaction_sequence_Dict = Base.Dict{Core.String, Core.Any}();  # 記錄按規則篩選股票按照擇時規則兩次對衝交易獲利信息的序列;
        # if Base.isa(data_transaction_sequence_Dict, Base.Dict) && Core.Int64(Base.length(data_transaction_sequence_Dict)) > Core.Int64(0)
        #     for (key, value) in data_transaction_sequence_Dict
        #         # 做多（Long Position）記錄;
        #         if Base.isa(value, Base.Dict) && Base.haskey(value, "Long_Position")
        #             if !(Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)))
        #                 profit_paired_data_transaction_sequence_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}("Long_Position" => Base.Dict{Core.String, Core.Any}());
        #             elseif Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && (!(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Long_Position")))
        #                 profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"] = Base.Dict{Core.String, Core.Any}();
        #             else
        #             end
        #             if Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Long_Position") && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], Base.Dict) && Core.Int64(Base.length(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"])) <= Core.Int64(0)
        #                 profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["Long_Position_profit_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 每兩次對衝交易價格差值利潤，向量;
        #                 profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["Long_Position_price_amplitude_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 兩次對衝交易日成交價振幅平方和，向量;
        #                 profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["Long_Position_volume_turnover_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 兩次對衝交易日成交量（換手率）向量;
        #                 profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["Long_Position_date_transaction_between"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 兩次對衝交易間隔日長，向量;
        #                 profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["drawdown"] = Core.Array{Core.Any, 1}();  # 記錄每輪對衝交易的回撤值序列;
        #             end
        #         end
        #         # 做空（Short Selling）記錄;
        #         if Base.isa(value, Base.Dict) && Base.haskey(value, "Short_Selling")
        #             if !(Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)))
        #                 profit_paired_data_transaction_sequence_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}("Short_Selling" => Base.Dict{Core.String, Core.Any}());
        #             elseif Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && (!(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Short_Selling")))
        #                 profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"] = Base.Dict{Core.String, Core.Any}();
        #             else
        #             end
        #             if Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Short_Selling") && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], Base.Dict) && Core.Int64(Base.length(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"])) <= Core.Int64(0)
        #                 profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["Short_Selling_profit_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 每兩次對衝交易價格差值利潤，向量;
        #                 profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["Short_Selling_price_amplitude_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 兩次對衝交易日成交價振幅平方和，向量;
        #                 profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["Short_Selling_volume_turnover_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 兩次對衝交易日成交量（換手率）向量;
        #                 profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["Short_Selling_date_transaction_between"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 兩次對衝交易間隔日長，向量;
        #                 profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["drawdown"] = Core.Array{Core.Any, 1}();  # 記錄每輪對衝交易的回撤值序列;
        #             end
        #         end
        #     end
        # end
        if Base.isa(data_transaction_sequence_Dict, Base.Dict) && Core.Int64(Base.length(data_transaction_sequence_Dict)) > Core.Int64(0)
            for (key, value) in data_transaction_sequence_Dict
                # 做多（Long Position）記錄;
                if Base.isa(value, Base.Dict) && Base.haskey(value, "Long_Position") && Base.isa(value["Long_Position"], Base.Dict) && Core.Int64(Base.length(value["Long_Position"])) > Core.Int64(0)

                    maximum_dates_transaction_sequence = Core.Int64(0);  # 各股票裏的最長交易天數;
                    minimum_dates_transaction_sequence = Core.Int64(0);  # 各股票裏的最短交易天數;
                    dates_transaction_sequence_Array = Core.Array{Core.Int64, 1}();
                    # 遍歷字典的鍵:值對;
                    for (key_1, value_1) in value["Long_Position"]
                        # println("Key: $key_1, Value: $value_1");
                        if Base.isa(value_1, Base.Dict)
                            if Base.haskey(value_1, "index") && Base.typeof(value_1["index"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["index"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["index"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["index"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "direction") && Base.typeof(value_1["direction"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["direction"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["direction"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["direction"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "price") && Base.typeof(value_1["price"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["price"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["price"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "SizePosition") && Base.typeof(value_1["SizePosition"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["SizePosition"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["SizePosition"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["SizePosition"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "focus") && Base.typeof(value_1["focus"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["focus"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["focus"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["focus"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "amplitude") && Base.typeof(value_1["amplitude"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["amplitude"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["amplitude"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["amplitude"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "date_transaction") && Base.typeof(value_1["date_transaction"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["date_transaction"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["date_transaction"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["date_transaction"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "turnover_volume") && Base.typeof(value_1["turnover_volume"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["turnover_volume"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["turnover_volume"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["turnover_volume"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "opening_price") && Base.typeof(value_1["opening_price"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["opening_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["opening_price"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["opening_price"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "close_price") && Base.typeof(value_1["close_price"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["close_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["close_price"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["close_price"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "low_price") && Base.typeof(value_1["low_price"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["low_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["low_price"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["low_price"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "high_price") && Base.typeof(value_1["high_price"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["high_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["high_price"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["high_price"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                        end
                    end
                    # println(maximum_dates_transaction_sequence);
                    if Base.length(dates_transaction_sequence_Array) > 0
                        minimum_dates_transaction_sequence_2 = Core.Int64(Base.findmin(dates_transaction_sequence_Array)[1]);
                        minimum_dates_transaction_sequence *= Core.Int64(0);
                        minimum_dates_transaction_sequence += Core.Int64(minimum_dates_transaction_sequence_2);
                    end
                    # println(minimum_dates_transaction_sequence);
                    dates_transaction_sequence_Array = Core.nothing;  # 釋放内存;

                    for i = Core.Int64(1):Core.Int64(minimum_dates_transaction_sequence)
                        # 判斷：i 是偶數，還是奇數，符號：% 表示除法取餘數，若餘數爲 0 則表示可以被 2 整除，即爲偶數;
                        if Core.Int64(i) % Core.Int64(2) === Core.Int64(0)
                            for (key_1, value_1) in value["Long_Position"]
                                if Base.haskey(value_1, "direction") && Base.typeof(value_1["direction"]) <: Core.Array
                                    if Base.string(value_1["direction"][Core.Int64(i)]) === "sell" && Base.string(value_1["direction"][Core.Int64(Core.Int64(i) - Core.Int64(1))]) === "buy"
                                        if Base.haskey(value_1, "price") && Base.typeof(value_1["price"]) <: Core.Array
                                            if Core.Int64(i) <= Core.Int64(Base.length(value_1["price"]))
                                                if Base.haskey(value_1, "SizePosition") && Base.typeof(value_1["SizePosition"]) <: Core.Array
                                                    if Core.Int64(i) <= Core.Int64(Base.length(value_1["SizePosition"]))
                                                        diff_price_profit = Core.Float64(Core.Float64(Core.Float64(value_1["price"][Core.Int64(i)]) * Core.Float64(value_1["SizePosition"][Core.Int64(i)][1]) * Core.Float64(value_1["SizePosition"][Core.Int64(i)][2])) - Core.Float64(Core.Float64(value_1["price"][Core.Int64(Core.Int64(i) - Core.Int64(1))]) * Core.Float64(value_1["SizePosition"][Core.Int64(Core.Int64(i) - Core.Int64(1))][1]) * Core.Float64(value_1["SizePosition"][Core.Int64(Core.Int64(i) - Core.Int64(1))][2])));
                                                        # diff_price_profit = Core.Float64(Core.Float64(Core.Float64(Base.abs(Core.Float64(value_1["price"][Core.Int64(i)]))) * Core.Float64(value_1["SizePosition"][Core.Int64(i)])) - Core.Float64(Core.Float64(Base.abs(Core.Float64(value_1["price"][Core.Int64(Core.Int64(i) - Core.Int64(1))]))) * Core.Float64(value_1["SizePosition"][Core.Int64(Core.Int64(i) - Core.Int64(1))])));
                                                    else
                                                        diff_price_profit = Core.Float64(Core.Float64(value_1["price"][Core.Int64(i)]) - Core.Float64(value_1["price"][Core.Int64(Core.Int64(i) - Core.Int64(1))]));
                                                        # diff_price_profit = Core.Float64(Core.Float64(Base.abs(Core.Float64(value_1["price"][Core.Int64(i)]))) - Core.Float64(Base.abs(Core.Float64(value_1["price"][Core.Int64(Core.Int64(i) - Core.Int64(1))]))));
                                                    end
                                                else
                                                    diff_price_profit = Core.Float64(Core.Float64(value_1["price"][Core.Int64(i)]) - Core.Float64(value_1["price"][Core.Int64(Core.Int64(i) - Core.Int64(1))]));
                                                    # diff_price_profit = Core.Float64(Core.Float64(Base.abs(Core.Float64(value_1["price"][Core.Int64(i)]))) - Core.Float64(Base.abs(Core.Float64(value_1["price"][Core.Int64(Core.Int64(i) - Core.Int64(1))]))));
                                                end
                                                if !(Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}("Long_Position" => Base.Dict{Core.String, Core.Any}());
                                                elseif Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && (!(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Long_Position")))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"] = Base.Dict{Core.String, Core.Any}();
                                                else
                                                end
                                                if Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Long_Position") && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], Base.Dict)
                                                    if !(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "Long_Position_profit_date_transaction"))
                                                        profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["Long_Position_profit_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 每兩次對衝交易價格差值利潤，向量;
                                                    end
                                                    if Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "Long_Position_profit_date_transaction") && Base.typeof(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["Long_Position_profit_date_transaction"]) <: Core.Array
                                                        Base.push!(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["Long_Position_profit_date_transaction"], Core.Float64(diff_price_profit));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                    end
                                                end
                                            end
                                        end
                                        if Base.haskey(value_1, "index") && Base.typeof(value_1["index"]) <: Core.Array
                                            if Core.Int64(i) <= Core.Int64(Base.length(value_1["index"]))
                                                diff_date = Core.Int64(Core.Int64(value_1["index"][Core.Int64(i)]) - Core.Int64(value_1["index"][Core.Int64(Core.Int64(i) - Core.Int64(1))]));
                                                if !(Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}("Long_Position" => Base.Dict{Core.String, Core.Any}());
                                                elseif Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && (!(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Long_Position")))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"] = Base.Dict{Core.String, Core.Any}();
                                                else
                                                end
                                                if Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Long_Position") && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], Base.Dict)
                                                    if !(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "Long_Position_date_transaction_between"))
                                                        profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["Long_Position_date_transaction_between"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 兩次對衝交易間隔日長，向量;
                                                    end
                                                    if Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "Long_Position_date_transaction_between") && Base.typeof(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["Long_Position_date_transaction_between"]) <: Core.Array
                                                        Base.push!(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["Long_Position_date_transaction_between"], Core.Int64(diff_date));
                                                    end
                                                end
                                            end
                                        end
                                        if Base.haskey(value_1, "amplitude") && Base.typeof(value_1["amplitude"]) <: Core.Array
                                            if Core.Int64(i) <= Core.Int64(Base.length(value_1["amplitude"]))
                                                synthetic_amplitude = Core.Float64(Base.sqrt(Core.Float64(value_1["amplitude"][Core.Int64(i)])^2 + Core.Float64(value_1["amplitude"][Core.Int64(Core.Int64(i) - Core.Int64(1))])^2));
                                                if !(Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}("Long_Position" => Base.Dict{Core.String, Core.Any}());
                                                elseif Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && (!(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Long_Position")))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"] = Base.Dict{Core.String, Core.Any}();
                                                else
                                                end
                                                if Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Long_Position") && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], Base.Dict)
                                                    if !(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "Long_Position_price_amplitude_date_transaction"))
                                                        profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["Long_Position_price_amplitude_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 兩次對衝交易日成交價振幅平方和，向量;
                                                    end
                                                    if Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "Long_Position_price_amplitude_date_transaction") && Base.typeof(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["Long_Position_price_amplitude_date_transaction"]) <: Core.Array
                                                        Base.push!(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["Long_Position_price_amplitude_date_transaction"], Core.Float64(synthetic_amplitude));
                                                    end
                                                end
                                            end
                                        end
                                        if Base.haskey(value_1, "turnover_volume") && Base.typeof(value_1["turnover_volume"]) <: Core.Array
                                            if Core.Int64(i) <= Core.Int64(Base.length(value_1["turnover_volume"]))
                                                volume_mean = Core.Float64(Core.Float64(Core.Float64(value_1["turnover_volume"][Core.Int64(i)]) + Core.Float64(value_1["turnover_volume"][Core.Int64(Core.Int64(i) - Core.Int64(1))])) / 2);
                                                if !(Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}("Long_Position" => Base.Dict{Core.String, Core.Any}());
                                                elseif Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && (!(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Long_Position")))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"] = Base.Dict{Core.String, Core.Any}();
                                                else
                                                end
                                                if Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Long_Position") && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], Base.Dict)
                                                    if !(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "Long_Position_volume_turnover_date_transaction"))
                                                        profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["Long_Position_volume_turnover_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 兩次對衝交易日成交量（換手率）向量;
                                                    end
                                                    if Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "Long_Position_volume_turnover_date_transaction") && Base.typeof(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["Long_Position_volume_turnover_date_transaction"]) <: Core.Array
                                                        Base.push!(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["Long_Position_volume_turnover_date_transaction"], Core.Float64(volume_mean));
                                                    end
                                                end
                                            end
                                        end
                                        if Base.haskey(value_1, "drawdown") && Base.typeof(value_1["drawdown"]) <: Core.Array
                                            if Core.Int64(i) <= Core.Int64(Base.length(value_1["drawdown"]))
                                                drawdown_sequence_Array = value_1["drawdown"][Core.Int64(i)];
                                                # if Base.ismissing(value_1["drawdown"][Core.Int64(i)]) || Base.isnothing(value_1["drawdown"][Core.Int64(i)])
                                                #     drawdown_sequence_Array = Base.missing;  # Base.missing;  # Core.nothing;
                                                # else
                                                #     drawdown_sequence_Array = value_1["drawdown"][Core.Int64(i)];
                                                # end
                                                if !(Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}("Long_Position" => Base.Dict{Core.String, Core.Any}());
                                                elseif Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && (!(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Long_Position")))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"] = Base.Dict{Core.String, Core.Any}();
                                                else
                                                end
                                                if Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Long_Position") && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], Base.Dict)
                                                    if !(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "drawdown"))
                                                        profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["drawdown"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 每輪對衝交易的回撤值序列向量;
                                                    end
                                                    if Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"], "drawdown") && Base.typeof(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["drawdown"]) <: Core.Array
                                                        Base.push!(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Long_Position"]["drawdown"], drawdown_sequence_Array);
                                                    end
                                                end
                                                drawdown_sequence_Array = Core.nothing;  # 釋放内存;
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end

                    maximum_dates_transaction_sequence = Core.nothing;  # 釋放内存;
                    minimum_dates_transaction_sequence = Core.nothing;  # 釋放内存;
                end
                # 做空（Short Selling）記錄;
                if Base.isa(value, Base.Dict) && Base.haskey(value, "Short_Selling") && Base.isa(value["Short_Selling"], Base.Dict) && Core.Int64(Base.length(value["Short_Selling"])) > Core.Int64(0)

                    maximum_dates_transaction_sequence = Core.Int64(0);  # 各股票裏的最長交易天數;
                    minimum_dates_transaction_sequence = Core.Int64(0);  # 各股票裏的最短交易天數;
                    dates_transaction_sequence_Array = Core.Array{Core.Int64, 1}();
                    # 遍歷字典的鍵:值對;
                    for (key_1, value_1) in value["Short_Selling"]
                        # println("Key: $key_1, Value: $value_1");
                        if Base.isa(value_1, Base.Dict)
                            if Base.haskey(value_1, "index") && Base.typeof(value_1["index"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["index"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["index"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["index"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "direction") && Base.typeof(value_1["direction"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["direction"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["direction"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["direction"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "price") && Base.typeof(value_1["price"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["price"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["price"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "SizePosition") && Base.typeof(value_1["SizePosition"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["SizePosition"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["SizePosition"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["SizePosition"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "focus") && Base.typeof(value_1["focus"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["focus"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["focus"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["focus"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "amplitude") && Base.typeof(value_1["amplitude"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["amplitude"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["amplitude"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["amplitude"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "date_transaction") && Base.typeof(value_1["date_transaction"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["date_transaction"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["date_transaction"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["date_transaction"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "turnover_volume") && Base.typeof(value_1["turnover_volume"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["turnover_volume"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["turnover_volume"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["turnover_volume"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "opening_price") && Base.typeof(value_1["opening_price"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["opening_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["opening_price"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["opening_price"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "close_price") && Base.typeof(value_1["close_price"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["close_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["close_price"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["close_price"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "low_price") && Base.typeof(value_1["low_price"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["low_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["low_price"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["low_price"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                            if Base.haskey(value_1, "high_price") && Base.typeof(value_1["high_price"]) <: Core.Array
                                # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                Base.push!(dates_transaction_sequence_Array, Core.Int64(Base.length(value_1["high_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

                                # 篩選最長交易天數;
                                if Core.Int64(Base.length(value_1["high_price"])) > Core.Int64(maximum_dates_transaction_sequence)
                                    maximum_dates_transaction_sequence_2 = Core.Int64(Base.length(value_1["high_price"]));
                                    maximum_dates_transaction_sequence *= Core.Int64(0);
                                    maximum_dates_transaction_sequence += Core.Int64(maximum_dates_transaction_sequence_2);
                                end
                            end
                        end
                    end
                    # println(maximum_dates_transaction_sequence);
                    if Base.length(dates_transaction_sequence_Array) > 0
                        minimum_dates_transaction_sequence_2 = Core.Int64(Base.findmin(dates_transaction_sequence_Array)[1]);
                        minimum_dates_transaction_sequence *= Core.Int64(0);
                        minimum_dates_transaction_sequence += Core.Int64(minimum_dates_transaction_sequence_2);
                    end
                    # println(minimum_dates_transaction_sequence);
                    dates_transaction_sequence_Array = Core.nothing;  # 釋放内存;

                    for i = Core.Int64(1):Core.Int64(minimum_dates_transaction_sequence)
                        # 判斷：i 是偶數，還是奇數，符號：% 表示除法取餘數，若餘數爲 0 則表示可以被 2 整除，即爲偶數;
                        if Core.Int64(i) % Core.Int64(2) === Core.Int64(0)
                            for (key_1, value_1) in value["Short_Selling"]
                                if Base.haskey(value_1, "direction") && Base.typeof(value_1["direction"]) <: Core.Array
                                    if Base.string(value_1["direction"][Core.Int64(i)]) === "sell" && Base.string(value_1["direction"][Core.Int64(Core.Int64(i) - Core.Int64(1))]) === "buy"
                                        if Base.haskey(value_1, "price") && Base.typeof(value_1["price"]) <: Core.Array
                                            if Core.Int64(i) <= Core.Int64(Base.length(value_1["price"]))
                                                if Base.haskey(value_1, "SizePosition") && Base.typeof(value_1["SizePosition"]) <: Core.Array
                                                    if Core.Int64(i) <= Core.Int64(Base.length(value_1["SizePosition"]))
                                                        diff_price_profit = Core.Float64(Core.Float64(Core.Float64(Base.abs(Core.Float64(value_1["price"][Core.Int64(i)]))) * Core.Float64(value_1["SizePosition"][Core.Int64(i)][1]) * Core.Float64(value_1["SizePosition"][Core.Int64(i)][2])) - Core.Float64(Core.Float64(Base.abs(Core.Float64(value_1["price"][Core.Int64(Core.Int64(i) - Core.Int64(1))]))) * Core.Float64(value_1["SizePosition"][Core.Int64(Core.Int64(i) - Core.Int64(1))][1]) * Core.Float64(value_1["SizePosition"][Core.Int64(Core.Int64(i) - Core.Int64(1))][2])));
                                                    else
                                                        diff_price_profit = Core.Float64(Core.Float64(Base.abs(Core.Float64(value_1["price"][Core.Int64(i)]))) - Core.Float64(Base.abs(Core.Float64(value_1["price"][Core.Int64(Core.Int64(i) - Core.Int64(1))]))));
                                                    end
                                                else
                                                    diff_price_profit = Core.Float64(Core.Float64(Base.abs(Core.Float64(value_1["price"][Core.Int64(i)]))) - Core.Float64(Base.abs(Core.Float64(value_1["price"][Core.Int64(Core.Int64(i) - Core.Int64(1))]))));
                                                end
                                                if !(Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}("Short_Selling" => Base.Dict{Core.String, Core.Any}());
                                                elseif Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && (!(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Short_Selling")))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"] = Base.Dict{Core.String, Core.Any}();
                                                else
                                                end
                                                if Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Short_Selling") && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], Base.Dict)
                                                    if !(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "Short_Selling_profit_date_transaction"))
                                                        profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["Short_Selling_profit_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 每兩次對衝交易價格差值利潤，向量;
                                                    end
                                                    if Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "Short_Selling_profit_date_transaction") && Base.typeof(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Core.Array
                                                        Base.push!(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["Short_Selling_profit_date_transaction"], Core.Float64(diff_price_profit));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                                                    end
                                                end
                                            end
                                        end
                                        if Base.haskey(value_1, "index") && Base.typeof(value_1["index"]) <: Core.Array
                                            if Core.Int64(i) <= Core.Int64(Base.length(value_1["index"]))
                                                diff_date = Core.Int64(Core.Int64(value_1["index"][Core.Int64(i)]) - Core.Int64(value_1["index"][Core.Int64(Core.Int64(i) - Core.Int64(1))]));
                                                if !(Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}("Short_Selling" => Base.Dict{Core.String, Core.Any}());
                                                elseif Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && (!(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Short_Selling")))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"] = Base.Dict{Core.String, Core.Any}();
                                                else
                                                end
                                                if Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Short_Selling") && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], Base.Dict)
                                                    if !(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "Short_Selling_date_transaction_between"))
                                                        profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["Short_Selling_date_transaction_between"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 兩次對衝交易間隔日長，向量;
                                                    end
                                                    if Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "Short_Selling_date_transaction_between") && Base.typeof(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["Short_Selling_date_transaction_between"]) <: Core.Array
                                                        Base.push!(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["Short_Selling_date_transaction_between"], Core.Int64(diff_date));
                                                    end
                                                end
                                            end
                                        end
                                        if Base.haskey(value_1, "amplitude") && Base.typeof(value_1["amplitude"]) <: Core.Array
                                            if Core.Int64(i) <= Core.Int64(Base.length(value_1["amplitude"]))
                                                synthetic_amplitude = Core.Float64(Base.sqrt(Core.Float64(value_1["amplitude"][Core.Int64(i)])^2 + Core.Float64(value_1["amplitude"][Core.Int64(Core.Int64(i) - Core.Int64(1))])^2));
                                                if !(Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}("Short_Selling" => Base.Dict{Core.String, Core.Any}());
                                                elseif Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && (!(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Short_Selling")))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"] = Base.Dict{Core.String, Core.Any}();
                                                else
                                                end
                                                if Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Short_Selling") && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], Base.Dict)
                                                    if !(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "Short_Selling_price_amplitude_date_transaction"))
                                                        profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["Short_Selling_price_amplitude_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 兩次對衝交易日成交價振幅平方和，向量;
                                                    end
                                                    if Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "Short_Selling_price_amplitude_date_transaction") && Base.typeof(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["Short_Selling_price_amplitude_date_transaction"]) <: Core.Array
                                                        Base.push!(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["Short_Selling_price_amplitude_date_transaction"], Core.Float64(synthetic_amplitude));
                                                    end
                                                end
                                            end
                                        end
                                        if Base.haskey(value_1, "turnover_volume") && Base.typeof(value_1["turnover_volume"]) <: Core.Array
                                            if Core.Int64(i) <= Core.Int64(Base.length(value_1["turnover_volume"]))
                                                volume_mean = Core.Float64(Core.Float64(Core.Float64(value_1["turnover_volume"][Core.Int64(i)]) + Core.Float64(value_1["turnover_volume"][Core.Int64(Core.Int64(i) - Core.Int64(1))])) / 2);
                                                if !(Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}("Short_Selling" => Base.Dict{Core.String, Core.Any}());
                                                elseif Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && (!(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Short_Selling")))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"] = Base.Dict{Core.String, Core.Any}();
                                                else
                                                end
                                                if Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Short_Selling") && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], Base.Dict)
                                                    if !(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "Short_Selling_volume_turnover_date_transaction"))
                                                        profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["Short_Selling_volume_turnover_date_transaction"] = Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 兩次對衝交易日成交量（換手率）向量;
                                                    end
                                                    if Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "Short_Selling_volume_turnover_date_transaction") && Base.typeof(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["Short_Selling_volume_turnover_date_transaction"]) <: Core.Array
                                                        Base.push!(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["Short_Selling_volume_turnover_date_transaction"], Core.Float64(volume_mean));
                                                    end
                                                end
                                            end
                                        end
                                        if Base.haskey(value_1, "drawdown") && Base.typeof(value_1["drawdown"]) <: Core.Array
                                            if Core.Int64(i) <= Core.Int64(Base.length(value_1["drawdown"]))
                                                drawdown_sequence_Array = value_1["drawdown"][Core.Int64(i)];
                                                # if Base.ismissing(value_1["drawdown"][Core.Int64(i)]) || Base.isnothing(value_1["drawdown"][Core.Int64(i)])
                                                #     drawdown_sequence_Array = Base.missing;  # Base.missing;  # Core.nothing;
                                                # else
                                                #     drawdown_sequence_Array = value_1["drawdown"][Core.Int64(i)];
                                                # end
                                                if !(Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}("Short_Selling" => Base.Dict{Core.String, Core.Any}());
                                                elseif Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && (!(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Short_Selling")))
                                                    profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"] = Base.Dict{Core.String, Core.Any}();
                                                else
                                                end
                                                if Base.haskey(profit_paired_data_transaction_sequence_Dict, Base.string(key)) && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)], Base.Dict) && Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Short_Selling") && Base.isa(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], Base.Dict)
                                                    if !(Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "drawdown"))
                                                        profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["drawdown"] = Core.Array{Core.Any, 1}();  # Core.Array{Core.Union{Dates.Date, Core.String, Core.Float64, Core.Int64, Core.UInt64, Core.Bool, Core.Nothing, Base.Missing}, 1}();  # 每輪對衝交易的回撤值序列向量;
                                                    end
                                                    if Base.haskey(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"], "drawdown") && Base.typeof(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["drawdown"]) <: Core.Array
                                                        Base.push!(profit_paired_data_transaction_sequence_Dict[Base.string(key)]["Short_Selling"]["drawdown"], drawdown_sequence_Array);
                                                    end
                                                end
                                                drawdown_sequence_Array = Core.nothing;  # 釋放内存;
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end

                    maximum_dates_transaction_sequence = Core.nothing;  # 釋放内存;
                    minimum_dates_transaction_sequence = Core.nothing;  # 釋放内存;
                end
            end
        end

        # 交易信息序列的空值，刪除未曾交易過的股票數據;
        profit_paired_data_transaction_sequence_Dict_2 = Base.Dict{Core.String, Core.Any}(key => value for (key, value) in profit_paired_data_transaction_sequence_Dict);  # 使用 Julia 字典（Dict）的推導式，創建副本;
        for (key, value) in profit_paired_data_transaction_sequence_Dict_2
            if Base.isa(value, Base.Dict)
                if Base.haskey(value, "Long_Position") && Base.isa(value["Long_Position"], Base.Dict) && Core.Int64(Base.length(value["Long_Position"])) <= Core.Int64(0)
                    Base.delete!(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Long_Position");  # 刪除：profit_paired_data_transaction_sequence_Dict 字典（Dict）中的鍵值對：key:value ;
                end
                if Base.haskey(value, "Long_Position") && Base.isa(value["Long_Position"], Base.Dict) && Core.Int64(Base.length(value["Long_Position"])) > Core.Int64(0)
                    if (Base.haskey(value["Long_Position"], "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])) === Core.Int64(0)) && (Base.haskey(value["Long_Position"], "Long_Position_price_amplitude_date_transaction") && (Base.typeof(value["Long_Position"]["Long_Position_price_amplitude_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_price_amplitude_date_transaction"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position"]["Long_Position_price_amplitude_date_transaction"])) === Core.Int64(0)) && (Base.haskey(value["Long_Position"], "Long_Position_volume_turnover_date_transaction") && (Base.typeof(value["Long_Position"]["Long_Position_volume_turnover_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_volume_turnover_date_transaction"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position"]["Long_Position_volume_turnover_date_transaction"])) === Core.Int64(0)) && (Base.haskey(value["Long_Position"], "Long_Position_date_transaction_between") && (Base.typeof(value["Long_Position"]["Long_Position_date_transaction_between"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_date_transaction_between"]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position"]["Long_Position_date_transaction_between"])) === Core.Int64(0))
                        Base.delete!(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Long_Position");  # 刪除：profit_paired_data_transaction_sequence_Dict 字典（Dict）中的鍵值對：key:value ;
                    end
                end
                if Base.haskey(value, "Short_Selling") && Base.isa(value["Short_Selling"], Base.Dict) && Core.Int64(Base.length(value["Short_Selling"])) <= Core.Int64(0)
                    Base.delete!(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Short_Selling");  # 刪除：profit_paired_data_transaction_sequence_Dict 字典（Dict）中的鍵值對：key:value ;
                end
                if Base.haskey(value, "Short_Selling") && Base.isa(value["Short_Selling"], Base.Dict) && Core.Int64(Base.length(value["Short_Selling"])) > Core.Int64(0)
                    if (Base.haskey(value["Short_Selling"], "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])) === Core.Int64(0)) && (Base.haskey(value["Short_Selling"], "Short_Selling_price_amplitude_date_transaction") && (Base.typeof(value["Short_Selling"]["Short_Selling_price_amplitude_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_price_amplitude_date_transaction"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_price_amplitude_date_transaction"])) === Core.Int64(0)) && (Base.haskey(value["Short_Selling"], "Short_Selling_volume_turnover_date_transaction") && (Base.typeof(value["Short_Selling"]["Short_Selling_volume_turnover_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_volume_turnover_date_transaction"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_volume_turnover_date_transaction"])) === Core.Int64(0)) && (Base.haskey(value["Short_Selling"], "Short_Selling_date_transaction_between") && (Base.typeof(value["Short_Selling"]["Short_Selling_date_transaction_between"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_date_transaction_between"]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_date_transaction_between"])) === Core.Int64(0))
                        Base.delete!(profit_paired_data_transaction_sequence_Dict[Base.string(key)], "Short_Selling");  # 刪除：profit_paired_data_transaction_sequence_Dict 字典（Dict）中的鍵值對：key:value ;
                    end
                end
                # if Core.Int64(Base.length(value)) <= Core.Int64(0)
                #     Base.delete!(profit_paired_data_transaction_sequence_Dict, key);  # 刪除：profit_paired_data_transaction_sequence_Dict 字典（Dict）中的鍵值對：key:value ;
                # end
            end
        end
        profit_paired_data_transaction_sequence_Dict_2 = Core.nothing;  # 釋放内存;
        profit_paired_data_transaction_sequence_Dict_2 = Base.Dict{Core.String, Core.Any}(key => value for (key, value) in profit_paired_data_transaction_sequence_Dict);  # 使用 Julia 字典（Dict）的推導式，創建副本;
        for (key, value) in profit_paired_data_transaction_sequence_Dict_2
            if Base.isa(value, Base.Dict)
                if Core.Int64(Base.length(value)) <= Core.Int64(0)
                    Base.delete!(profit_paired_data_transaction_sequence_Dict, key);  # 刪除：profit_paired_data_transaction_sequence_Dict 字典（Dict）中的鍵值對：key:value ;
                end
            end
        end
        profit_paired_data_transaction_sequence_Dict_2 = Core.nothing;  # 釋放内存;

        # 交易信息序列匯總求和;
        for (key, value) in profit_paired_data_transaction_sequence_Dict
            if Base.isa(value, Base.Dict)

                if investment_method === "Long_Position_and_Short_Selling" || investment_method === "Long_Position"
                    if Base.haskey(value, "Long_Position") && Base.isa(value["Long_Position"], Base.Dict)

                        # 交易信息序列數據（融資做多 buying long）的匯總求和;
                        profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_number_total"] = Core.nothing;  # Core.Int64(0);  # 對衝交易總次數;
                        profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["maximum_drawdown"] = Core.nothing;  # Core.Float64(0.0);  # 最大回撤值;
                        profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_total"] = Core.nothing;  # Core.Float64(0.0);  # 每兩次對衝交易利潤，纍加總計;
                        profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive"] = Core.nothing;  # Core.Float64(0.0);  # 每兩次對衝交易收益纍加總計;
                        profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative"] = Core.nothing;  # Core.Float64(0.0);  # 每兩次對衝交易損失纍加總計;
                        profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive_probability"] = Core.nothing;  # Core.Float64(0.0);  # 每兩次對衝交易正利潤概率;
                        profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative_probability"] = Core.nothing;  # Core.Float64(0.0);  # 每兩次對衝交易負利潤概率;
                        profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"] = Core.nothing;  # Core.Float64(0.0);  # 兩次對衝交易日成交價振幅平方和，均值;
                        profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"] = Core.nothing;  # Core.Float64(0.0);  # 兩次對衝交易日成交量（換手率）均值;
                        profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_date_transaction_between"] = Core.nothing;  # Core.Float64(0.0);  # 兩次對衝交易間隔日長，均值;
                        # profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["y_Long_Position"] = Core.nothing;  # Core.Float64(0.0);  # 優化目標變量，做多（Long Position），每兩次對衝交易利潤 × 權重，加權纍加總計;

                        if (Base.haskey(value["Long_Position"], "drawdown") && (Base.typeof(value["Long_Position"]["drawdown"]) <: Core.Array || Base.typeof(value["Long_Position"]["drawdown"]) <: Base.Vector))
                            # println(value["Long_Position"]["drawdown"]);
                            if Core.Int64(Base.length(value["Long_Position"]["drawdown"])) > Core.Int64(0) && Core.Int64(Base.findmax([(Base.typeof(value["Long_Position"]["drawdown"][i]) <: Core.Array || Base.typeof(value["Long_Position"]["drawdown"][i]) <: Base.Vector) ? Core.Int64(Base.length(value["Long_Position"]["drawdown"][i])) : (-Base.Inf) for i in 1:Base.length(value["Long_Position"]["drawdown"])])[1]) > Core.Int64(0)
                                # profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["maximum_drawdown"] = Core.Float64(Base.findmin([if ((Base.typeof(value["Long_Position"]["drawdown"][i]) <: Core.Array || Base.typeof(value["Long_Position"]["drawdown"][i]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position"]["drawdown"][i])) > Core.Int64(0)) Core.Float64(Base.findmin(value["Long_Position"]["drawdown"][i])[1]) else (+Base.Inf) end for i in 1:Base.length(value["Long_Position"]["drawdown"])])[1]);  # 每兩次對衝交易之間的回撤值，纍加總計;
                                # profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["maximum_drawdown"] = Core.Float64(Base.findmin([((Base.typeof(value["Long_Position"]["drawdown"][i]) <: Core.Array || Base.typeof(value["Long_Position"]["drawdown"][i]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position"]["drawdown"][i])) > Core.Int64(0)) ? Core.Float64(Base.findmin(value["Long_Position"]["drawdown"][i])[1]) : (+Base.Inf) for i in 1:Base.length(value["Long_Position"]["drawdown"])])[1]);  # 每兩次對衝交易之間的回撤值，纍加總計;
                                profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["maximum_drawdown"] = Core.Float64(Base.findmin([if ((Base.typeof(value["Long_Position"]["drawdown"][i]) <: Core.Array || Base.typeof(value["Long_Position"]["drawdown"][i]) <: Base.Vector) && Core.Int64(Base.length(value["Long_Position"]["drawdown"][i])) > Core.Int64(0)) Core.Float64(Base.findmin(value["Long_Position"]["drawdown"][i])[1]) end for i in 1:Base.length(value["Long_Position"]["drawdown"])])[1]);  # 每兩次對衝交易之間的回撤值，纍加總計;
                            end
                        end

                        if (Base.haskey(value["Long_Position"], "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Base.Vector))
                            # println(value["Long_Position"]["Long_Position_profit_date_transaction"]);
                            profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_number_total"] = Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"]));
                        end

                        if (Base.haskey(value["Long_Position"], "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Base.Vector))
                            # println(value["Long_Position"]["Long_Position_profit_date_transaction"]);
                            if Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])) > Core.Int64(0)
                                profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_total"] = Core.Float64(Base.sum([Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])]));  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                            end
                        end

                        if (Base.haskey(value["Long_Position"], "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Base.Vector))
                            # println(value["Long_Position"]["Long_Position_profit_date_transaction"]);
                            if Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])) > Core.Int64(0)
                                if Core.Int64(Base.length([(Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) : Core.Float64(0.0) for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])])) > Core.Int64(0)
                                    # profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive"] = Core.Float64(Base.sum([if Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0) Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) else Core.Float64(0.0) end for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])]));
                                    profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive"] = Core.Float64(Base.sum([(Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) : Core.Float64(0.0) for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])]));
                                end
                                if Core.Int64(Base.length([(Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) < Core.Float64(0.0)) ? Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) : Core.Float64(0.0) for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])])) > Core.Int64(0)
                                    # profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative"] = Core.Float64(Base.sum([if Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) < Core.Float64(0.0) Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) else Core.Float64(0.0) end for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])]));
                                    profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative"] = Core.Float64(Base.sum([(Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) < Core.Float64(0.0)) ? Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) : Core.Float64(0.0) for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])]));
                                end

                                # profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive"] = Core.Float64(0.0);  # 交易規則正利潤纍計;
                                # profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative"] = Core.Float64(0.0);  # 交易規則負利潤纍計;
                                # for i = 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])
                                #     if Core.Int64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) > Core.Float64(0)
                                #         profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive"] + value["Long_Position"]["Long_Position_profit_date_transaction"][i]);
                                #     elseif Core.Int64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) < Core.Float64(0)
                                #         profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative"] + value["Long_Position"]["Long_Position_profit_date_transaction"][i]);
                                #     else
                                #     end
                                # end
                            end
                        end

                        if (Base.haskey(value["Long_Position"], "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Base.Vector))
                            # println(value["Long_Position"]["Long_Position_profit_date_transaction"]);
                            if Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])) > Core.Int64(0)
                                # profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive_probability"] = Core.Float64(Core.Int64(Base.sum([if Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])])) / Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])));
                                profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive_probability"] = Core.Float64(Core.Int64(Base.sum([(Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])])) / Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])));
                                # profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative_probability"] = Core.Float64(Core.Int64(Base.sum([if Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) < Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])])) / Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])));
                                profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative_probability"] = Core.Float64(Core.Int64(Base.sum([(Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) < Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])])) / Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])));

                                # profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive_probability"] = Core.Int64(0);  # Core.Float64(0.0);  # 交易規則正利潤頻率;
                                # profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative_probability"] = Core.Int64(0);  # Core.Float64(0.0);  # 交易規則負利潤頻率;
                                # for i = 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])
                                #     if Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0)
                                #         profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive_probability"] = Core.Int64(Core.Int64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive_probability"]) + Core.Int64(1));
                                #     elseif Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) < Core.Float64(0.0)
                                #         profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative_probability"] = Core.Int64(Core.Int64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative_probability"]) + Core.Int64(1));
                                #     else
                                #     end
                                # end
                                # if Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])) > Core.Int64(0)
                                #     profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive_probability"] = Core.Float64(Core.Int64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive_probability"]) / Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])));
                                #     profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative_probability"] = Core.Float64(Core.Int64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative_probability"]) / Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])));
                                # end
                            end
                        end

                        # # y = Core.Float64(y_Positive_Long_Position * y_P_Positive_Long_Position);  # 每兩次對衝交易正利潤 × 頻率，纍加總計;
                        # # y = Core.Float64(y_Negative_Long_Position * y_P_Negative_Long_Position);  # 每兩次對衝交易負利潤 × 頻率，纍加總計;
                        # y = Core.Float64(y_Positive_Long_Position * y_P_Positive_Long_Position) - Core.Float64(y_Negative_Long_Position * y_P_Negative_Long_Position);

                        if (Base.haskey(value["Long_Position"], "Long_Position_price_amplitude_date_transaction") && (Base.typeof(value["Long_Position"]["Long_Position_price_amplitude_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_price_amplitude_date_transaction"]) <: Base.Vector))
                            # println(value["Long_Position"]["Long_Position_price_amplitude_date_transaction"]);
                            if Core.Int64(Base.length(value["Long_Position"]["Long_Position_price_amplitude_date_transaction"])) > Core.Int64(0)
                                profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"] = Core.Float64(Statistics.mean(value["Long_Position"]["Long_Position_price_amplitude_date_transaction"]));  # amplitude_rate;
                            end
                        end

                        if (Base.haskey(value["Long_Position"], "Long_Position_volume_turnover_date_transaction") && (Base.typeof(value["Long_Position"]["Long_Position_volume_turnover_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_volume_turnover_date_transaction"]) <: Base.Vector))
                            # println(value["Long_Position"]["Long_Position_volume_turnover_date_transaction"]);
                            if Core.Int64(Base.length(value["Long_Position"]["Long_Position_volume_turnover_date_transaction"])) > Core.Int64(0)
                                profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"] = Core.Float64(Statistics.mean(value["Long_Position"]["Long_Position_volume_turnover_date_transaction"]));  # turnover_volume; turnover_rate;
                            end
                        end

                        if (Base.haskey(value["Long_Position"], "Long_Position_date_transaction_between") && (Base.typeof(value["Long_Position"]["Long_Position_date_transaction_between"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_date_transaction_between"]) <: Base.Vector))
                            # println(value["Long_Position"]["Long_Position_date_transaction_between"]);
                            if Core.Int64(Base.length(value["Long_Position"]["Long_Position_date_transaction_between"])) > Core.Int64(0)
                                profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_date_transaction_between"] = Core.Float64(Statistics.mean(value["Long_Position"]["Long_Position_date_transaction_between"]));  # Between two date_transaction;
                            end
                        end

                        # weight_Long_Position = Core.Array{Core.Float64, 1}();
                        # # if (Base.haskey(value["Long_Position"], "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Base.Vector))
                        # #     # println(value["Long_Position"]["Long_Position_profit_date_transaction"]);
                        # #     if Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])) > Core.Int64(0)
                        # #         if Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive_probability"]) > Core.Float64(0.0) && Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative_probability"]) > Core.Float64(0.0)
                        # #             weight_Long_Position = [(Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive_probability"]) : Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative_probability"]) for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])];
                        # #         elseif Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive_probability"]) > Core.Float64(0.0) && Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative_probability"]) <= Core.Float64(0.0)
                        # #             weight_Long_Position = [(Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive_probability"]) : Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative_probability"]) for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])];
                        # #         elseif Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive_probability"]) <= Core.Float64(0.0) && Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative_probability"]) > Core.Float64(0.0)
                        # #             weight_Long_Position = [(Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive_probability"]) : Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative_probability"]) for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])];
                        # #         else
                        # #             weight_Long_Position = [Core.Float64(1.0) for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])];
                        # #         end
                        # #     end
                        # # end
                        # # if (Base.haskey(value["Long_Position"], "Long_Position_date_transaction_between") && (Base.typeof(value["Long_Position"]["Long_Position_date_transaction_between"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_date_transaction_between"]) <: Base.Vector))
                        # #     # println(value["Long_Position"]["Long_Position_date_transaction_between"]);
                        # #     if Core.Int64(Base.length(value["Long_Position"]["Long_Position_date_transaction_between"])) > Core.Int64(0)
                        # #         weight_Long_Position = [Core.Float64(Core.Int64(1) / Core.Int64(value["Long_Position"]["Long_Position_date_transaction_between"][i])) for i in 1:Base.length(value["Long_Position"]["Long_Position_date_transaction_between"])];  # 每兩次對衝交易間隔日長的倒數;
                        # #     end
                        # # end
                        # # if (Base.haskey(value["Long_Position"], "Long_Position_price_amplitude_date_transaction") && (Base.typeof(value["Long_Position"]["Long_Position_price_amplitude_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_price_amplitude_date_transaction"]) <: Base.Vector))
                        # #     # println(value["Long_Position"]["Long_Position_price_amplitude_date_transaction"]);
                        # #     if Core.Int64(Base.length(value["Long_Position"]["Long_Position_price_amplitude_date_transaction"])) > Core.Int64(0)
                        # #         weight_Long_Position = [Core.Float64(Core.Int64(1) / Core.Float64(value["Long_Position"]["Long_Position_price_amplitude_date_transaction"][i])) for i in 1:Base.length(value["Long_Position"]["Long_Position_price_amplitude_date_transaction"])];  # 兩次對衝交易日成交價振幅平方和的倒數;
                        # #     end
                        # # end
                        # # if (Base.haskey(value["Long_Position"], "Long_Position_volume_turnover_date_transaction") && (Base.typeof(value["Long_Position"]["Long_Position_volume_turnover_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_volume_turnover_date_transaction"]) <: Base.Vector))
                        # #     # println(value["Long_Position"]["Long_Position_volume_turnover_date_transaction"]);
                        # #     if Core.Int64(Base.length(value["Long_Position"]["Long_Position_volume_turnover_date_transaction"])) > Core.Int64(0)
                        # #         weight_Long_Position = [Core.Float64(value["Long_Position"]["Long_Position_volume_turnover_date_transaction"][i]) for i in 1:Base.length(value["Long_Position"]["Long_Position_volume_turnover_date_transaction"])];  # 兩次對衝交易日成交量（換手率）均值;
                        # #     end
                        # # end

                        # if (Base.haskey(value["Long_Position"], "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Base.Vector))
                        #     # println(value["Long_Position"]["Long_Position_profit_date_transaction"]);
                        #     if Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])) > Core.Int64(0)
                        #         if Core.Int64(Base.length(weight_Long_Position)) > Core.Int64(0)
                        #             profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["y_Long_Position"] = Core.Float64(Base.sum([Core.Float64(Core.Float64(weight_Long_Position[i]) * Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i])) for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])]));  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                        #             # profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["y_Long_Position"] = Core.Float64(0.0);  # 每兩次對衝交易利潤 × 權重，纍加總計;
                        #             # for i = 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])
                        #             #     profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["y_Long_Position"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["y_Long_Position"]) + Core.Float64(weight_Long_Position[i] * value["Long_Position"]["Long_Position_profit_date_transaction"][i]);
                        #             # end
                        #         elseif Core.Int64(Base.length(weight_Long_Position)) <= Core.Int64(0)
                        #             profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["y_Long_Position"] = Core.Float64(Base.sum([Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])]));  # 每兩次對衝交易利潤，加權纍加總計;
                        #             # profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["y_Long_Position"] = Core.Float64(0.0);  # 每兩次對衝交易利潤，纍加總計;
                        #             # for i = 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])
                        #             #     profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["y_Long_Position"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["y_Long_Position"]) + Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]);
                        #             # end
                        #         else
                        #         end
                        #     end
                        # end

                        # 優化目標變量合入風險因素;
                        # if Core.Float64(y_P_Negative_Long_Position) === Core.Float64(0.0)
                        #     y_Long_Position = Core.Float64(y_Long_Position * y_P_Positive_Long_Position);  # 每次交易利潤 × 頻率 × 權重，加權纍加總計，然後再 × 正利潤概率，叠加不確定風險效果;
                        # else
                        #     y_Long_Position = Core.Float64(y_Long_Position * Core.Float64(y_P_Positive_Long_Position / y_P_Negative_Long_Position));  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計，然後再 × 正利潤概率，叠加不確定風險效果;
                        # end
                    end
                end

                if investment_method === "Long_Position_and_Short_Selling" || investment_method === "Short_Selling"
                    if Base.haskey(value, "Short_Selling") && Base.isa(value["Short_Selling"], Base.Dict)

                        # 交易信息序列數據（融券做空 short selling）的匯總求和;
                        profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_number_total"] = Core.nothing;  # Core.Int64(0);  # 對衝交易總次數;
                        profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["maximum_drawdown"] = Core.nothing;  # Core.Float64(0.0);  # 最大回撤值;
                        profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_total"] = Core.nothing;  # Core.Float64(0.0);  # 每兩次對衝交易利潤，纍加總計;
                        profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive"] = Core.nothing;  # Core.Float64(0.0);  # 每兩次對衝交易收益纍加總計;
                        profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative"] = Core.nothing;  # Core.Float64(0.0);  # 每兩次對衝交易損失纍加總計;
                        profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive_probability"] = Core.nothing;  # Core.Float64(0.0);  # 每兩次對衝交易正利潤概率;
                        profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative_probability"] = Core.nothing;  # Core.Float64(0.0);  # 每兩次對衝交易負利潤概率;
                        profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"] = Core.nothing;  # Core.Float64(0.0);  # 兩次對衝交易日成交價振幅平方和，均值;
                        profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"] = Core.nothing;  # Core.Float64(0.0);  # 兩次對衝交易日成交量（換手率）均值;
                        profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_date_transaction_between"] = Core.nothing;  # Core.Float64(0.0);  # 兩次對衝交易間隔日長，均值;
                        # profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["y_Short_Selling"] = Core.nothing;  # Core.Float64(0.0);  # 優化目標變量，做空（Short Selling），每兩次對衝交易利潤 × 權重，加權纍加總計;

                        if (Base.haskey(value["Short_Selling"], "drawdown") && (Base.typeof(value["Short_Selling"]["drawdown"]) <: Core.Array || Base.typeof(value["Short_Selling"]["drawdown"]) <: Base.Vector))
                            # println(value["Short_Selling"]["drawdown"]);
                            if Core.Int64(Base.length(value["Short_Selling"]["drawdown"])) > Core.Int64(0) && Core.Int64(Base.findmax([(Base.typeof(value["Short_Selling"]["drawdown"][i]) <: Core.Array || Base.typeof(value["Short_Selling"]["drawdown"][i]) <: Base.Vector) ? Core.Int64(Base.length(value["Short_Selling"]["drawdown"][i])) : (-Base.Inf) for i in 1:Base.length(value["Short_Selling"]["drawdown"])])[1]) > Core.Int64(0)
                                # profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["maximum_drawdown"] = Core.Float64(Base.findmin([if ((Base.typeof(value["Short_Selling"]["drawdown"][i]) <: Core.Array || Base.typeof(value["Short_Selling"]["drawdown"][i]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling"]["drawdown"][i])) > Core.Int64(0)) Core.Float64(Base.findmin(value["Short_Selling"]["drawdown"][i])[1]) else (+Base.Inf) end for i in 1:Base.length(value["Short_Selling"]["drawdown"])])[1]);  # 每兩次對衝交易之間的回撤值，纍加總計;
                                # profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["maximum_drawdown"] = Core.Float64(Base.findmin([((Base.typeof(value["Short_Selling"]["drawdown"][i]) <: Core.Array || Base.typeof(value["Short_Selling"]["drawdown"][i]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling"]["drawdown"][i])) > Core.Int64(0)) ? Core.Float64(Base.findmin(value["Short_Selling"]["drawdown"][i])[1]) : (+Base.Inf) for i in 1:Base.length(value["Short_Selling"]["drawdown"])])[1]);  # 每兩次對衝交易之間的回撤值，纍加總計;
                                profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["maximum_drawdown"] = Core.Float64(Base.findmin([if ((Base.typeof(value["Short_Selling"]["drawdown"][i]) <: Core.Array || Base.typeof(value["Short_Selling"]["drawdown"][i]) <: Base.Vector) && Core.Int64(Base.length(value["Short_Selling"]["drawdown"][i])) > Core.Int64(0)) Core.Float64(Base.findmin(value["Short_Selling"]["drawdown"][i])[1]) end for i in 1:Base.length(value["Short_Selling"]["drawdown"])])[1]);  # 每兩次對衝交易之間的回撤值，纍加總計;
                            end
                        end

                        if (Base.haskey(value["Short_Selling"], "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Base.Vector))
                            # println(value["Short_Selling"]["Short_Selling_profit_date_transaction"]);
                            profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_number_total"] = Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"]));
                        end

                        if (Base.haskey(value["Short_Selling"], "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Base.Vector))
                            # println(value["Short_Selling"]["Short_Selling_profit_date_transaction"]);
                            if Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])) > Core.Int64(0)
                                profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_total"] = Core.Float64(Base.sum([Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])]));  # 每兩次對衝交易利潤 × 頻率，纍加總計;
                            end
                        end

                        if (Base.haskey(value["Short_Selling"], "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Base.Vector))
                            # println(value["Short_Selling"]["Short_Selling_profit_date_transaction"]);
                            if Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])) > Core.Int64(0)
                                if Core.Int64(Base.length([(Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) : Core.Float64(0.0) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])])) > Core.Int64(0)
                                    # profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive"] = Core.Float64(Base.sum([if Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0) Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) else Core.Float64(0.0) end for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])]));
                                    profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive"] = Core.Float64(Base.sum([(Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) : Core.Float64(0.0) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])]));
                                end
                                if Core.Int64(Base.length([(Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0.0)) ? Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) : Core.Float64(0.0) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])])) > Core.Int64(0)
                                    # profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative"] = Core.Float64(Base.sum([if Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0.0) Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) else Core.Float64(0.0) end for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])]));
                                    profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative"] = Core.Float64(Base.sum([(Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0.0)) ? Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) : Core.Float64(0.0) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])]));
                                end

                                # profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive"] = Core.Float64(0.0);  # 交易規則正利潤纍計;
                                # profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative"] = Core.Float64(0.0);  # 交易規則負利潤纍計;
                                # for i = 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])
                                #     if Core.Int64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0)
                                #         profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive"] + value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]);
                                #     elseif Core.Int64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0)
                                #         profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative"] + value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]);
                                #     else
                                #     end
                                # end
                            end
                        end

                        if (Base.haskey(value["Short_Selling"], "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Base.Vector))
                            # println(value["Short_Selling"]["Short_Selling_profit_date_transaction"]);
                            if Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])) > Core.Int64(0)
                                # profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive_probability"] = Core.Float64(Core.Int64(Base.sum([if Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])])) / Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])));
                                profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive_probability"] = Core.Float64(Core.Int64(Base.sum([(Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])])) / Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])));
                                # profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative_probability"] = Core.Float64(Core.Int64(Base.sum([if Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])])) / Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])));
                                profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative_probability"] = Core.Float64(Core.Int64(Base.sum([(Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])])) / Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])));

                                # profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive_probability"] = Core.Int64(0);  # Core.Float64(0.0);  # 交易規則正利潤頻率;
                                # profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative_probability"] = Core.Int64(0);  # Core.Float64(0.0);  # 交易規則負利潤頻率;
                                # for i = 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])
                                #     if Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0)
                                #         profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive_probability"] = Core.Int64(Core.Int64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive_probability"]) + Core.Int64(1));
                                #     elseif Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0.0)
                                #         profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative_probability"] = Core.Int64(Core.Int64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative_probability"]) + Core.Int64(1));
                                #     else
                                #     end
                                # end
                                # if Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])) > Core.Int64(0)
                                #     profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive_probability"] = Core.Float64(Core.Int64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive_probability"]) / Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])));
                                #     profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative_probability"] = Core.Float64(Core.Int64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative_probability"]) / Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])));
                                # end
                            end
                        end

                        # # y = Core.Float64(y_Positive_Short_Selling * y_P_Positive_Short_Selling);  # 每兩次對衝交易正利潤 × 頻率，纍加總計;
                        # # y = Core.Float64(y_Negative_Short_Selling * y_P_Negative_Short_Selling);  # 每兩次對衝交易負利潤 × 頻率，纍加總計;
                        # y = Core.Float64(y_Positive_Short_Selling * y_P_Positive_Short_Selling) - Core.Float64(y_Negative_Short_Selling * y_P_Negative_Short_Selling);

                        if (Base.haskey(value["Short_Selling"], "Short_Selling_price_amplitude_date_transaction") && (Base.typeof(value["Short_Selling"]["Short_Selling_price_amplitude_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_price_amplitude_date_transaction"]) <: Base.Vector))
                            # println(value["Short_Selling"]["Short_Selling_price_amplitude_date_transaction"]);
                            if Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_price_amplitude_date_transaction"])) > Core.Int64(0)
                                profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"] = Core.Float64(Statistics.mean(value["Short_Selling"]["Short_Selling_price_amplitude_date_transaction"]));  # amplitude_rate;
                            end
                        end

                        if (Base.haskey(value["Short_Selling"], "Short_Selling_volume_turnover_date_transaction") && (Base.typeof(value["Short_Selling"]["Short_Selling_volume_turnover_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_volume_turnover_date_transaction"]) <: Base.Vector))
                            # println(value["Short_Selling"]["Short_Selling_volume_turnover_date_transaction"]);
                            if Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_volume_turnover_date_transaction"])) > Core.Int64(0)
                                profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"] = Core.Float64(Statistics.mean(value["Short_Selling"]["Short_Selling_volume_turnover_date_transaction"]));  # turnover_volume; turnover_rate;
                            end
                        end

                        if (Base.haskey(value["Short_Selling"], "Short_Selling_date_transaction_between") && (Base.typeof(value["Short_Selling"]["Short_Selling_date_transaction_between"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_date_transaction_between"]) <: Base.Vector))
                            # println(value["Short_Selling"]["Short_Selling_date_transaction_between"]);
                            if Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_date_transaction_between"])) > Core.Int64(0)
                                profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_date_transaction_between"] = Core.Float64(Statistics.mean(value["Short_Selling"]["Short_Selling_date_transaction_between"]));  # Between two date_transaction;
                            end
                        end

                        # weight_Short_Selling = Core.Array{Core.Float64, 1}();
                        # # if (Base.haskey(value["Short_Selling"], "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Base.Vector))
                        # #     # println(value["Short_Selling"]["Short_Selling_profit_date_transaction"]);
                        # #     if Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])) > Core.Int64(0)
                        # #         if Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive_probability"]) > Core.Float64(0.0) && Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative_probability"]) > Core.Float64(0.0)
                        # #             weight_Short_Selling = [(Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive_probability"]) : Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative_probability"]) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])];
                        # #         elseif Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive_probability"]) > Core.Float64(0.0) && Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative_probability"]) <= Core.Float64(0.0)
                        # #             weight_Short_Selling = [(Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive_probability"]) : Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative_probability"]) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])];
                        # #         elseif Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive_probability"]) <= Core.Float64(0.0) && Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative_probability"]) > Core.Float64(0.0)
                        # #             weight_Short_Selling = [(Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive_probability"]) : Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative_probability"]) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])];
                        # #         else
                        # #             weight_Short_Selling = [Core.Float64(1.0) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])];
                        # #         end
                        # #     end
                        # # end
                        # # if (Base.haskey(value["Short_Selling"], "Short_Selling_date_transaction_between") && (Base.typeof(value["Short_Selling"]["Short_Selling_date_transaction_between"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_date_transaction_between"]) <: Base.Vector))
                        # #     # println(value["Short_Selling"]["Short_Selling_date_transaction_between"]);
                        # #     if Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_date_transaction_between"])) > Core.Int64(0)
                        # #         weight_Short_Selling = [Core.Float64(Core.Int64(1) / Core.Int64(value["Short_Selling"]["Short_Selling_date_transaction_between"][i])) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_date_transaction_between"])];  # 每兩次對衝交易間隔日長的倒數;
                        # #     end
                        # # end
                        # # if (Base.haskey(value["Short_Selling"], "Short_Selling_price_amplitude_date_transaction") && (Base.typeof(value["Short_Selling"]["Short_Selling_price_amplitude_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_price_amplitude_date_transaction"]) <: Base.Vector))
                        # #     # println(value["Short_Selling"]["Short_Selling_price_amplitude_date_transaction"]);
                        # #     if Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_price_amplitude_date_transaction"])) > Core.Int64(0)
                        # #         weight_Short_Selling = [Core.Float64(Core.Int64(1) / Core.Float64(value["Short_Selling"]["Short_Selling_price_amplitude_date_transaction"][i])) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_price_amplitude_date_transaction"])];  # 兩次對衝交易日成交價振幅平方和的倒數;
                        # #     end
                        # # end
                        # # if (Base.haskey(value["Short_Selling"], "Short_Selling_volume_turnover_date_transaction") && (Base.typeof(value["Short_Selling"]["Short_Selling_volume_turnover_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_volume_turnover_date_transaction"]) <: Base.Vector))
                        # #     # println(value["Short_Selling"]["Short_Selling_volume_turnover_date_transaction"]);
                        # #     if Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_volume_turnover_date_transaction"])) > Core.Int64(0)
                        # #         weight_Short_Selling = [Core.Float64(value["Short_Selling"]["Short_Selling_volume_turnover_date_transaction"][i]) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_volume_turnover_date_transaction"])];  # 兩次對衝交易日成交量（換手率）均值;
                        # #     end
                        # # end

                        # if (Base.haskey(value["Short_Selling"], "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Base.Vector))
                        #     # println(value["Short_Selling"]["Short_Selling_profit_date_transaction"]);
                        #     if Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])) > Core.Int64(0)
                        #         if Core.Int64(Base.length(weight_Short_Selling)) > Core.Int64(0)
                        #             profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["y_Short_Selling"] = Core.Float64(Base.sum([Core.Float64(Core.Float64(weight_Short_Selling[i]) * Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i])) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])]));  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
                        #             # profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["y_Short_Selling"] = Core.Float64(0.0);  # 每兩次對衝交易利潤 × 權重，纍加總計;
                        #             # for i = 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])
                        #             #     profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["y_Short_Selling"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["y_Short_Selling"]) + Core.Float64(weight_Short_Selling[i] * value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]);
                        #             # end
                        #         elseif Core.Int64(Base.length(weight_Short_Selling)) <= Core.Int64(0)
                        #             profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["y_Short_Selling"] = Core.Float64(Base.sum([Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])]));  # 每兩次對衝交易利潤，加權纍加總計;
                        #             # profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["y_Short_Selling"] = Core.Float64(0.0);  # 每兩次對衝交易利潤，纍加總計;
                        #             # for i = 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])
                        #             #     profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["y_Short_Selling"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["y_Short_Selling"]) + Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]);
                        #             # end
                        #         else
                        #         end
                        #     end
                        # end

                        # 優化目標變量合入風險因素;
                        # if Core.Float64(y_P_Negative_Short_Selling) === Core.Float64(0.0)
                        #     y_Short_Selling = Core.Float64(y_Short_Selling * y_P_Positive_Short_Selling);  # 每次交易利潤 × 頻率 × 權重，加權纍加總計，然後再 × 正利潤概率，叠加不確定風險效果;
                        # else
                        #     y_Short_Selling = Core.Float64(y_Short_Selling * Core.Float64(y_P_Positive_Short_Selling / y_P_Negative_Short_Selling));  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計，然後再 × 正利潤概率，叠加不確定風險效果;
                        # end
                    end
                end

                if investment_method === "Long_Position_and_Short_Selling"
                    if (Base.haskey(value, "Long_Position") && Base.isa(value["Long_Position"], Base.Dict)) && (Base.haskey(value, "Short_Selling") && Base.isa(value["Short_Selling"], Base.Dict))
                        # 交易信息序列數據（融資做多 buying long）+（融券做空 short selling）的匯總求和;
                        profit_paired_data_transaction_sequence_Dict[key]["number_total"] = Core.nothing;  # Core.Int64(Core.Int64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_number_total"]) + Core.Int64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_number_total"]));  # 兩次對衝交易總輪數，纍加總計;
                        if (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_number_total"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_number_total"]))) && (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_number_total"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_number_total"])))
                            profit_paired_data_transaction_sequence_Dict[key]["number_total"] = Core.Float64(Base.sum([profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_number_total"], profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_number_total"]]));  # 兩次對衝交易總輪數，纍加總計;
                        elseif (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_number_total"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_number_total"]))) && (Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_number_total"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_number_total"]))
                            profit_paired_data_transaction_sequence_Dict[key]["number_total"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_number_total"]);
                        elseif (Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_number_total"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_number_total"])) && (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_number_total"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_number_total"])))
                            profit_paired_data_transaction_sequence_Dict[key]["number_total"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_number_total"]);
                        else
                            profit_paired_data_transaction_sequence_Dict[key]["number_total"] = Core.nothing;
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["maximum_drawdown"] = Core.nothing;  # Core.Float64(Base.findmin([Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["maximum_drawdown"]), Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["maximum_drawdown"])])[1]);  # 每兩次對衝交易之間的回撤值，纍加總計;
                        if (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["maximum_drawdown"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["maximum_drawdown"]))) && (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["maximum_drawdown"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["maximum_drawdown"])))
                            profit_paired_data_transaction_sequence_Dict[key]["maximum_drawdown"] = Core.Float64(Base.findmin([profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["maximum_drawdown"], profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["maximum_drawdown"]])[1]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                        elseif (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["maximum_drawdown"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["maximum_drawdown"]))) && (Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["maximum_drawdown"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["maximum_drawdown"]))
                            profit_paired_data_transaction_sequence_Dict[key]["maximum_drawdown"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                        elseif (Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["maximum_drawdown"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["maximum_drawdown"])) && (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["maximum_drawdown"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["maximum_drawdown"])))
                            profit_paired_data_transaction_sequence_Dict[key]["maximum_drawdown"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
                        else
                            profit_paired_data_transaction_sequence_Dict[key]["maximum_drawdown"] = Core.nothing;
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["profit_total"] = Core.nothing;  # Core.Float64(Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_total"]) + Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_total"]));  # 每兩次對衝交易利潤，纍加總計;
                        if (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_total"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_total"]))) && (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_total"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_total"])))
                            profit_paired_data_transaction_sequence_Dict[key]["profit_total"] = Core.Float64(Base.sum([profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_total"], profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_total"]]));  # 每兩次對衝交易利潤，纍加總計;
                        elseif (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_total"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_total"]))) && (Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_total"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_total"]))
                            profit_paired_data_transaction_sequence_Dict[key]["profit_total"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_total"]);
                        elseif (Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_total"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_total"])) && (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_total"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_total"])))
                            profit_paired_data_transaction_sequence_Dict[key]["profit_total"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_total"]);
                        else
                            profit_paired_data_transaction_sequence_Dict[key]["profit_total"] = Core.nothing;
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["profit_Positive"] = Core.nothing;  # Core.Float64(Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive"]) + Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive"]));  # 每兩次對衝交易收益纍加總計;
                        if (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive"]))) && (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive"])))
                            profit_paired_data_transaction_sequence_Dict[key]["profit_Positive"] = Core.Float64(Base.sum([profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive"], profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive"]]));  # 每兩次對衝交易收益纍加總計;
                        elseif (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive"]))) && (Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive"]))
                            profit_paired_data_transaction_sequence_Dict[key]["profit_Positive"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive"]);
                        elseif (Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive"])) && (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive"])))
                            profit_paired_data_transaction_sequence_Dict[key]["profit_Positive"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive"]);
                        else
                            profit_paired_data_transaction_sequence_Dict[key]["profit_Positive"] = Core.nothing;
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["profit_Negative"] = Core.nothing;  # Core.Float64(Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative"]) + Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative"]));  # 每兩次對衝交易損失纍加總計;
                        if (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative"]))) && (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative"])))
                            profit_paired_data_transaction_sequence_Dict[key]["profit_Negative"] = Core.Float64(Base.sum([profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative"], profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative"]]));  # 每兩次對衝交易損失纍加總計;
                        elseif (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative"]))) && (Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative"]))
                            profit_paired_data_transaction_sequence_Dict[key]["profit_Negative"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative"]);
                        elseif (Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative"])) && (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative"])))
                            profit_paired_data_transaction_sequence_Dict[key]["profit_Negative"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative"]);
                        else
                            profit_paired_data_transaction_sequence_Dict[key]["profit_Negative"] = Core.nothing;
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["profit_Positive_probability"] = Core.nothing;  # Core.Float64(0.0);  # 每兩次對衝交易正利潤概率;
                        profit_paired_data_transaction_sequence_Dict[key]["profit_Negative_probability"] = Core.nothing;  # Core.Float64(0.0);  # 每兩次對衝交易負利潤概率;
                        if ((Base.haskey(value["Long_Position"], "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Base.Vector)) && Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])) > Core.Int64(0)) || ((Base.haskey(value["Short_Selling"], "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Base.Vector)) && Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])) > Core.Int64(0))
                            y_Positive_count_Long_Position = Core.Int64(0);
                            y_Negative_count_Long_Position = Core.Int64(0);
                            y_Positive_count_Short_Selling = Core.Int64(0);
                            y_Negative_count_Short_Selling = Core.Int64(0);
                            if (Base.haskey(value["Long_Position"], "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Base.Vector))
                                if Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])) > Core.Int64(0)
                                    # y_Positive_count_Long_Position = Core.Int64(Base.sum([if Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])]));
                                    y_Positive_count_Long_Position = Core.Int64(Base.sum([(Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])]));
                                    # y_Negative_count_Long_Position = Core.Int64(Base.sum([if Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) < Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])]));
                                    y_Negative_count_Long_Position = Core.Int64(Base.sum([(Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) < Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])]));
                                end
                            end
                            if (Base.haskey(value["Short_Selling"], "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Base.Vector))
                                if Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])) > Core.Int64(0)
                                    # y_Positive_count_Short_Selling = Core.Int64(Base.sum([if Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])]));
                                    y_Positive_count_Short_Selling = Core.Int64(Base.sum([(Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])]));
                                    # y_Negative_count_Short_Selling = Core.Int64(Base.sum([if Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])]));
                                    y_Negative_count_Short_Selling = Core.Int64(Base.sum([(Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])]));
                                end
                            end
                            profit_paired_data_transaction_sequence_Dict[key]["profit_Positive_probability"] = Core.Float64(Core.Int64(Core.Int64(y_Positive_count_Long_Position) + Core.Int64(y_Positive_count_Short_Selling)) / Core.Int64(Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])) + Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"]))));
                            profit_paired_data_transaction_sequence_Dict[key]["profit_Negative_probability"] = Core.Float64(Core.Int64(Core.Int64(y_Negative_count_Long_Position) + Core.Int64(y_Negative_count_Short_Selling)) / Core.Int64(Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])) + Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"]))));
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["average_price_amplitude_date_transaction"] = Core.nothing;  # Core.Float64(Core.Float64(Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"]) + Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"])) / Core.Int64(2));  # 兩次對衝交易日成交價振幅平方和，均值;
                        if (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"]))) && (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"])))
                            profit_paired_data_transaction_sequence_Dict[key]["average_price_amplitude_date_transaction"] = Core.Float64(Statistics.mean([profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"], profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"]]));  # 兩次對衝交易日成交價振幅平方和，均值;
                        elseif (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"]))) && (Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"]))
                            profit_paired_data_transaction_sequence_Dict[key]["average_price_amplitude_date_transaction"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"]);
                        elseif (Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"])) && (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"])))
                            profit_paired_data_transaction_sequence_Dict[key]["average_price_amplitude_date_transaction"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"]);
                        else
                            profit_paired_data_transaction_sequence_Dict[key]["average_price_amplitude_date_transaction"] = Core.nothing;
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["average_volume_turnover_date_transaction"] = Core.nothing;  # Core.Float64(Core.Float64(Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"]) + Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"])) / Core.Int64(2));  # 兩次對衝交易日成交量（換手率）均值;
                        if (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"]))) && (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"])))
                            profit_paired_data_transaction_sequence_Dict[key]["average_volume_turnover_date_transaction"] = Core.Float64(Statistics.mean([profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"], profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"]]));  # 兩次對衝交易日成交量（換手率）均值;
                        elseif (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"]))) && (Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"]))
                            profit_paired_data_transaction_sequence_Dict[key]["average_volume_turnover_date_transaction"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"]);
                        elseif (Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"])) && (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"])))
                            profit_paired_data_transaction_sequence_Dict[key]["average_volume_turnover_date_transaction"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"]);
                        else
                            profit_paired_data_transaction_sequence_Dict[key]["average_volume_turnover_date_transaction"] = Core.nothing;
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["average_date_transaction_between"] = Core.nothing;  # Core.Float64(Core.Float64(Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_date_transaction_between"]) + Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_date_transaction_between"])) / Core.Int64(2));  # 兩次對衝交易間隔日長，均值，Between two date_transaction;
                        if (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_date_transaction_between"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_date_transaction_between"]))) && (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_date_transaction_between"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_date_transaction_between"])))
                            profit_paired_data_transaction_sequence_Dict[key]["average_date_transaction_between"] = Core.Float64(Statistics.mean([profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_date_transaction_between"], profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_date_transaction_between"]]));  # 兩次對衝交易總輪數，纍加總計;
                        elseif (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_date_transaction_between"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_date_transaction_between"]))) && (Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_date_transaction_between"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_date_transaction_between"]))
                            profit_paired_data_transaction_sequence_Dict[key]["average_date_transaction_between"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_date_transaction_between"]);
                        elseif (Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_date_transaction_between"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_date_transaction_between"])) && (!(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_date_transaction_between"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_date_transaction_between"])))
                            profit_paired_data_transaction_sequence_Dict[key]["average_date_transaction_between"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_date_transaction_between"]);
                        else
                            profit_paired_data_transaction_sequence_Dict[key]["average_date_transaction_between"] = Core.nothing;
                        end
                        # profit_paired_data_transaction_sequence_Dict[key]["y"] = Core.Float64(Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["y_Long_Position"]) + Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["y_Short_Selling"]));  # 優化目標變量，每兩次對衝交易利潤 × 權重，加權纍加總計;
                    end
                    if (Base.haskey(value, "Long_Position") && Base.isa(value["Long_Position"], Base.Dict)) && (!(Base.haskey(value, "Short_Selling") && Base.isa(value["Short_Selling"], Base.Dict)))
                        # 交易信息序列數據（融資做多 buying long）+（融券做空 short selling）的匯總求和;
                        profit_paired_data_transaction_sequence_Dict[key]["number_total"] = Core.nothing;  # Core.Int64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_number_total"]);  # 兩次對衝交易總輪數，纍加總計;
                        if !(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_number_total"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_number_total"]))
                            profit_paired_data_transaction_sequence_Dict[key]["number_total"] = Core.Int64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_number_total"]);  # 兩次對衝交易總輪數，纍加總計;
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["maximum_drawdown"] = Core.nothing;  # Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["maximum_drawdown"]);  # 每兩次對衝交易之間的回撤值，纍加總計;
                        if !(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["maximum_drawdown"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["maximum_drawdown"]))
                            profit_paired_data_transaction_sequence_Dict[key]["maximum_drawdown"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["maximum_drawdown"]);  # 每兩次對衝交易之間的回撤值，纍加總計;
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["profit_total"] = Core.nothing;  # Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_total"]);  # 每兩次對衝交易利潤，纍加總計;
                        if !(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_total"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_total"]))
                            profit_paired_data_transaction_sequence_Dict[key]["profit_total"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_total"]);  # 每兩次對衝交易利潤，纍加總計;
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["profit_Positive"] = Core.nothing;  # Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                        if !(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive"]))
                            profit_paired_data_transaction_sequence_Dict[key]["profit_Positive"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["profit_Negative"] = Core.nothing;  # Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                        if !(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative"]))
                            profit_paired_data_transaction_sequence_Dict[key]["profit_Negative"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["profit_Positive_probability"] = Core.nothing;  # Core.Float64(0.0);  # 每兩次對衝交易正利潤概率;
                        profit_paired_data_transaction_sequence_Dict[key]["profit_Negative_probability"] = Core.nothing;  # Core.Float64(0.0);  # 每兩次對衝交易負利潤概率;
                        if ((Base.haskey(value["Long_Position"], "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Base.Vector)) && Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])) > Core.Int64(0)) || ((Base.haskey(value["Short_Selling"], "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Base.Vector)) && Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])) > Core.Int64(0))
                            y_Positive_count_Long_Position = Core.Int64(0);
                            y_Negative_count_Long_Position = Core.Int64(0);
                            y_Positive_count_Short_Selling = Core.Int64(0);
                            y_Negative_count_Short_Selling = Core.Int64(0);
                            if (Base.haskey(value["Long_Position"], "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Base.Vector))
                                if Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])) > Core.Int64(0)
                                    # y_Positive_count_Long_Position = Core.Int64(Base.sum([if Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])]));
                                    y_Positive_count_Long_Position = Core.Int64(Base.sum([(Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])]));
                                    # y_Negative_count_Long_Position = Core.Int64(Base.sum([if Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) < Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])]));
                                    y_Negative_count_Long_Position = Core.Int64(Base.sum([(Core.Float64(value["Long_Position"]["Long_Position_profit_date_transaction"][i]) < Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])]));
                                end
                            end
                            profit_paired_data_transaction_sequence_Dict[key]["profit_Positive_probability"] = Core.Float64(Core.Int64(Core.Int64(y_Positive_count_Long_Position) + Core.Int64(y_Positive_count_Short_Selling)) / Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])));
                            profit_paired_data_transaction_sequence_Dict[key]["profit_Negative_probability"] = Core.Float64(Core.Int64(Core.Int64(y_Negative_count_Long_Position) + Core.Int64(y_Negative_count_Short_Selling)) / Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])));
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["average_price_amplitude_date_transaction"] = Core.nothing;  # Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"]);
                        if !(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"]))
                            profit_paired_data_transaction_sequence_Dict[key]["average_price_amplitude_date_transaction"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"]);
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["average_volume_turnover_date_transaction"] = Core.nothing;  # Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"]);
                        if !(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"]))
                            profit_paired_data_transaction_sequence_Dict[key]["average_volume_turnover_date_transaction"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"]);
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["average_date_transaction_between"] = Core.nothing;  # Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值，Between two date_transaction;
                        if !(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_date_transaction_between"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_date_transaction_between"]))
                            profit_paired_data_transaction_sequence_Dict[key]["average_date_transaction_between"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值，Between two date_transaction;
                        end
                        # profit_paired_data_transaction_sequence_Dict[key]["y"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Long_Position"]["y_Long_Position"]);  # 優化目標變量，每兩次對衝交易利潤 × 權重，加權纍加總計;
                    end
                    if (!(Base.haskey(value, "Long_Position") && Base.isa(value["Long_Position"], Base.Dict))) && (Base.haskey(value, "Short_Selling") && Base.isa(value["Short_Selling"], Base.Dict))
                        # 交易信息序列數據（融資做多 buying long）+（融券做空 short selling）的匯總求和;
                        profit_paired_data_transaction_sequence_Dict[key]["number_total"] = Core.nothing;  # Core.Int64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_number_total"]);  # 兩次對衝交易總輪數，纍加總計;
                        if !(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_number_total"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_number_total"]))
                            profit_paired_data_transaction_sequence_Dict[key]["number_total"] = Core.Int64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_number_total"]);  # 兩次對衝交易總輪數，纍加總計;
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["maximum_drawdown"] = Core.nothing;  # Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["maximum_drawdown"]);  # 每兩次對衝交易之間的回撤值，纍加總計;
                        if !(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["maximum_drawdown"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["maximum_drawdown"]))
                            profit_paired_data_transaction_sequence_Dict[key]["maximum_drawdown"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["maximum_drawdown"]);  # 每兩次對衝交易之間的回撤值，纍加總計;
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["profit_total"] = Core.nothing;  # Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤，纍加總計;
                        if !(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_total"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_total"]))
                            profit_paired_data_transaction_sequence_Dict[key]["profit_total"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤，纍加總計;
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["profit_Positive"] = Core.nothing;  # Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                        if !(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive"]))
                            profit_paired_data_transaction_sequence_Dict[key]["profit_Positive"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["profit_Negative"] = Core.nothing;  # Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                        if !(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative"]))
                            profit_paired_data_transaction_sequence_Dict[key]["profit_Negative"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["profit_Positive_probability"] = Core.nothing;  # Core.Float64(0.0);  # 每兩次對衝交易正利潤概率;
                        profit_paired_data_transaction_sequence_Dict[key]["profit_Negative_probability"] = Core.nothing;  # Core.Float64(0.0);  # 每兩次對衝交易負利潤概率;
                        if ((Base.haskey(value["Long_Position"], "Long_Position_profit_date_transaction") && (Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Long_Position"]["Long_Position_profit_date_transaction"]) <: Base.Vector)) && Core.Int64(Base.length(value["Long_Position"]["Long_Position_profit_date_transaction"])) > Core.Int64(0)) || ((Base.haskey(value["Short_Selling"], "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Base.Vector)) && Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])) > Core.Int64(0))
                            y_Positive_count_Long_Position = Core.Int64(0);
                            y_Negative_count_Long_Position = Core.Int64(0);
                            y_Positive_count_Short_Selling = Core.Int64(0);
                            y_Negative_count_Short_Selling = Core.Int64(0);
                            if (Base.haskey(value["Short_Selling"], "Short_Selling_profit_date_transaction") && (Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Core.Array || Base.typeof(value["Short_Selling"]["Short_Selling_profit_date_transaction"]) <: Base.Vector))
                                if Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])) > Core.Int64(0)
                                    # y_Positive_count_Short_Selling = Core.Int64(Base.sum([if Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])]));
                                    y_Positive_count_Short_Selling = Core.Int64(Base.sum([(Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) > Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])]));
                                    # y_Negative_count_Short_Selling = Core.Int64(Base.sum([if Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])]));
                                    y_Negative_count_Short_Selling = Core.Int64(Base.sum([(Core.Float64(value["Short_Selling"]["Short_Selling_profit_date_transaction"][i]) < Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])]));
                                end
                            end
                            profit_paired_data_transaction_sequence_Dict[key]["profit_Positive_probability"] = Core.Float64(Core.Int64(Core.Int64(y_Positive_count_Long_Position) + Core.Int64(y_Positive_count_Short_Selling)) / Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])));
                            profit_paired_data_transaction_sequence_Dict[key]["profit_Negative_probability"] = Core.Float64(Core.Int64(Core.Int64(y_Negative_count_Long_Position) + Core.Int64(y_Negative_count_Short_Selling)) / Core.Int64(Base.length(value["Short_Selling"]["Short_Selling_profit_date_transaction"])));
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["average_price_amplitude_date_transaction"] = Core.nothing;  # Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，均值;
                        if !(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"]))
                            profit_paired_data_transaction_sequence_Dict[key]["average_price_amplitude_date_transaction"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，均值;
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["average_volume_turnover_date_transaction"] = Core.nothing;  # Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                        if !(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"]))
                            profit_paired_data_transaction_sequence_Dict[key]["average_volume_turnover_date_transaction"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
                        end
                        profit_paired_data_transaction_sequence_Dict[key]["average_date_transaction_between"] = Core.nothing;  # Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值，Between two date_transaction;
                        if !(Base.ismissing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_date_transaction_between"]) || Base.isnothing(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_date_transaction_between"]))
                            profit_paired_data_transaction_sequence_Dict[key]["average_date_transaction_between"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值，Between two date_transaction;
                        end
                        # profit_paired_data_transaction_sequence_Dict[key]["y"] = Core.Float64(profit_paired_data_transaction_sequence_Dict[key]["Short_Selling"]["y_Short_Selling"]);  # 優化目標變量，每兩次對衝交易利潤 × 權重，加權纍加總計;
                    end
                end
            end
        end

        return_stepping_Dict["profit_paired_transaction"] = profit_paired_data_transaction_sequence_Dict;

        # 交易選股票的總隻數，函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
        Array_PickStock_transaction_Long_Position = Core.Array{Core.String, 1}();  # 做多交易選股票的總隻數;
        Array_PickStock_transaction_Short_Selling = Core.Array{Core.String, 1}();  # 做空交易選股票的總隻數;
        for (key, value) in profit_paired_data_transaction_sequence_Dict
            if Base.isa(value, Base.Dict)
                if Base.haskey(value, "Long_Position") && Base.isa(value["Long_Position"], Base.Dict) && Core.Int64(Base.length(value["Long_Position"])) > Core.Int64(0)
                    if !(Base.string(key) in Array_PickStock_transaction_Long_Position)
                        Base.push!(Array_PickStock_transaction_Long_Position, Base.string(key));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                    end
                end
                if Base.haskey(value, "Short_Selling") && Base.isa(value["Short_Selling"], Base.Dict) && Core.Int64(Base.length(value["Short_Selling"])) > Core.Int64(0)
                    if !(Base.string(key) in Array_PickStock_transaction_Short_Selling)
                        Base.push!(Array_PickStock_transaction_Short_Selling, Base.string(key));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
                    end
                end
            end
        end
        Array_PickStock_transaction = Core.Array{Core.String, 1}();  # 選股票的總隻數;
        for i = Core.Int64(1):Core.Int64(Base.length(Array_PickStock_transaction_Long_Position))
            if !(Base.string(Array_PickStock_transaction_Long_Position[i]) in Array_PickStock_transaction)
                Base.push!(Array_PickStock_transaction, Base.string(Array_PickStock_transaction_Long_Position[i]));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
            end
        end
        for i = Core.Int64(1):Core.Int64(Base.length(Array_PickStock_transaction_Short_Selling))
            if !(Base.string(Array_PickStock_transaction_Short_Selling[i]) in Array_PickStock_transaction)
                Base.push!(Array_PickStock_transaction, Base.string(Array_PickStock_transaction_Short_Selling[i]));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
            end
        end

        return_stepping_Dict["PickStock"] = Array_PickStock_transaction;
        return_stepping_Dict["PickStock_Long_Position"] = Array_PickStock_transaction_Long_Position;
        return_stepping_Dict["PickStock_Short_Selling"] = Array_PickStock_transaction_Short_Selling;
        return_stepping_Dict["number_PickStock"] = Core.Int64(Base.length(Array_PickStock_transaction));
        return_stepping_Dict["number_PickStock_Long_Position"] = Core.Int64(Base.length(Array_PickStock_transaction_Long_Position));
        return_stepping_Dict["number_PickStock_Short_Selling"] = Core.Int64(Base.length(Array_PickStock_transaction_Short_Selling));

        # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
        # 做多（Long Position）記錄;
        number_total_Long_Position = Core.nothing;  # Core.Int64(0);  # 兩次對衝交易的總輪數，纍加總計;
        y_total_Long_Position = Core.nothing;  # Core.Float64(0.0);  # 每兩次對衝交易利潤，纍加總計;
        y_maximum_drawdown_Long_Position = Core.nothing;  # Core.Float64(0.0);  # 兩次對衝交易之間的最大回撤值，取極值統計;
        y_total_Long_Position_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_maximum_drawdown_Long_Position_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_Positive_Long_Position = Core.nothing;  # Core.Float64(0.0);  # 交易規則正利潤纍計;
        y_Positive_Long_Position_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_Negative_Long_Position = Core.nothing;  # Core.Float64(0.0);  # 交易規則負利潤纍計;
        y_Negative_Long_Position_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_P_Positive_Long_Position = Core.nothing;  # Core.Float64(0.0);  # 交易規則正利潤出現頻率;
        y_P_Positive_Long_Position_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_P_Negative_Long_Position = Core.nothing;  # Core.Float64(0.0);  # 交易規則負利潤出現頻率;
        y_P_Negative_Long_Position_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_amplitude_Long_Position = Core.nothing;  # Core.Float64(0.0);  # amplitude_rate;
        y_amplitude_Long_Position_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_turnover_Long_Position = Core.nothing;  # Core.Float64(0.0);  # turnover_volume; turnover_rate;
        y_turnover_Long_Position_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_date_transaction_between_Long_Position = Core.nothing;  # Core.Float64(0.0);  # Between two date_transaction;
        y_date_transaction_between_Long_Position_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_Long_Position_profit = Core.nothing;  # Core.Float64(0.0);  # 優化目標變量，利潤 × 權重;
        y_Long_Position_loss = Core.nothing;  # Core.Float64(0.0);  # 優化目標變量，最大回撤 × 權重;
        y_Long_Position_profit_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_Long_Position_loss_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        # 做空（Short Selling）記錄;
        number_total_Short_Selling = Core.nothing;  # Core.Int64(0);  # 兩次對衝交易的總輪數，纍加總計;
        y_total_Short_Selling = Core.nothing;  # Core.Float64(0.0);  # 每兩次對衝交易利潤，纍加總計;
        y_maximum_drawdown_Short_Selling = Core.nothing;  # Core.Float64(0.0);  # 兩次對衝交易之間的最大回撤值，取極值統計;
        y_total_Short_Selling_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_maximum_drawdown_Short_Selling_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_Positive_Short_Selling = Core.nothing;  # Core.Float64(0.0);  # 交易規則正利潤纍計;
        y_Positive_Short_Selling_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_Negative_Short_Selling = Core.nothing;  # Core.Float64(0.0);  # 交易規則負利潤纍計;
        y_Negative_Short_Selling_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_P_Positive_Short_Selling = Core.nothing;  # Core.Float64(0.0);  # 交易規則正利潤出現頻率;
        y_P_Positive_Short_Selling_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_P_Negative_Short_Selling = Core.nothing;  # Core.Float64(0.0);  # 交易規則負利潤出現頻率;
        y_P_Negative_Short_Selling_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_amplitude_Short_Selling = Core.nothing;  # Core.Float64(0.0);  # amplitude_rate;
        y_amplitude_Short_Selling_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_turnover_Short_Selling = Core.nothing;  # Core.Float64(0.0);  # turnover_volume; turnover_rate;
        y_turnover_Short_Selling_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_date_transaction_between_Short_Selling = Core.nothing;  # Core.Float64(0.0);  # Between two date_transaction;
        y_date_transaction_between_Short_Selling_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_Short_Selling_profit = Core.nothing;  # Core.Float64(0.0);  # 優化目標變量，利潤 × 權重;
        y_Short_Selling_loss = Core.nothing;  # Core.Float64(0.0);  # 優化目標變量，最大回撤 × 權重;
        y_Short_Selling_profit_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_Short_Selling_loss_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        # 做多（Long Position）記錄 + 做空（Short Selling）記錄，纍計求和;
        number_total = Core.nothing;  # Core.Int64(0);  # 兩次對衝交易的總輪數，纍加總計;
        y_total = Core.nothing;  # Core.Float64(0.0);  # Core.Float64(y_total_Long_Position + y_total_Short_Selling);  # 每兩次對衝交易利潤，纍加總計;
        y_maximum_drawdown = Core.nothing;  # Core.Float64(0.0);
        y_total_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_maximum_drawdown_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_Positive = Core.nothing;  # Core.Float64(0.0);  # Core.Float64(y_Positive_Long_Position + y_Positive_Short_Selling);  # 交易規則正利潤纍計;
        y_Positive_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_Negative = Core.nothing;  # Core.Float64(0.0);  # Core.Float64(y_Negative_Long_Position + y_Negative_Short_Selling);  # 交易規則負利潤纍計;
        y_Negative_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_P_Positive = Core.nothing;  # Core.Float64(0.0);  # 交易規則正利潤出現頻率;
        y_P_Positive_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_P_Negative = Core.nothing;  # Core.Float64(0.0);  # 交易規則負利潤出現頻率;
        y_P_Negative_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        # if Core.Int64(Base.length(y_A_Long_Position)) > Core.Int64(0) || Core.Int64(Base.length(y_A_Short_Selling)) > Core.Int64(0)
        #     y_Positive_count_Long_Position = Core.Int64(0);
        #     y_Negative_count_Long_Position = Core.Int64(0);
        #     y_Positive_count_Short_Selling = Core.Int64(0);
        #     y_Negative_count_Short_Selling = Core.Int64(0);
        #     if Core.Int64(Base.length(y_A_Long_Position)) > Core.Int64(0)
        #         # y_Positive_count_Long_Position = Core.Int64(Base.sum([if Core.Float64(y_A_Long_Position[i]) > Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(y_A_Long_Position)]));
        #         y_Positive_count_Long_Position = Core.Int64(Base.sum([(Core.Float64(y_A_Long_Position[i]) > Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(y_A_Long_Position)]));
        #         # y_Negative_count_Long_Position = Core.Int64(Base.sum([if Core.Float64(y_A_Long_Position[i]) < Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(y_A_Long_Position)]));
        #         y_Negative_count_Long_Position = Core.Int64(Base.sum([(Core.Float64(y_A_Long_Position[i]) < Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(y_A_Long_Position)]));
        #     end
        #     if Core.Int64(Base.length(y_A_Short_Selling)) > Core.Int64(0)
        #         # y_Positive_count_Short_Selling = Core.Int64(Base.sum([if Core.Float64(y_A_Short_Selling[i]) > Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(y_A_Short_Selling)]));
        #         y_Positive_count_Short_Selling = Core.Int64(Base.sum([(Core.Float64(y_A_Short_Selling[i]) > Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(y_A_Short_Selling)]));
        #         # y_Negative_count_Short_Selling = Core.Int64(Base.sum([if Core.Float64(y_A_Short_Selling[i]) < Core.Float64(0.0) Core.Int64(1) else Core.Int64(0) end for i in 1:Base.length(y_A_Short_Selling)]));
        #         y_Negative_count_Short_Selling = Core.Int64(Base.sum([(Core.Float64(y_A_Short_Selling[i]) < Core.Float64(0.0)) ? Core.Int64(1) : Core.Int64(0) for i in 1:Base.length(y_A_Short_Selling)]));
        #     end
        #     y_P_Positive = Core.Float64(Core.Int64(Core.Int64(y_Positive_count_Long_Position) + Core.Int64(y_Positive_count_Short_Selling)) / Core.Int64(Core.Int64(Base.length(y_A_Long_Position)) + Core.Int64(Base.length(y_A_Short_Selling))));
        #     y_P_Negative = Core.Float64(Core.Int64(Core.Int64(y_Negative_count_Long_Position) + Core.Int64(y_Negative_count_Short_Selling)) / Core.Int64(Core.Int64(Base.length(y_A_Long_Position)) + Core.Int64(Base.length(y_A_Short_Selling))));
        # end
        y_amplitude = Core.nothing;  # Core.Float64(0.0);  # Core.Float64(Core.Float64(y_amplitude_Long_Position + y_amplitude_Short_Selling) / Core.Int64(2));  # amplitude_rate;
        y_amplitude_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_turnover = Core.nothing;  # Core.Float64(0.0);  # Core.Float64(Core.Float64(y_turnover_Long_Position + y_turnover_Short_Selling) / Core.Int64(2));  # turnover_volume; turnover_rate;
        y_turnover_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_date_transaction_between = Core.nothing;  # Core.Float64(0.0);  # Core.Float64(Core.Float64(y_date_transaction_between_Long_Position + y_date_transaction_between_Short_Selling) / Core.Int64(2));  # Between two date_transaction;
        y_date_transaction_between_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_profit = Core.nothing;  # Core.Float64(0.0);  # Core.Float64(Core.Float64(y_Long_Position_profit) + Core.Float64(y_Short_Selling_profit));  # 優化目標變量，利潤 × 權重;
        y_loss = Core.nothing;  # Core.Float64(0.0);  # Core.Float64(Base.findmin([Core.Float64(y_Long_Position_loss), Core.Float64(y_Short_Selling_loss)])[1]);  # 優化目標變量，最大回撤 × 權重;
        y_profit_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        y_loss_Array = Core.Array{Core.Float64, 1}();  # Core.Array{Core.Any, 1}();
        for (key, value) in profit_paired_data_transaction_sequence_Dict
            if Base.isa(value, Base.Dict)

                # 做多（Long Position）記錄;
                if Base.haskey(value, "Long_Position") && Base.isa(value["Long_Position"], Base.Dict)
                    if Base.haskey(value["Long_Position"], "Long_Position_number_total")
                        if !(Base.ismissing(value["Long_Position"]["Long_Position_number_total"]) || Base.isnothing(value["Long_Position"]["Long_Position_number_total"]))
                            # 取總和;
                            number_total_Long_Position_2 = Core.Int64(Core.Int64(number_total_Long_Position) + Core.Int64(value["Long_Position"]["Long_Position_number_total"]));
                            # global number_total_Long_Position *= Core.Int64(0);
                            number_total_Long_Position *= Core.Int64(0);
                            # global number_total_Long_Position += Core.Int64(number_total_Long_Position_2);
                            number_total_Long_Position += Core.Int64(number_total_Long_Position_2);
                        end
                    end
                    if Base.haskey(value["Long_Position"], "Long_Position_profit_total")
                        if !(Base.ismissing(value["Long_Position"]["Long_Position_profit_total"]) || Base.isnothing(value["Long_Position"]["Long_Position_profit_total"]))
                            if Core.Int64(Base.length(weight_PickStock_Dict)) > Core.Int64(0)
                                if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Long_Position")
                                    y_total_Long_Position_2 = Core.Float64(Core.Float64(value["Long_Position"]["Long_Position_profit_total"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Long_Position"]));
                                else
                                    y_total_Long_Position_2 = Core.Float64(value["Long_Position"]["Long_Position_profit_total"]);
                                end
                            else
                                y_total_Long_Position_2 = Core.Float64(value["Long_Position"]["Long_Position_profit_total"]);
                            end
                            # 取總和;
                            # y_total_Long_Position_2 = Core.Float64(Core.Float64(y_total_Long_Position) + Core.Float64(value["Long_Position"]["Long_Position_profit_total"]));
                            # y_total_Long_Position *= Core.Float64(0.0);
                            # y_total_Long_Position += Core.Float64(y_total_Long_Position_2);
                            Base.push!(y_total_Long_Position_Array, y_total_Long_Position_2);  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Long_Position"], "maximum_drawdown_Long_Position")
                        if !(Base.ismissing(value["Long_Position"]["maximum_drawdown_Long_Position"]) || Base.isnothing(value["Long_Position"]["maximum_drawdown_Long_Position"]))
                            if Core.Int64(Base.length(weight_PickStock_Dict)) > Core.Int64(0)
                                if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Long_Position")
                                    y_maximum_drawdown_Long_Position_2 = Core.Float64(Core.Float64(value["Long_Position"]["maximum_drawdown_Long_Position"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Long_Position"]));
                                else
                                    y_maximum_drawdown_Long_Position_2 = Core.Float64(value["Long_Position"]["maximum_drawdown_Long_Position"]);
                                end
                            else
                                y_maximum_drawdown_Long_Position_2 = Core.Float64(value["Long_Position"]["maximum_drawdown_Long_Position"]);
                            end
                            # # 取均值;
                            # y_maximum_drawdown_Long_Position_2 = Core.Float64(Core.Float64(Core.Float64(y_maximum_drawdown_Long_Position) + Core.Float64(value["Long_Position"]["maximum_drawdown_Long_Position"])) / Core.Int64(2));
                            # # 取最大值;
                            # y_maximum_drawdown_Long_Position_2 = Core.Float64(Base.findmax([Core.Float64(y_maximum_drawdown_Long_Position), Core.Float64(value["Long_Position"]["maximum_drawdown_Long_Position"])])[1]);
                            # # 取最小值;
                            # y_maximum_drawdown_Long_Position_2 = Core.Float64(Base.findmin([Core.Float64(y_maximum_drawdown_Long_Position), Core.Float64(value["Long_Position"]["maximum_drawdown_Long_Position"])])[1]);
                            # y_maximum_drawdown_Long_Position *= Core.Float64(0.0);
                            # y_maximum_drawdown_Long_Position += Core.Float64(y_maximum_drawdown_Long_Position_2);
                            Base.push!(y_maximum_drawdown_Long_Position_Array, y_maximum_drawdown_Long_Position_2);  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Long_Position"], "Long_Position_profit_Positive")
                        if !(Base.ismissing(value["Long_Position"]["Long_Position_profit_Positive"]) || Base.isnothing(value["Long_Position"]["Long_Position_profit_Positive"]))
                            if Core.Int64(Base.length(weight_PickStock_Dict)) > Core.Int64(0)
                                if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Long_Position")
                                    y_Positive_Long_Position_2 = Core.Float64(Core.Float64(value["Long_Position"]["Long_Position_profit_Positive"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Long_Position"]));
                                else
                                    y_Positive_Long_Position_2 = Core.Float64(value["Long_Position"]["Long_Position_profit_Positive"]);
                                end
                            else
                                y_Positive_Long_Position_2 = Core.Float64(value["Long_Position"]["Long_Position_profit_Positive"]);
                            end
                            # 取總和;
                            # y_Positive_Long_Position_2 = Core.Float64(Core.Float64(y_Positive_Long_Position) + Core.Float64(value["Long_Position"]["Long_Position_profit_Positive"]));
                            # y_Positive_Long_Position *= Core.Float64(0.0);
                            # y_Positive_Long_Position += Core.Float64(y_Positive_Long_Position_2);
                            Base.push!(y_Positive_Long_Position_Array, y_Positive_Long_Position_2);  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Long_Position"], "Long_Position_profit_Negative")
                        if !(Base.ismissing(value["Long_Position"]["Long_Position_profit_Negative"]) || Base.isnothing(value["Long_Position"]["Long_Position_profit_Negative"]))
                            if Core.Int64(Base.length(weight_PickStock_Dict)) > Core.Int64(0)
                                if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Long_Position")
                                    y_Negative_Long_Position_2 = Core.Float64(Core.Float64(value["Long_Position"]["Long_Position_profit_Negative"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Long_Position"]));
                                else
                                    y_Negative_Long_Position_2 = Core.Float64(value["Long_Position"]["Long_Position_profit_Negative"]);
                                end
                            else
                                y_Negative_Long_Position_2 = Core.Float64(value["Long_Position"]["Long_Position_profit_Negative"]);
                            end
                            # 取總和;
                            # y_Negative_Long_Position_2 = Core.Float64(Core.Float64(y_Negative_Long_Position) + Core.Float64(value["Long_Position"]["Long_Position_profit_Negative"]));
                            # y_Negative_Long_Position *= Core.Float64(0.0);
                            # y_Negative_Long_Position += Core.Float64(y_Negative_Long_Position_2);
                            Base.push!(y_Negative_Long_Position_Array, y_Negative_Long_Position_2);  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Long_Position"], "Long_Position_profit_Positive_probability")
                        if !(Base.ismissing(value["Long_Position"]["Long_Position_profit_Positive_probability"]) || Base.isnothing(value["Long_Position"]["Long_Position_profit_Positive_probability"]))
                            # 取均值;
                            # y_P_Positive_Long_Position_2 = Core.Float64(Core.Float64(Core.Float64(y_P_Positive_Long_Position) + Core.Float64(value["Long_Position"]["Long_Position_profit_Positive_probability"])) / Core.Int64(2));
                            # # 取最大值;
                            # y_P_Positive_Long_Position_2 = Core.Float64(Base.findmax([Core.Float64(y_P_Positive_Long_Position), Core.Float64(value["Long_Position"]["Long_Position_profit_Positive_probability"])])[1]);
                            # # 取最小值;
                            # y_P_Positive_Long_Position_2 = Core.Float64(Base.findmin([Core.Float64(y_P_Positive_Long_Position), Core.Float64(value["Long_Position"]["Long_Position_profit_Positive_probability"])])[1]);
                            # y_P_Positive_Long_Position *= Core.Float64(0.0);
                            # y_P_Positive_Long_Position += Core.Float64(y_P_Positive_Long_Position_2);
                            Base.push!(y_P_Positive_Long_Position_Array, Core.Float64(value["Long_Position"]["Long_Position_profit_Positive_probability"]));  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Long_Position"], "Long_Position_profit_Negative_probability")
                        if !(Base.ismissing(value["Long_Position"]["Long_Position_profit_Negative_probability"]) || Base.isnothing(value["Long_Position"]["Long_Position_profit_Negative_probability"]))
                            # # 取均值;
                            # y_P_Negative_Long_Position_2 = Core.Float64(Core.Float64(Core.Float64(y_P_Negative_Long_Position) + Core.Float64(value["Long_Position"]["Long_Position_profit_Negative_probability"])) / Core.Int64(2));
                            # 取最大值;
                            # y_P_Negative_Long_Position_2 = Core.Float64(Base.findmax([Core.Float64(y_P_Negative_Long_Position), Core.Float64(value["Long_Position"]["Long_Position_profit_Negative_probability"])])[1]);
                            # # 取最小值;
                            # y_P_Negative_Long_Position_2 = Core.Float64(Base.findmin([Core.Float64(y_P_Negative_Long_Position), Core.Float64(value["Long_Position"]["Long_Position_profit_Negative_probability"])])[1]);
                            # y_P_Negative_Long_Position *= Core.Float64(0.0);
                            # y_P_Negative_Long_Position += Core.Float64(y_P_Negative_Long_Position_2);
                            Base.push!(y_P_Negative_Long_Position_Array, Core.Float64(value["Long_Position"]["Long_Position_profit_Negative_probability"]));  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Long_Position"], "Long_Position_average_price_amplitude_date_transaction")
                        if !(Base.ismissing(value["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"]) || Base.isnothing(value["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"]))
                            # # 取均值;
                            # y_amplitude_Long_Position_2 = Core.Float64(Core.Float64(Core.Float64(y_amplitude_Long_Position) + Core.Float64(value["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"])) / Core.Int64(2));
                            # 取最大值;
                            # y_amplitude_Long_Position_2 = Core.Float64(Base.findmax([Core.Float64(y_amplitude_Long_Position), Core.Float64(value["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"])])[1]);
                            # # 取最小值;
                            # y_amplitude_Long_Position_2 = Core.Float64(Base.findmin([Core.Float64(y_amplitude_Long_Position), Core.Float64(value["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"])])[1]);
                            # y_amplitude_Long_Position *= Core.Float64(0.0);
                            # y_amplitude_Long_Position += Core.Float64(y_amplitude_Long_Position_2);
                            Base.push!(y_amplitude_Long_Position_Array, Core.Float64(value["Long_Position"]["Long_Position_average_price_amplitude_date_transaction"]));  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Long_Position"], "Long_Position_average_volume_turnover_date_transaction")
                        if !(Base.ismissing(value["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"]) || Base.isnothing(value["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"]))
                            # # 取均值;
                            # y_turnover_Long_Position_2 = Core.Float64(Core.Float64(Core.Float64(y_turnover_Long_Position) + Core.Float64(value["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"])) / Core.Int64(2));
                            # # 取最大值;
                            # y_turnover_Long_Position_2 = Core.Float64(Base.findmax([Core.Float64(y_turnover_Long_Position), Core.Float64(value["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"])])[1]);
                            # 取最小值;
                            # y_turnover_Long_Position_2 = Core.Float64(Base.findmin([Core.Float64(y_turnover_Long_Position), Core.Float64(value["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"])])[1]);
                            # y_turnover_Long_Position *= Core.Float64(0.0);
                            # y_turnover_Long_Position += Core.Float64(y_turnover_Long_Position_2);
                            Base.push!(y_turnover_Long_Position_Array, Core.Float64(value["Long_Position"]["Long_Position_average_volume_turnover_date_transaction"]));  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Long_Position"], "Long_Position_average_date_transaction_between")
                        if !(Base.ismissing(value["Long_Position"]["Long_Position_average_date_transaction_between"]) || Base.isnothing(value["Long_Position"]["Long_Position_average_date_transaction_between"]))
                            # # 取均值;
                            # y_date_transaction_between_Long_Position_2 = Core.Float64(Core.Float64(Core.Float64(y_date_transaction_between_Long_Position) + Core.Float64(value["Long_Position"]["Long_Position_average_date_transaction_between"])) / Core.Int64(2));
                            # 取最大值;
                            # y_date_transaction_between_Long_Position_2 = Core.Float64(Base.findmax([Core.Float64(y_date_transaction_between_Long_Position), Core.Float64(value["Long_Position"]["Long_Position_average_date_transaction_between"])])[1]);
                            # # 取最小值;
                            # y_date_transaction_between_Long_Position_2 = Core.Float64(Base.findmin([Core.Float64(y_date_transaction_between_Long_Position), Core.Float64(value["Long_Position"]["Long_Position_average_date_transaction_between"])])[1]);
                            # y_date_transaction_between_Long_Position *= Core.Float64(0.0);
                            # y_date_transaction_between_Long_Position += Core.Float64(y_date_transaction_between_Long_Position_2);
                            Base.push!(y_date_transaction_between_Long_Position_Array, Core.Float64(value["Long_Position"]["Long_Position_average_date_transaction_between"]));  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Long_Position"], "y_Long_Position_profit")
                        if !(Base.ismissing(value["Long_Position"]["y_Long_Position_profit"]) || Base.isnothing(value["Long_Position"]["y_Long_Position_profit"]))
                            # 取總和;
                            if Core.Int64(Base.length(weight_PickStock_Dict)) > Core.Int64(0)
                                if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Long_Position")
                                    y_Long_Position_profit_2 = Core.Float64(Core.Float64(value["Long_Position"]["y_Long_Position_profit"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Long_Position"]));
                                else
                                    y_Long_Position_profit_2 = Core.Float64(value["Long_Position"]["y_Long_Position_profit"]);
                                end
                            else
                                y_Long_Position_profit_2 = Core.Float64(value["Long_Position"]["y_Long_Position_profit"]);
                            end
                            Base.push!(y_Long_Position_profit_Array, y_Long_Position_profit_2);  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Long_Position"], "y_Long_Position_loss")
                        if !(Base.ismissing(value["Long_Position"]["y_Long_Position_loss"]) || Base.isnothing(value["Long_Position"]["y_Long_Position_loss"]))
                            # # 取均值;
                            # y_Long_Position_loss_2 = Core.Float64(Core.Float64(Core.Float64(y_Long_Position_loss) + Core.Float64(value["Long_Position"]["y_Long_Position_loss"])) / Core.Int64(2));
                            # # 取最大值;
                            # y_Long_Position_loss_2 = Core.Float64(Base.findmax([Core.Float64(y_Long_Position_loss), Core.Float64(value["Long_Position"]["y_Long_Position_loss"])])[1]);
                            # # 取最小值;
                            # y_Long_Position_loss_2 = Core.Float64(Base.findmin([Core.Float64(y_Long_Position_loss), Core.Float64(value["Long_Position"]["y_Long_Position_loss"])])[1]);
                            # y_Long_Position_loss *= Core.Float64(0.0);
                            # y_Long_Position_loss += Core.Float64(y_Long_Position_loss_2);
                            if Core.Int64(Base.length(weight_PickStock_Dict)) > Core.Int64(0)
                                if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Long_Position")
                                    y_Long_Position_loss_2 = Core.Float64(Core.Float64(value["Long_Position"]["y_Long_Position_loss"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Long_Position"]));
                                else
                                    y_Long_Position_loss_2 = Core.Float64(value["Long_Position"]["y_Long_Position_loss"]);
                                end
                            else
                                y_Long_Position_loss_2 = Core.Float64(value["Long_Position"]["y_Long_Position_loss"]);
                            end
                            Base.push!(y_Long_Position_loss_Array, y_Long_Position_loss_2);  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                end

                # 做空（Short Selling）記錄;
                if Base.haskey(value, "Short_Selling") && Base.isa(value["Short_Selling"], Base.Dict)
                    if Base.haskey(value["Short_Selling"], "Short_Selling_number_total")
                        if !(Base.ismissing(value["Short_Selling"]["Short_Selling_number_total"]) || Base.isnothing(value["Short_Selling"]["Short_Selling_number_total"]))
                            # 取總和;
                            number_total_Short_Selling_2 = Core.Int64(Core.Int64(number_total_Short_Selling) + Core.Int64(value["Short_Selling"]["Short_Selling_number_total"]));
                            # global number_total_Short_Selling *= Core.Int64(0);
                            number_total_Short_Selling *= Core.Int64(0);
                            # global number_total_Short_Selling += Core.Int64(number_total_Short_Selling_2);
                            number_total_Short_Selling += Core.Int64(number_total_Short_Selling_2);
                        end
                    end
                    if Base.haskey(value["Short_Selling"], "Short_Selling_profit_total")
                        if !(Base.ismissing(value["Short_Selling"]["Short_Selling_profit_total"]) || Base.isnothing(value["Short_Selling"]["Short_Selling_profit_total"]))
                            if Core.Int64(Base.length(weight_PickStock_Dict)) > Core.Int64(0)
                                if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Short_Selling")
                                    y_total_Short_Selling_2 = Core.Float64(Core.Float64(value["Short_Selling"]["Short_Selling_profit_total"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Short_Selling"]));
                                else
                                    y_total_Short_Selling_2 = Core.Float64(value["Short_Selling"]["Short_Selling_profit_total"]);
                                end
                            else
                                y_total_Short_Selling_2 = Core.Float64(value["Short_Selling"]["Short_Selling_profit_total"]);
                            end
                            # 取總和;
                            # y_total_Short_Selling_2 = Core.Float64(Core.Float64(y_total_Short_Selling) + Core.Float64(value["Short_Selling"]["Short_Selling_profit_total"]));
                            # y_total_Short_Selling *= Core.Float64(0.0);
                            # y_total_Short_Selling += Core.Float64(y_total_Short_Selling_2);
                            Base.push!(y_total_Short_Selling_Array, y_total_Short_Selling_2);  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Short_Selling"], "maximum_drawdown_Short_Selling")
                        if !(Base.ismissing(value["Short_Selling"]["maximum_drawdown_Short_Selling"]) || Base.isnothing(value["Short_Selling"]["maximum_drawdown_Short_Selling"]))
                            if Core.Int64(Base.length(weight_PickStock_Dict)) > Core.Int64(0)
                                if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Short_Selling")
                                    y_maximum_drawdown_Short_Selling_2 = Core.Float64(Core.Float64(value["Short_Selling"]["maximum_drawdown_Short_Selling"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Short_Selling"]));
                                else
                                    y_maximum_drawdown_Short_Selling_2 = Core.Float64(value["Short_Selling"]["maximum_drawdown_Short_Selling"]);
                                end
                            else
                                y_maximum_drawdown_Short_Selling_2 = Core.Float64(value["Short_Selling"]["maximum_drawdown_Short_Selling"]);
                            end
                            # # 取均值;
                            # y_maximum_drawdown_Short_Selling_2 = Core.Float64(Core.Float64(Core.Float64(y_maximum_drawdown_Short_Selling) + Core.Float64(value["Short_Selling"]["maximum_drawdown_Short_Selling"])) / Core.Int64(2));
                            # # 取最大值;
                            # y_maximum_drawdown_Short_Selling_2 = Core.Float64(Base.findmax([Core.Float64(y_maximum_drawdown_Short_Selling), Core.Float64(value["Short_Selling"]["maximum_drawdown_Short_Selling"])])[1]);
                            # # 取最小值;
                            # y_maximum_drawdown_Short_Selling_2 = Core.Float64(Base.findmin([Core.Float64(y_maximum_drawdown_Short_Selling), Core.Float64(value["Short_Selling"]["maximum_drawdown_Short_Selling"])])[1]);
                            # y_maximum_drawdown_Short_Selling *= Core.Float64(0.0);
                            # y_maximum_drawdown_Short_Selling += Core.Float64(y_maximum_drawdown_Short_Selling_2);
                            Base.push!(y_maximum_drawdown_Short_Selling_Array, y_maximum_drawdown_Short_Selling_2);  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Short_Selling"], "Short_Selling_profit_Positive")
                        if !(Base.ismissing(value["Short_Selling"]["Short_Selling_profit_Positive"]) || Base.isnothing(value["Short_Selling"]["Short_Selling_profit_Positive"]))
                            if Core.Int64(Base.length(weight_PickStock_Dict)) > Core.Int64(0)
                                if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Short_Selling")
                                    y_Positive_Short_Selling_2 = Core.Float64(Core.Float64(value["Short_Selling"]["Short_Selling_profit_Positive"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Short_Selling"]));
                                else
                                    y_Positive_Short_Selling_2 = Core.Float64(value["Short_Selling"]["Short_Selling_profit_Positive"]);
                                end
                            else
                                y_Positive_Short_Selling_2 = Core.Float64(value["Short_Selling"]["Short_Selling_profit_Positive"]);
                            end
                            # 取總和;
                            # y_Positive_Short_Selling_2 = Core.Float64(Core.Float64(y_Positive_Short_Selling) + Core.Float64(value["Short_Selling"]["Short_Selling_profit_Positive"]));
                            # y_Positive_Short_Selling *= Core.Float64(0.0);
                            # y_Positive_Short_Selling += Core.Float64(y_Positive_Short_Selling_2);
                            Base.push!(y_Positive_Short_Selling_Array, y_Positive_Short_Selling_2);  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Short_Selling"], "Short_Selling_profit_Negative")
                        if !(Base.ismissing(value["Short_Selling"]["Short_Selling_profit_Negative"]) || Base.isnothing(value["Short_Selling"]["Short_Selling_profit_Negative"]))
                            if Core.Int64(Base.length(weight_PickStock_Dict)) > Core.Int64(0)
                                if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Short_Selling")
                                    y_Negative_Short_Selling_2 = Core.Float64(Core.Float64(value["Short_Selling"]["Short_Selling_profit_Negative"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Short_Selling"]));
                                else
                                    y_Negative_Short_Selling_2 = Core.Float64(value["Short_Selling"]["Short_Selling_profit_Negative"]);
                                end
                            else
                                y_Negative_Short_Selling_2 = Core.Float64(value["Short_Selling"]["Short_Selling_profit_Negative"]);
                            end
                            # 取總和;
                            # y_Negative_Short_Selling_2 = Core.Float64(Core.Float64(y_Negative_Short_Selling) + Core.Float64(value["Short_Selling"]["Short_Selling_profit_Negative"]));
                            # y_Negative_Short_Selling *= Core.Float64(0.0);
                            # y_Negative_Short_Selling += Core.Float64(y_Negative_Short_Selling_2);
                            Base.push!(y_Negative_Short_Selling_Array, y_Negative_Short_Selling_2);  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Short_Selling"], "Short_Selling_profit_Positive_probability")
                        if !(Base.ismissing(value["Short_Selling"]["Short_Selling_profit_Positive_probability"]) || Base.isnothing(value["Short_Selling"]["Short_Selling_profit_Positive_probability"]))
                            # 取均值;
                            # y_P_Positive_Short_Selling_2 = Core.Float64(Core.Float64(Core.Float64(y_P_Positive_Short_Selling) + Core.Float64(value["Short_Selling"]["Short_Selling_profit_Positive_probability"])) / Core.Int64(2));
                            # # 取最大值;
                            # y_P_Positive_Short_Selling_2 = Core.Float64(Base.findmax([Core.Float64(y_P_Positive_Short_Selling), Core.Float64(value["Short_Selling"]["Short_Selling_profit_Positive_probability"])])[1]);
                            # # 取最小值;
                            # y_P_Positive_Short_Selling_2 = Core.Float64(Base.findmin([Core.Float64(y_P_Positive_Short_Selling), Core.Float64(value["Short_Selling"]["Short_Selling_profit_Positive_probability"])])[1]);
                            # y_P_Positive_Short_Selling *= Core.Float64(0.0);
                            # y_P_Positive_Short_Selling += Core.Float64(y_P_Positive_Short_Selling_2);
                            Base.push!(y_P_Positive_Short_Selling_Array, Core.Float64(value["Short_Selling"]["Short_Selling_profit_Positive_probability"]));  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Short_Selling"], "Short_Selling_profit_Negative_probability")
                        if !(Base.ismissing(value["Short_Selling"]["Short_Selling_profit_Negative_probability"]) || Base.isnothing(value["Short_Selling"]["Short_Selling_profit_Negative_probability"]))
                            # # 取均值;
                            # y_P_Negative_Short_Selling_2 = Core.Float64(Core.Float64(Core.Float64(y_P_Negative_Short_Selling) + Core.Float64(value["Short_Selling"]["Short_Selling_profit_Negative_probability"])) / Core.Int64(2));
                            # 取最大值;
                            # y_P_Negative_Short_Selling_2 = Core.Float64(Base.findmax([Core.Float64(y_P_Negative_Short_Selling), Core.Float64(value["Short_Selling"]["Short_Selling_profit_Negative_probability"])])[1]);
                            # # 取最小值;
                            # y_P_Negative_Short_Selling_2 = Core.Float64(Base.findmin([Core.Float64(y_P_Negative_Short_Selling), Core.Float64(value["Short_Selling"]["Short_Selling_profit_Negative_probability"])])[1]);
                            # y_P_Negative_Short_Selling *= Core.Float64(0.0);
                            # y_P_Negative_Short_Selling += Core.Float64(y_P_Negative_Short_Selling_2);
                            Base.push!(y_P_Negative_Short_Selling_Array, Core.Float64(value["Short_Selling"]["Short_Selling_profit_Negative_probability"]));  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Short_Selling"], "Short_Selling_average_price_amplitude_date_transaction")
                        if !(Base.ismissing(value["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"]) || Base.isnothing(value["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"]))
                            # # 取均值;
                            # y_amplitude_Short_Selling_2 = Core.Float64(Core.Float64(Core.Float64(y_amplitude_Short_Selling) + Core.Float64(value["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"])) / Core.Int64(2));
                            # 取最大值;
                            # y_amplitude_Short_Selling_2 = Core.Float64(Base.findmax([Core.Float64(y_amplitude_Short_Selling), Core.Float64(value["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"])])[1]);
                            # # 取最小值;
                            # y_amplitude_Short_Selling_2 = Core.Float64(Base.findmin([Core.Float64(y_amplitude_Short_Selling), Core.Float64(value["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"])])[1]);
                            # y_amplitude_Short_Selling *= Core.Float64(0.0);
                            # y_amplitude_Short_Selling += Core.Float64(y_amplitude_Short_Selling_2);
                            Base.push!(y_amplitude_Short_Selling_Array, Core.Float64(value["Short_Selling"]["Short_Selling_average_price_amplitude_date_transaction"]));  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Short_Selling"], "Short_Selling_average_volume_turnover_date_transaction")
                        if !(Base.ismissing(value["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"]) || Base.isnothing(value["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"]))
                            # # 取均值;
                            # y_turnover_Short_Selling_2 = Core.Float64(Core.Float64(Core.Float64(y_turnover_Short_Selling) + Core.Float64(value["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"])) / Core.Int64(2));
                            # # 取最大值;
                            # y_turnover_Short_Selling_2 = Core.Float64(Base.findmax([Core.Float64(y_turnover_Short_Selling), Core.Float64(value["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"])])[1]);
                            # 取最小值;
                            # y_turnover_Short_Selling_2 = Core.Float64(Base.findmin([Core.Float64(y_turnover_Short_Selling), Core.Float64(value["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"])])[1]);
                            # y_turnover_Short_Selling *= Core.Float64(0.0);
                            # y_turnover_Short_Selling += Core.Float64(y_turnover_Short_Selling_2);
                            Base.push!(y_turnover_Short_Selling_Array, Core.Float64(value["Short_Selling"]["Short_Selling_average_volume_turnover_date_transaction"]));  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Short_Selling"], "Short_Selling_average_date_transaction_between")
                        if !(Base.ismissing(value["Short_Selling"]["Short_Selling_average_date_transaction_between"]) || Base.isnothing(value["Short_Selling"]["Short_Selling_average_date_transaction_between"]))
                            # # 取均值;
                            # y_date_transaction_between_Short_Selling_2 = Core.Float64(Core.Float64(Core.Float64(y_date_transaction_between_Short_Selling) + Core.Float64(value["Short_Selling"]["Short_Selling_average_date_transaction_between"])) / Core.Int64(2));
                            # 取最大值;
                            # y_date_transaction_between_Short_Selling_2 = Core.Float64(Base.findmax([Core.Float64(y_date_transaction_between_Short_Selling), Core.Float64(value["Short_Selling"]["Short_Selling_average_date_transaction_between"])])[1]);
                            # # 取最小值;
                            # y_date_transaction_between_Short_Selling_2 = Core.Float64(Base.findmin([Core.Float64(y_date_transaction_between_Short_Selling), Core.Float64(value["Short_Selling"]["Short_Selling_average_date_transaction_between"])])[1]);
                            # y_date_transaction_between_Short_Selling *= Core.Float64(0.0);
                            # y_date_transaction_between_Short_Selling += Core.Float64(y_date_transaction_between_Short_Selling_2);
                            Base.push!(y_date_transaction_between_Short_Selling_Array, Core.Float64(value["Short_Selling"]["Short_Selling_average_date_transaction_between"]));  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Short_Selling"], "y_Short_Selling_profit")
                        if !(Base.ismissing(value["Short_Selling"]["y_Short_Selling_profit"]) || Base.isnothing(value["Short_Selling"]["y_Short_Selling_profit"]))
                            # 取總和;
                            if Core.Int64(Base.length(weight_PickStock_Dict)) > Core.Int64(0)
                                if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Short_Selling")
                                    y_Short_Selling_profit_2 = Core.Float64(Core.Float64(value["Short_Selling"]["y_Short_Selling_profit"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Short_Selling"]));
                                else
                                    y_Short_Selling_profit_2 = Core.Float64(value["Short_Selling"]["y_Short_Selling_profit"]);
                                end
                            else
                                y_Short_Selling_profit_2 = Core.Float64(value["Short_Selling"]["y_Short_Selling_profit"]);
                            end
                            Base.push!(y_Short_Selling_profit_Array, y_Short_Selling_profit_2);  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    if Base.haskey(value["Short_Selling"], "y_Short_Selling_loss")
                        if !(Base.ismissing(value["Short_Selling"]["y_Short_Selling_loss"]) || Base.isnothing(value["Short_Selling"]["y_Short_Selling_loss"]))
                            # # 取均值;
                            # y_Short_Selling_loss_2 = Core.Float64(Core.Float64(Core.Float64(y_Short_Selling_loss) + Core.Float64(value["Short_Selling"]["y_Short_Selling_loss"])) / Core.Int64(2));
                            # # 取最大值;
                            # y_Short_Selling_loss_2 = Core.Float64(Base.findmax([Core.Float64(y_Short_Selling_loss), Core.Float64(value["Short_Selling"]["y_Short_Selling_loss"])])[1]);
                            # # 取最小值;
                            # y_Short_Selling_loss_2 = Core.Float64(Base.findmin([Core.Float64(y_Short_Selling_loss), Core.Float64(value["Short_Selling"]["y_Short_Selling_loss"])])[1]);
                            # y_Short_Selling_loss *= Core.Float64(0.0);
                            # y_Short_Selling_loss += Core.Float64(y_Short_Selling_loss_2);
                            if Core.Int64(Base.length(weight_PickStock_Dict)) > Core.Int64(0)
                                if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Short_Selling")
                                    y_Short_Selling_loss_2 = Core.Float64(Core.Float64(value["Short_Selling"]["y_Short_Selling_loss"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Short_Selling"]));
                                else
                                    y_Short_Selling_loss_2 = Core.Float64(value["Short_Selling"]["y_Short_Selling_loss"]);
                                end
                            else
                                y_Short_Selling_loss_2 = Core.Float64(value["Short_Selling"]["y_Short_Selling_loss"]);
                            end
                            Base.push!(y_Short_Selling_loss_Array, y_Short_Selling_loss_2);  # 使用 push! 函數在數組末尾追加推入新元素;
                        end
                    end
                end

                # 做多（Long Position）記錄 + 做空（Short Selling）記錄，纍計求和;
                if Base.haskey(value, "profit_total")
                    if !(Base.ismissing(value["profit_total"]) || Base.isnothing(value["profit_total"]))
                        # 取總和;
                        # y_total_2 = Core.Float64(Core.Float64(y_total) + Core.Float64(value["profit_total"]));
                        # # 取均值;
                        # y_total_2 = Core.Float64(Core.Float64(Core.Float64(y_total) + Core.Float64(value["profit_total"])) / Core.Int64(2));
                        # # 取極大值;
                        # y_total_2 = Core.Float64(Base.findmax([Core.Float64(y_total), Core.Float64(value["profit_total"])])[1]);
                        # # 取極小值;
                        # y_total_2 = Core.Float64(Base.findmin([Core.Float64(y_total), Core.Float64(value["profit_total"])])[1]);
                        # y_total *= Core.Float64(0.0);
                        # y_total += Core.Float64(y_total_2);
                        Base.push!(y_total_Array, Core.Float64(value["profit_total"]));  # 使用 push! 函數在數組末尾追加推入新元素;
                    end
                end
                if Base.haskey(value, "maximum_drawdown")
                    if !(Base.ismissing(value["maximum_drawdown"]) || Base.isnothing(value["maximum_drawdown"]))
                        # # 取均值;
                        # y_maximum_drawdown_2 = Core.Float64(Core.Float64(Core.Float64(y_maximum_drawdown) + Core.Float64(value["maximum_drawdown"])) / Core.Int64(2));
                        # # 取最大值;
                        # y_maximum_drawdown_2 = Core.Float64(Base.findmax([Core.Float64(y_maximum_drawdown), Core.Float64(value["maximum_drawdown"])])[1]);
                        # # 取最小值;
                        # y_maximum_drawdown_2 = Core.Float64(Base.findmin([Core.Float64(y_maximum_drawdown), Core.Float64(value["maximum_drawdown"])])[1]);
                        # y_maximum_drawdown *= Core.Float64(0.0);
                        # y_maximum_drawdown += Core.Float64(y_maximum_drawdown_2);
                        Base.push!(y_maximum_drawdown_Array, Core.Float64(value["maximum_drawdown"]));  # 使用 push! 函數在數組末尾追加推入新元素;
                    end
                end
                if Base.haskey(value, "profit_Positive")
                    if !(Base.ismissing(value["profit_Positive"]) || Base.isnothing(value["profit_Positive"]))
                        # 取總和;
                        # y_Positive_2 = Core.Float64(Core.Float64(y_Positive) + Core.Float64(value["profit_Positive"]));
                        # # 取均值;
                        # y_Positive_2 = Core.Float64(Core.Float64(Core.Float64(y_Positive) + Core.Float64(value["profit_Positive"])) / Core.Int64(2));
                        # # 取極大值;
                        # y_Positive_2 = Core.Float64(Base.findmax([Core.Float64(y_Positive), Core.Float64(value["profit_Positive"])])[1]);
                        # # 取極小值;
                        # y_Positive_2 = Core.Float64(Base.findmin([Core.Float64(y_Positive), Core.Float64(value["profit_Positive"])])[1]);
                        # y_Positive *= Core.Float64(0.0);
                        # y_Positive += Core.Float64(y_Positive_2);
                        Base.push!(y_Positive_Array, Core.Float64(value["profit_Positive"]));  # 使用 push! 函數在數組末尾追加推入新元素;
                    end
                end
                if Base.haskey(value, "profit_Negative")
                    if !(Base.ismissing(value["profit_Negative"]) || Base.isnothing(value["profit_Negative"]))
                        # 取總和;
                        # y_Negative_2 = Core.Float64(Core.Float64(y_Negative) + Core.Float64(value["profit_Negative"]));
                        # # 取均值;
                        # y_Negative_2 = Core.Float64(Core.Float64(Core.Float64(y_Negative) + Core.Float64(value["profit_Negative"])) / Core.Int64(2));
                        # # 取極大值;
                        # y_Negative_2 = Core.Float64(Base.findmax([Core.Float64(y_Negative), Core.Float64(value["profit_Negative"])])[1]);
                        # # 取極小值;
                        # y_Negative_2 = Core.Float64(Base.findmin([Core.Float64(y_Negative), Core.Float64(value["profit_Negative"])])[1]);
                        # y_Negative *= Core.Float64(0.0);
                        # y_Negative += Core.Float64(y_Negative_2);
                        Base.push!(y_Negative_Array, Core.Float64(value["profit_Negative"]));  # 使用 push! 函數在數組末尾追加推入新元素;
                    end
                end
                if Base.haskey(value, "profit_Positive_probability")
                    if !(Base.ismissing(value["profit_Positive_probability"]) || Base.isnothing(value["profit_Positive_probability"]))
                        # # 取總和;
                        # y_P_Positive_2 = Core.Float64(Core.Float64(y_P_Positive) + Core.Float64(value["profit_Positive_probability"]));
                        # 取均值;
                        # y_P_Positive_2 = Core.Float64(Core.Float64(Core.Float64(y_P_Positive) + Core.Float64(value["profit_Positive_probability"])) / Core.Int64(2));
                        # # 取極大值;
                        # y_P_Positive_2 = Core.Float64(Base.findmax([Core.Float64(y_P_Positive), Core.Float64(value["profit_Positive_probability"])])[1]);
                        # # 取極小值;
                        # y_P_Positive_2 = Core.Float64(Base.findmin([Core.Float64(y_P_Positive), Core.Float64(value["profit_Positive_probability"])])[1]);
                        # y_P_Positive *= Core.Float64(0.0);
                        # y_P_Positive += Core.Float64(y_P_Positive_2);
                        Base.push!(y_P_Positive_Array, Core.Float64(value["profit_Positive_probability"]));  # 使用 push! 函數在數組末尾追加推入新元素;
                    end
                end
                if Base.haskey(value, "profit_Negative_probability")
                    if !(Base.ismissing(value["profit_Negative_probability"]) || Base.isnothing(value["profit_Negative_probability"]))
                        # # 取總和;
                        # y_P_Negative_2 = Core.Float64(Core.Float64(y_P_Negative) + Core.Float64(value["profit_Negative_probability"]));
                        # # 取均值;
                        # y_P_Negative_2 = Core.Float64(Core.Float64(Core.Float64(y_P_Negative) + Core.Float64(value["profit_Negative_probability"])) / Core.Int64(2));
                        # 取極大值;
                        # y_P_Negative_2 = Core.Float64(Base.findmax([Core.Float64(y_P_Negative), Core.Float64(value["profit_Negative_probability"])])[1]);
                        # # 取極小值;
                        # y_P_Negative_2 = Core.Float64(Base.findmin([Core.Float64(y_P_Negative), Core.Float64(value["profit_Negative_probability"])])[1]);
                        # y_P_Negative *= Core.Float64(0.0);
                        # y_P_Negative += Core.Float64(y_P_Negative_2);
                        Base.push!(y_P_Negative_Array, Core.Float64(value["profit_Negative_probability"]));  # 使用 push! 函數在數組末尾追加推入新元素;
                    end
                end
                if Base.haskey(value, "average_price_amplitude_date_transaction")
                    if !(Base.ismissing(value["average_price_amplitude_date_transaction"]) || Base.isnothing(value["average_price_amplitude_date_transaction"]))
                        # # 取總和;
                        # y_amplitude_2 = Core.Float64(Core.Float64(y_amplitude) + Core.Float64(value["average_price_amplitude_date_transaction"]));
                        # # 取均值;
                        # y_amplitude_2 = Core.Float64(Core.Float64(Core.Float64(y_amplitude) + Core.Float64(value["average_price_amplitude_date_transaction"])) / Core.Int64(2));
                        # 取極大值;
                        # y_amplitude_2 = Core.Float64(Base.findmax([Core.Float64(y_amplitude), Core.Float64(value["average_price_amplitude_date_transaction"])])[1]);
                        # # 取極小值;
                        # y_amplitude_2 = Core.Float64(Base.findmin([Core.Float64(y_amplitude), Core.Float64(value["average_price_amplitude_date_transaction"])])[1]);
                        # y_amplitude *= Core.Float64(0.0);
                        # y_amplitude += Core.Float64(y_amplitude_2);
                        Base.push!(y_amplitude_Array, Core.Float64(value["average_price_amplitude_date_transaction"]));  # 使用 push! 函數在數組末尾追加推入新元素;
                    end
                end
                if Base.haskey(value, "average_volume_turnover_date_transaction")
                    if !(Base.ismissing(value["average_volume_turnover_date_transaction"]) || Base.isnothing(value["average_volume_turnover_date_transaction"]))
                        # # 取總和;
                        # y_turnover_2 = Core.Float64(Core.Float64(y_turnover) + Core.Float64(value["average_volume_turnover_date_transaction"]));
                        # # 取均值;
                        # y_turnover_2 = Core.Float64(Core.Float64(Core.Float64(y_turnover) + Core.Float64(value["average_volume_turnover_date_transaction"])) / Core.Int64(2));
                        # # 取極大值;
                        # y_turnover_2 = Core.Float64(Base.findmax([Core.Float64(y_turnover), Core.Float64(value["average_volume_turnover_date_transaction"])])[1]);
                        # 取極小值;
                        # y_turnover_2 = Core.Float64(Base.findmin([Core.Float64(y_turnover), Core.Float64(value["average_volume_turnover_date_transaction"])])[1]);
                        # y_turnover *= Core.Float64(0.0);
                        # y_turnover += Core.Float64(y_turnover_2);
                        Base.push!(y_turnover_Array, Core.Float64(value["average_volume_turnover_date_transaction"]));  # 使用 push! 函數在數組末尾追加推入新元素;
                    end
                end
                if Base.haskey(value, "average_date_transaction_between")
                    if !(Base.ismissing(value["average_date_transaction_between"]) || Base.isnothing(value["average_date_transaction_between"]))
                        # # 取總和;
                        # y_date_transaction_between_2 = Core.Float64(Core.Float64(y_date_transaction_between) + Core.Float64(value["average_date_transaction_between"]));
                        # # 取均值;
                        # y_date_transaction_between_2 = Core.Float64(Core.Float64(Core.Float64(y_date_transaction_between) + Core.Float64(value["average_date_transaction_between"])) / Core.Int64(2));
                        # 取極大值;
                        # y_date_transaction_between_2 = Core.Float64(Base.findmax([Core.Float64(y_date_transaction_between), Core.Float64(value["average_date_transaction_between"])])[1]);
                        # # 取極小值;
                        # y_date_transaction_between_2 = Core.Float64(Base.findmin([Core.Float64(y_date_transaction_between), Core.Float64(value["average_date_transaction_between"])])[1]);
                        # y_date_transaction_between *= Core.Float64(0.0);
                        # y_date_transaction_between += Core.Float64(y_date_transaction_between_2);
                        Base.push!(y_date_transaction_between_Array, Core.Float64(value["average_date_transaction_between"]));  # 使用 push! 函數在數組末尾追加推入新元素;
                    end
                end
                if Base.haskey(value, "y_profit")
                    if !(Base.ismissing(value["y_profit"]) || Base.isnothing(value["y_profit"]))
                        # # 取總和;
                        # if Core.Int64(Base.length(weight_PickStock_Dict)) > Core.Int64(0)
                        #     if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Long_Position") && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Short_Selling")
                        #         y_profit_2 = Core.Float64(Core.Float64(y_profit) + Core.Float64(Core.Float64(value["y_profit"]) * Core.Float64(Core.Float64(weight_PickStock_Dict[Base.string(key)]["Long_Position"]) + Core.Float64(weight_PickStock_Dict[Base.string(key)]["Short_Selling"]))));
                        #     elseif Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Long_Position") && (!Base.haskey(weight_PickStock_Dict[Base.string(key)], "Short_Selling"))
                        #         y_profit_2 = Core.Float64(Core.Float64(y_profit) + Core.Float64(Core.Float64(value["y_profit"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Long_Position"])));
                        #     elseif Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && (!Base.haskey(weight_PickStock_Dict[Base.string(key)], "Long_Position")) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Short_Selling")
                        #         y_profit_2 = Core.Float64(Core.Float64(y_profit) + Core.Float64(Core.Float64(value["y_profit"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Short_Selling"])));
                        #     else
                        #         y_profit_2 = Core.Float64(Core.Float64(y_profit) + Core.Float64(value["y_profit"]));
                        #     end
                        # else
                        #     y_profit_2 = Core.Float64(Core.Float64(y_profit) + Core.Float64(value["y_profit"]));
                        # end
                        # # 取總和;
                        # y_profit_2 = Core.Float64(Core.Float64(y_profit) + Core.Float64(value["y_profit"]));
                        # # 取均值;
                        # y_profit_2 = Core.Float64(Core.Float64(Core.Float64(y_profit) + Core.Float64(value["y_profit"])) / Core.Int64(2));
                        # # 取極大值;
                        # y_profit_2 = Core.Float64(Base.findmax([Core.Float64(y_profit), Core.Float64(value["y_profit"])])[1]);
                        # # 取極小值;
                        # y_profit_2 = Core.Float64(Base.findmin([Core.Float64(y_profit), Core.Float64(value["y_profit"])])[1]);
                        # y_profit *= Core.Float64(0.0);
                        # y_profit += Core.Float64(y_profit_2);
                        if Core.Int64(Base.length(weight_PickStock_Dict)) > Core.Int64(0)
                            if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Long_Position") && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Short_Selling")
                                y_profit_2 = Core.Float64(Core.Float64(value["y_profit"]) * Core.Float64(Core.Float64(weight_PickStock_Dict[Base.string(key)]["Long_Position"]) + Core.Float64(weight_PickStock_Dict[Base.string(key)]["Short_Selling"])));
                            elseif Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Long_Position") && (!Base.haskey(weight_PickStock_Dict[Base.string(key)], "Short_Selling"))
                                y_profit_2 = Core.Float64(Core.Float64(value["y_profit"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Long_Position"]));
                            elseif Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && (!Base.haskey(weight_PickStock_Dict[Base.string(key)], "Long_Position")) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Short_Selling")
                                y_profit_2 = Core.Float64(Core.Float64(value["y_profit"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Short_Selling"]));
                            else
                                y_profit_2 = Core.Float64(value["y_profit"]);
                            end
                        else
                            y_profit_2 = Core.Float64(value["y_profit"]);
                        end
                        Base.push!(y_profit_Array, y_profit_2);  # 使用 push! 函數在數組末尾追加推入新元素;
                    end
                end
                if Base.haskey(value, "y_loss")
                    if !(Base.ismissing(value["y_loss"]) || Base.isnothing(value["y_loss"]))
                        # # 取均值;
                        # y_loss_2 = Core.Float64(Core.Float64(Core.Float64(y_loss) + Core.Float64(value["y_loss"])) / Core.Int64(2));
                        # # 取最大值;
                        # y_loss_2 = Core.Float64(Base.findmax([Core.Float64(y_loss), Core.Float64(value["y_loss"])])[1]);
                        # # 取最小值;
                        # y_loss_2 = Core.Float64(Base.findmin([Core.Float64(y_loss), Core.Float64(value["y_loss"])])[1]);
                        # y_loss *= Core.Float64(0.0);
                        # y_loss += Core.Float64(y_loss_2);
                        if Core.Int64(Base.length(weight_PickStock_Dict)) > Core.Int64(0)
                            if Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Long_Position") && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Short_Selling")
                                y_loss_2 = Core.Float64(Core.Float64(value["y_loss"]) * Core.Float64(Core.Float64(weight_PickStock_Dict[Base.string(key)]["Long_Position"]) + Core.Float64(weight_PickStock_Dict[Base.string(key)]["Short_Selling"])));
                            elseif Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Long_Position") && (!Base.haskey(weight_PickStock_Dict[Base.string(key)], "Short_Selling"))
                                y_loss_2 = Core.Float64(Core.Float64(value["y_loss"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Long_Position"]));
                            elseif Base.haskey(weight_PickStock_Dict, Base.string(key)) && Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict) && (!Base.haskey(weight_PickStock_Dict[Base.string(key)], "Long_Position")) && Base.haskey(weight_PickStock_Dict[Base.string(key)], "Short_Selling")
                                y_loss_2 = Core.Float64(Core.Float64(value["y_loss"]) * Core.Float64(weight_PickStock_Dict[Base.string(key)]["Short_Selling"]));
                            else
                                y_loss_2 = Core.Float64(value["y_loss"]);
                            end
                        else
                            y_loss_2 = Core.Float64(value["y_loss"]);
                        end
                        Base.push!(y_loss_Array, y_loss_2);  # 使用 push! 函數在數組末尾追加推入新元素;
                    end
                end
            end
        end
        number_total = Core.nothing;  # Core.Int64(Core.Int64(number_total_Long_Position) + Core.Int64(number_total_Short_Selling));  # 兩次對衝交易的總輪數，纍加總計;
        if (!(Base.ismissing(number_total_Long_Position) || Base.isnothing(number_total_Long_Position))) && (!(Base.ismissing(number_total_Short_Selling) || Base.isnothing(number_total_Short_Selling)))
            number_total = Core.Int64(Core.Int64(number_total_Long_Position) + Core.Int64(number_total_Short_Selling));  # 兩次對衝交易的總輪數，纍加總計;
        elseif (!(Base.ismissing(number_total_Long_Position) || Base.isnothing(number_total_Long_Position))) && (Base.ismissing(number_total_Short_Selling) || Base.isnothing(number_total_Short_Selling))
            number_total = Core.Int64(number_total_Long_Position);
        elseif (Base.ismissing(number_total_Long_Position) || Base.isnothing(number_total_Long_Position)) && (!(Base.ismissing(number_total_Short_Selling) || Base.isnothing(number_total_Short_Selling)))
            number_total = Core.Int64(number_total_Short_Selling);
        else
            number_total = Core.nothing;  # Core.Int64(Core.Int64(number_total_Long_Position) + Core.Int64(number_total_Short_Selling));  # 兩次對衝交易的總輪數，纍加總計;
        end
        if Core.Int64(Base.length(y_total_Long_Position_Array)) > Core.Int64(0)
            # y_total_Long_Position = Core.Float64(Base.findmin(y_total_Long_Position_Array)[1]);
            y_total_Long_Position = Core.Float64(Base.sum(y_total_Long_Position_Array));
        end
        y_total_Long_Position_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_total_Short_Selling_Array)) > Core.Int64(0)
            # y_total_Short_Selling = Core.Float64(Base.findmin(y_total_Short_Selling_Array)[1]);
            y_total_Short_Selling = Core.Float64(Base.sum(y_total_Short_Selling_Array));
        end
        y_total_Short_Selling_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_total_Array)) > Core.Int64(0)
            # y_total = Core.Float64(Base.findmin(y_total_Array)[1]);
            y_total = Core.Float64(Base.sum(y_total_Array));
        end
        y_total_Array = Core.nothing;  # 釋放内存;
        # y_total = Core.nothing;  # Core.Float64(0.0);  # Core.Float64(Core.Float64(y_total_Long_Position) + Core.Float64(y_total_Short_Selling));  # 每兩次對衝交易利潤，纍加總計;
        if (!(Base.ismissing(y_total_Long_Position) || Base.isnothing(y_total_Long_Position))) && (!(Base.ismissing(y_total_Short_Selling) || Base.isnothing(y_total_Short_Selling)))
            y_total = Core.Float64(Core.Float64(y_total_Long_Position) + Core.Float64(y_total_Short_Selling));  # 每兩次對衝交易利潤，纍加總計;
        elseif (!(Base.ismissing(y_total_Long_Position) || Base.isnothing(y_total_Long_Position))) && (Base.ismissing(y_total_Short_Selling) || Base.isnothing(y_total_Short_Selling))
            y_total = Core.Float64(y_total_Long_Position);
        elseif (Base.ismissing(y_total_Long_Position) || Base.isnothing(y_total_Long_Position)) && (!(Base.ismissing(y_total_Short_Selling) || Base.isnothing(y_total_Short_Selling)))
            y_total = Core.Float64(y_total_Short_Selling);
        else
            y_total = Core.nothing;  # Core.Float64(Core.Float64(y_total_Long_Position) + Core.Float64(y_total_Short_Selling));  # 每兩次對衝交易利潤，纍加總計;
        end
        if Core.Int64(Base.length(y_maximum_drawdown_Long_Position_Array)) > Core.Int64(0)
            y_maximum_drawdown_Long_Position = Core.Float64(Base.findmin(y_maximum_drawdown_Long_Position_Array)[1]);
        end
        y_maximum_drawdown_Long_Position_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_maximum_drawdown_Short_Selling_Array)) > Core.Int64(0)
            y_maximum_drawdown_Short_Selling = Core.Float64(Base.findmin(y_maximum_drawdown_Short_Selling_Array)[1]);
        end
        y_maximum_drawdown_Short_Selling_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_maximum_drawdown_Array)) > Core.Int64(0)
            y_maximum_drawdown = Core.Float64(Base.findmin(y_maximum_drawdown_Array)[1]);
        end
        y_maximum_drawdown_Array = Core.nothing;  # 釋放内存;
        if (!(Base.ismissing(y_maximum_drawdown_Long_Position) || Base.isnothing(y_maximum_drawdown_Long_Position))) && (!(Base.ismissing(y_maximum_drawdown_Short_Selling) || Base.isnothing(y_maximum_drawdown_Short_Selling)))
            y_maximum_drawdown = Core.Float64(Base.findmin([y_maximum_drawdown_Long_Position, y_maximum_drawdown_Short_Selling])[1]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
        elseif (!(Base.ismissing(y_maximum_drawdown_Long_Position) || Base.isnothing(y_maximum_drawdown_Long_Position))) && (Base.ismissing(y_maximum_drawdown_Short_Selling) || Base.isnothing(y_maximum_drawdown_Short_Selling))
            y_maximum_drawdown = Core.Float64(y_maximum_drawdown_Long_Position);  # 兩次對衝交易之間的最大回撤值，取極值統計;
        elseif (Base.ismissing(y_maximum_drawdown_Long_Position) || Base.isnothing(y_maximum_drawdown_Long_Position)) && (!(Base.ismissing(y_maximum_drawdown_Short_Selling) || Base.isnothing(y_maximum_drawdown_Short_Selling)))
            y_maximum_drawdown = Core.Float64(y_maximum_drawdown_Short_Selling);  # 兩次對衝交易之間的最大回撤值，取極值統計;
        else
            y_maximum_drawdown = Core.nothing;
        end
        if Core.Int64(Base.length(y_Positive_Long_Position_Array)) > Core.Int64(0)
            # y_Positive_Long_Position = Core.Float64(Base.findmin(y_Positive_Long_Position_Array)[1]);
            y_Positive_Long_Position = Core.Float64(Base.sum(y_Positive_Long_Position_Array));
        end
        y_Positive_Long_Position_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_Positive_Short_Selling_Array)) > Core.Int64(0)
            # y_Positive_Short_Selling = Core.Float64(Base.findmin(y_Positive_Short_Selling_Array)[1]);
            y_Positive_Short_Selling = Core.Float64(Base.sum(y_Positive_Short_Selling_Array));
        end
        y_Positive_Short_Selling_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_Positive_Array)) > Core.Int64(0)
            # y_Positive = Core.Float64(Base.findmin(y_Positive_Array)[1]);
            y_Positive = Core.Float64(Base.sum(y_Positive_Array));
        end
        y_Positive_Array = Core.nothing;  # 釋放内存;
        # y_Positive = Core.nothing;  # Core.Float64(0.0);  # Core.Float64(Core.Float64(y_Positive_Long_Position) + Core.Float64(y_Positive_Short_Selling));
        if (!(Base.ismissing(y_Positive_Long_Position) || Base.isnothing(y_Positive_Long_Position))) && (!(Base.ismissing(y_Positive_Short_Selling) || Base.isnothing(y_Positive_Short_Selling)))
            y_Positive = Core.Float64(Core.Float64(y_Positive_Long_Position) + Core.Float64(y_Positive_Short_Selling));
        elseif (!(Base.ismissing(y_Positive_Long_Position) || Base.isnothing(y_Positive_Long_Position))) && (Base.ismissing(y_Positive_Short_Selling) || Base.isnothing(y_Positive_Short_Selling))
            y_Positive = Core.Float64(y_Positive_Long_Position);
        elseif (Base.ismissing(y_Positive_Long_Position) || Base.isnothing(y_Positive_Long_Position)) && (!(Base.ismissing(y_Positive_Short_Selling) || Base.isnothing(y_Positive_Short_Selling)))
            y_Positive = Core.Float64(y_Positive_Short_Selling);
        else
            y_Positive = Core.nothing;  # Core.Float64(Core.Float64(y_Positive_Long_Position) + Core.Float64(y_Positive_Short_Selling));
        end
        if Core.Int64(Base.length(y_Negative_Long_Position_Array)) > Core.Int64(0)
            # y_Negative_Long_Position = Core.Float64(Base.findmin(y_Negative_Long_Position_Array)[1]);
            y_Negative_Long_Position = Core.Float64(Base.sum(y_Negative_Long_Position_Array));
        end
        y_Negative_Long_Position_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_Negative_Short_Selling_Array)) > Core.Int64(0)
            # y_Negative_Short_Selling = Core.Float64(Base.findmin(y_Negative_Short_Selling_Array)[1]);
            y_Negative_Short_Selling = Core.Float64(Base.sum(y_Negative_Short_Selling_Array));
        end
        y_Negative_Short_Selling_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_Negative_Array)) > Core.Int64(0)
            # y_Negative = Core.Float64(Base.findmin(y_Negative_Array)[1]);
            y_Negative = Core.Float64(Base.sum(y_Negative_Array));
        end
        y_Negative_Array = Core.nothing;  # 釋放内存;
        # y_Negative = Core.nothing;  # Core.Float64(0.0);  # Core.Float64(Core.Float64(y_Negative_Long_Position) + Core.Float64(y_Negative_Short_Selling));
        if (!(Base.ismissing(y_Negative_Long_Position) || Base.isnothing(y_Negative_Long_Position))) && (!(Base.ismissing(y_Negative_Short_Selling) || Base.isnothing(y_Negative_Short_Selling)))
            y_Negative = Core.Float64(Core.Float64(y_Negative_Long_Position) + Core.Float64(y_Negative_Short_Selling));
        elseif (!(Base.ismissing(y_Negative_Long_Position) || Base.isnothing(y_Negative_Long_Position))) && (Base.ismissing(y_Negative_Short_Selling) || Base.isnothing(y_Negative_Short_Selling))
            y_Negative = Core.Float64(y_Negative_Long_Position);
        elseif (Base.ismissing(y_Negative_Long_Position) || Base.isnothing(y_Negative_Long_Position)) && (!(Base.ismissing(y_Negative_Short_Selling) || Base.isnothing(y_Negative_Short_Selling)))
            y_Negative = Core.Float64(y_Negative_Short_Selling);
        else
            y_Negative = Core.nothing;  # Core.Float64(Core.Float64(y_Negative_Long_Position) + Core.Float64(y_Negative_Short_Selling));
        end
        if Core.Int64(Base.length(y_P_Positive_Long_Position_Array)) > Core.Int64(0)
            # y_P_Positive_Long_Position = Core.Float64(Base.findmin(y_P_Positive_Long_Position_Array)[1]);
            # y_P_Positive_Long_Position = Core.Float64(Base.sum(y_P_Positive_Long_Position_Array));
            y_P_Positive_Long_Position = Core.Float64(Statistics.mean(y_P_Positive_Long_Position_Array));
        end
        y_P_Positive_Long_Position_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_P_Positive_Short_Selling_Array)) > Core.Int64(0)
            # y_P_Positive_Short_Selling = Core.Float64(Base.findmin(y_P_Positive_Short_Selling_Array)[1]);
            # y_P_Positive_Short_Selling = Core.Float64(Base.sum(y_P_Positive_Short_Selling_Array));
            y_P_Positive_Short_Selling = Core.Float64(Statistics.mean(y_P_Positive_Short_Selling_Array));
        end
        y_P_Positive_Short_Selling_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_P_Positive_Array)) > Core.Int64(0)
            # y_P_Positive = Core.Float64(Base.findmin(y_P_Positive_Array)[1]);
            # y_P_Positive = Core.Float64(Base.sum(y_P_Positive_Array));
            y_P_Positive = Core.Float64(Statistics.mean(y_P_Positive_Array));
        end
        y_P_Positive_Array = Core.nothing;  # 釋放内存;
        # y_P_Positive = Core.nothing;  # Core.Float64(0.0);  # Core.Float64(Core.Float64(y_P_Positive_Long_Position) + Core.Float64(y_P_Positive_Short_Selling));
        if (!(Base.ismissing(y_P_Positive_Long_Position) || Base.isnothing(y_P_Positive_Long_Position))) && (!(Base.ismissing(y_P_Positive_Short_Selling) || Base.isnothing(y_P_Positive_Short_Selling)))
            # y_P_Positive = Core.Float64(Core.Float64(y_P_Positive_Long_Position) + Core.Float64(y_P_Positive_Short_Selling));
            y_P_Positive = Core.Float64(Statistics.mean([Core.Float64(y_P_Positive_Long_Position), Core.Float64(y_P_Positive_Short_Selling)]));
        elseif (!(Base.ismissing(y_P_Positive_Long_Position) || Base.isnothing(y_P_Positive_Long_Position))) && (Base.ismissing(y_P_Positive_Short_Selling) || Base.isnothing(y_P_Positive_Short_Selling))
            y_P_Positive = Core.Float64(y_P_Positive_Long_Position);
        elseif (Base.ismissing(y_P_Positive_Long_Position) || Base.isnothing(y_P_Positive_Long_Position)) && (!(Base.ismissing(y_P_Positive_Short_Selling) || Base.isnothing(y_P_Positive_Short_Selling)))
            y_P_Positive = Core.Float64(y_P_Positive_Short_Selling);
        else
            y_P_Positive = Core.nothing;  # Core.Float64(Core.Float64(y_P_Positive_Long_Position) + Core.Float64(y_P_Positive_Short_Selling));
        end
        if Core.Int64(Base.length(y_P_Negative_Long_Position_Array)) > Core.Int64(0)
            # y_P_Negative_Long_Position = Core.Float64(Base.findmin(y_P_Negative_Long_Position_Array)[1]);
            # y_P_Negative_Long_Position = Core.Float64(Base.sum(y_P_Negative_Long_Position_Array));
            y_P_Negative_Long_Position = Core.Float64(Statistics.mean(y_P_Negative_Long_Position_Array));
        end
        y_P_Negative_Long_Position_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_P_Negative_Short_Selling_Array)) > Core.Int64(0)
            # y_P_Negative_Short_Selling = Core.Float64(Base.findmin(y_P_Negative_Short_Selling_Array)[1]);
            # y_P_Negative_Short_Selling = Core.Float64(Base.sum(y_P_Negative_Short_Selling_Array));
            y_P_Negative_Short_Selling = Core.Float64(Statistics.mean(y_P_Negative_Short_Selling_Array));
        end
        y_P_Negative_Short_Selling_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_P_Negative_Array)) > Core.Int64(0)
            # y_P_Negative = Core.Float64(Base.findmin(y_P_Negative_Array)[1]);
            # y_P_Negative = Core.Float64(Base.sum(y_P_Negative_Array));
            y_P_Negative = Core.Float64(Statistics.mean(y_P_Negative_Array));
        end
        y_P_Negative_Array = Core.nothing;  # 釋放内存;
        # y_P_Negative = Core.nothing;  # Core.Float64(0.0);  # Core.Float64(Core.Float64(y_P_Negative_Long_Position) + Core.Float64(y_P_Negative_Short_Selling));
        if (!(Base.ismissing(y_P_Negative_Long_Position) || Base.isnothing(y_P_Negative_Long_Position))) && (!(Base.ismissing(y_P_Negative_Short_Selling) || Base.isnothing(y_P_Negative_Short_Selling)))
            # y_P_Negative = Core.Float64(Core.Float64(y_P_Negative_Long_Position) + Core.Float64(y_P_Negative_Short_Selling));
            y_P_Negative = Core.Float64(Statistics.mean([Core.Float64(y_P_Negative_Long_Position), Core.Float64(y_P_Negative_Short_Selling)]));
        elseif (!(Base.ismissing(y_P_Negative_Long_Position) || Base.isnothing(y_P_Negative_Long_Position))) && (Base.ismissing(y_P_Negative_Short_Selling) || Base.isnothing(y_P_Negative_Short_Selling))
            y_P_Negative = Core.Float64(y_P_Negative_Long_Position);
        elseif (Base.ismissing(y_P_Negative_Long_Position) || Base.isnothing(y_P_Negative_Long_Position)) && (!(Base.ismissing(y_P_Negative_Short_Selling) || Base.isnothing(y_P_Negative_Short_Selling)))
            y_P_Negative = Core.Float64(y_P_Negative_Short_Selling);
        else
            y_P_Negative = Core.nothing;  # Core.Float64(Core.Float64(y_P_Negative_Long_Position) + Core.Float64(y_P_Negative_Short_Selling));
        end
        if Core.Int64(Base.length(y_amplitude_Long_Position_Array)) > Core.Int64(0)
            # y_amplitude_Long_Position = Core.Float64(Base.findmin(y_amplitude_Long_Position_Array)[1]);  # 去極小值;
            # y_amplitude_Long_Position = Core.Float64(Base.sum(y_amplitude_Long_Position_Array));  # 取總和
            # y_amplitude_Long_Position = Core.Float64(Statistics.mean(y_amplitude_Long_Position_Array));  # 取均值;
            y_amplitude_Long_Position = Core.Float64(Statistics.median(y_amplitude_Long_Position_Array));  # 取中位數;
        end
        y_amplitude_Long_Position_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_amplitude_Short_Selling_Array)) > Core.Int64(0)
            # y_amplitude_Short_Selling = Core.Float64(Base.findmin(y_amplitude_Short_Selling_Array)[1]);  # 去極小值;
            # y_amplitude_Short_Selling = Core.Float64(Base.sum(y_amplitude_Short_Selling_Array));  # 取總和
            # y_amplitude_Short_Selling = Core.Float64(Statistics.mean(y_amplitude_Short_Selling_Array));  # 取均值;
            y_amplitude_Short_Selling = Core.Float64(Statistics.median(y_amplitude_Short_Selling_Array));  # 取中位數;
        end
        y_amplitude_Short_Selling_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_amplitude_Array)) > Core.Int64(0)
            # y_amplitude = Core.Float64(Base.findmin(y_amplitude_Array)[1]);  # 去極小值;
            # y_amplitude = Core.Float64(Base.sum(y_amplitude_Array));  # 取總和
            # y_amplitude = Core.Float64(Statistics.mean(y_amplitude_Array));  # 取均值;
            y_amplitude = Core.Float64(Statistics.median(y_amplitude_Array));  # 取中位數;
        end
        y_amplitude_Array = Core.nothing;  # 釋放内存;
        # y_amplitude = Core.nothing;  # Core.Float64(0.0);  # Core.Float64(Core.Float64(y_amplitude_Long_Position) + Core.Float64(y_amplitude_Short_Selling));
        if (!(Base.ismissing(y_amplitude_Long_Position) || Base.isnothing(y_amplitude_Long_Position))) && (!(Base.ismissing(y_amplitude_Short_Selling) || Base.isnothing(y_amplitude_Short_Selling)))
            # y_amplitude = Core.Float64(Core.Float64(y_amplitude_Long_Position) + Core.Float64(y_amplitude_Short_Selling));  # 取總和
            # y_amplitude = Core.Float64(Statistics.mean([Core.Float64(y_amplitude_Long_Position), Core.Float64(y_amplitude_Short_Selling)]));  # 取均值;
            y_amplitude = Core.Float64(Statistics.median([Core.Float64(y_amplitude_Long_Position), Core.Float64(y_amplitude_Short_Selling)]));  # 取中位數;
        elseif (!(Base.ismissing(y_amplitude_Long_Position) || Base.isnothing(y_amplitude_Long_Position))) && (Base.ismissing(y_amplitude_Short_Selling) || Base.isnothing(y_amplitude_Short_Selling))
            y_amplitude = Core.Float64(y_amplitude_Long_Position);
        elseif (Base.ismissing(y_amplitude_Long_Position) || Base.isnothing(y_amplitude_Long_Position)) && (!(Base.ismissing(y_amplitude_Short_Selling) || Base.isnothing(y_amplitude_Short_Selling)))
            y_amplitude = Core.Float64(y_amplitude_Short_Selling);
        else
            y_amplitude = Core.nothing;  # Core.Float64(Core.Float64(y_amplitude_Long_Position) + Core.Float64(y_amplitude_Short_Selling));
        end
        if Core.Int64(Base.length(y_turnover_Long_Position_Array)) > Core.Int64(0)
            # y_turnover_Long_Position = Core.Float64(Base.findmin(y_turnover_Long_Position_Array)[1]);  # 去極小值;
            # y_turnover_Long_Position = Core.Float64(Base.sum(y_turnover_Long_Position_Array));  # 取總和
            # y_turnover_Long_Position = Core.Float64(Statistics.mean(y_turnover_Long_Position_Array));  # 取均值;
            y_turnover_Long_Position = Core.Float64(Statistics.median(y_turnover_Long_Position_Array));  # 取中位數;
        end
        y_turnover_Long_Position_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_turnover_Short_Selling_Array)) > Core.Int64(0)
            # y_turnover_Short_Selling = Core.Float64(Base.findmin(y_turnover_Short_Selling_Array)[1]);  # 去極小值;
            # y_turnover_Short_Selling = Core.Float64(Base.sum(y_turnover_Short_Selling_Array));  # 取總和
            # y_turnover_Short_Selling = Core.Float64(Statistics.mean(y_turnover_Short_Selling_Array));  # 取均值;
            y_turnover_Short_Selling = Core.Float64(Statistics.median(y_turnover_Short_Selling_Array));  # 取中位數;
        end
        y_turnover_Short_Selling_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_turnover_Array)) > Core.Int64(0)
            # y_turnover = Core.Float64(Base.findmin(y_turnover_Array)[1]);  # 去極小值;
            # y_turnover = Core.Float64(Base.sum(y_turnover_Array));  # 取總和
            # y_turnover = Core.Float64(Statistics.mean(y_turnover_Array));  # 取均值;
            y_turnover = Core.Float64(Statistics.median(y_turnover_Array));  # 取中位數;
        end
        y_turnover_Array = Core.nothing;  # 釋放内存;
        # y_turnover = Core.nothing;  # Core.Float64(0.0);  # Core.Float64(Core.Float64(y_turnover_Long_Position) + Core.Float64(y_turnover_Short_Selling));
        if (!(Base.ismissing(y_turnover_Long_Position) || Base.isnothing(y_turnover_Long_Position))) && (!(Base.ismissing(y_turnover_Short_Selling) || Base.isnothing(y_turnover_Short_Selling)))
            # y_turnover = Core.Float64(Core.Float64(y_turnover_Long_Position) + Core.Float64(y_turnover_Short_Selling));  # 取總和
            # y_turnover = Core.Float64(Statistics.mean([Core.Float64(y_turnover_Long_Position), Core.Float64(y_turnover_Short_Selling)]));  # 取均值;
            y_turnover = Core.Float64(Statistics.median([Core.Float64(y_turnover_Long_Position), Core.Float64(y_turnover_Short_Selling)]));  # 取中位數;
        elseif (!(Base.ismissing(y_turnover_Long_Position) || Base.isnothing(y_turnover_Long_Position))) && (Base.ismissing(y_turnover_Short_Selling) || Base.isnothing(y_turnover_Short_Selling))
            y_turnover = Core.Float64(y_turnover_Long_Position);
        elseif (Base.ismissing(y_turnover_Long_Position) || Base.isnothing(y_turnover_Long_Position)) && (!(Base.ismissing(y_turnover_Short_Selling) || Base.isnothing(y_turnover_Short_Selling)))
            y_turnover = Core.Float64(y_turnover_Short_Selling);
        else
            y_turnover = Core.nothing;  # Core.Float64(Core.Float64(y_turnover_Long_Position) + Core.Float64(y_turnover_Short_Selling));
        end
        if Core.Int64(Base.length(y_date_transaction_between_Long_Position_Array)) > Core.Int64(0)
            # y_date_transaction_between_Long_Position = Core.Float64(Base.findmin(y_date_transaction_between_Long_Position_Array)[1]);  # 去極小值;
            # y_date_transaction_between_Long_Position = Core.Float64(Base.sum(y_date_transaction_between_Long_Position_Array));  # 取總和
            # y_date_transaction_between_Long_Position = Core.Float64(Statistics.mean(y_date_transaction_between_Long_Position_Array));  # 取均值;
            y_date_transaction_between_Long_Position = Core.Float64(Statistics.median(y_date_transaction_between_Long_Position_Array));  # 取中位數;
        end
        y_date_transaction_between_Long_Position_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_date_transaction_between_Short_Selling_Array)) > Core.Int64(0)
            # y_date_transaction_between_Short_Selling = Core.Float64(Base.findmin(y_date_transaction_between_Short_Selling_Array)[1]);  # 去極小值;
            # y_date_transaction_between_Short_Selling = Core.Float64(Base.sum(y_date_transaction_between_Short_Selling_Array));  # 取總和
            # y_date_transaction_between_Short_Selling = Core.Float64(Statistics.mean(y_date_transaction_between_Short_Selling_Array));  # 取均值;
            y_date_transaction_between_Short_Selling = Core.Float64(Statistics.median(y_date_transaction_between_Short_Selling_Array));  # 取中位數;
        end
        y_date_transaction_between_Short_Selling_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_date_transaction_between_Array)) > Core.Int64(0)
            # y_date_transaction_between = Core.Float64(Base.findmin(y_date_transaction_between_Array)[1]);  # 去極小值;
            # y_date_transaction_between = Core.Float64(Base.sum(y_date_transaction_between_Array));  # 取總和
            # y_date_transaction_between = Core.Float64(Statistics.mean(y_date_transaction_between_Array));  # 取均值;
            y_date_transaction_between = Core.Float64(Statistics.median(y_date_transaction_between_Array));  # 取中位數;
        end
        y_date_transaction_between_Array = Core.nothing;  # 釋放内存;
        # y_date_transaction_between = Core.nothing;  # Core.Float64(0.0);  # Core.Float64(Core.Float64(y_date_transaction_between_Long_Position) + Core.Float64(y_date_transaction_between_Short_Selling));
        if (!(Base.ismissing(y_date_transaction_between_Long_Position) || Base.isnothing(y_date_transaction_between_Long_Position))) && (!(Base.ismissing(y_date_transaction_between_Short_Selling) || Base.isnothing(y_date_transaction_between_Short_Selling)))
            # y_date_transaction_between = Core.Float64(Core.Float64(y_date_transaction_between_Long_Position) + Core.Float64(y_date_transaction_between_Short_Selling));  # 取總和
            # y_date_transaction_between = Core.Float64(Statistics.mean([Core.Float64(y_date_transaction_between_Long_Position), Core.Float64(y_date_transaction_between_Short_Selling)]));  # 取均值;
            y_date_transaction_between = Core.Float64(Statistics.median([Core.Float64(y_date_transaction_between_Long_Position), Core.Float64(y_date_transaction_between_Short_Selling)]));  # 取中位數;
        elseif (!(Base.ismissing(y_date_transaction_between_Long_Position) || Base.isnothing(y_date_transaction_between_Long_Position))) && (Base.ismissing(y_date_transaction_between_Short_Selling) || Base.isnothing(y_date_transaction_between_Short_Selling))
            y_date_transaction_between = Core.Float64(y_date_transaction_between_Long_Position);
        elseif (Base.ismissing(y_date_transaction_between_Long_Position) || Base.isnothing(y_date_transaction_between_Long_Position)) && (!(Base.ismissing(y_date_transaction_between_Short_Selling) || Base.isnothing(y_date_transaction_between_Short_Selling)))
            y_date_transaction_between = Core.Float64(y_date_transaction_between_Short_Selling);
        else
            y_date_transaction_between = Core.nothing;  # Core.Float64(Core.Float64(y_date_transaction_between_Long_Position) + Core.Float64(y_date_transaction_between_Short_Selling));
        end
        if Core.Int64(Base.length(y_Long_Position_profit_Array)) > Core.Int64(0)
            # y_Long_Position_profit = Core.Float64(Base.findmin(y_Long_Position_profit_Array)[1]);
            y_Long_Position_profit = Core.Float64(Base.sum(y_Long_Position_profit_Array));
        end
        y_Long_Position_profit_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_Short_Selling_profit_Array)) > Core.Int64(0)
            # y_Short_Selling_profit = Core.Float64(Base.findmin(y_Short_Selling_profit_Array)[1]);
            y_Short_Selling_profit = Core.Float64(Base.sum(y_Short_Selling_profit_Array));
        end
        y_Short_Selling_profit_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_profit_Array)) > Core.Int64(0)
            # y_profit = Core.Float64(Base.findmin(y_profit_Array)[1]);
            y_profit = Core.Float64(Base.sum(y_profit_Array));
        end
        y_profit_Array = Core.nothing;  # 釋放内存;
        # y_profit = Core.nothing;  # Core.Float64(0.0);  # Core.Float64(Core.Float64(y_Long_Position_profit) + Core.Float64(y_Short_Selling_profit));  # 優化目標變量，利潤 × 權重;
        if (!(Base.ismissing(y_Long_Position_profit) || Base.isnothing(y_Long_Position_profit))) && (!(Base.ismissing(y_Short_Selling_profit) || Base.isnothing(y_Short_Selling_profit)))
            y_profit = Core.Float64(Core.Float64(y_Long_Position_profit) + Core.Float64(y_Short_Selling_profit));  # 優化目標變量，利潤 × 權重;
        elseif (!(Base.ismissing(y_Long_Position_profit) || Base.isnothing(y_Long_Position_profit))) && (Base.ismissing(y_Short_Selling_profit) || Base.isnothing(y_Short_Selling_profit))
            y_profit = Core.Float64(y_Long_Position_profit);
        elseif (Base.ismissing(y_Long_Position_profit) || Base.isnothing(y_Long_Position_profit)) && (!(Base.ismissing(y_Short_Selling_profit) || Base.isnothing(y_Short_Selling_profit)))
            y_profit = Core.Float64(y_Short_Selling_profit);
        else
            y_profit = Core.nothing;  # Core.Float64(Core.Float64(y_Long_Position_profit) + Core.Float64(y_Short_Selling_profit));  # 優化目標變量，利潤 × 權重;
        end
        if Core.Int64(Base.length(y_Long_Position_loss_Array)) > Core.Int64(0)
            y_Long_Position_loss = Core.Float64(Base.findmin(y_Long_Position_loss_Array)[1]);
        end
        y_Long_Position_loss_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_Short_Selling_loss_Array)) > Core.Int64(0)
            y_Short_Selling_loss = Core.Float64(Base.findmin(y_Short_Selling_loss_Array)[1]);
        end
        y_Short_Selling_loss_Array = Core.nothing;  # 釋放内存;
        if Core.Int64(Base.length(y_loss_Array)) > Core.Int64(0)
            y_loss = Core.Float64(Base.findmin(y_loss_Array)[1]);
        end
        y_loss_Array = Core.nothing;  # 釋放内存;
        # y_loss = Core.nothing;  # Core.Float64(0.0);  # Core.Float64(Base.findmin([Core.Float64(y_Long_Position_loss), Core.Float64(y_Short_Selling_loss)])[1]);  # 優化目標變量，最大回撤 × 權重;
        if (!(Base.ismissing(y_Long_Position_loss) || Base.isnothing(y_Long_Position_loss))) && (!(Base.ismissing(y_Short_Selling_loss) || Base.isnothing(y_Short_Selling_loss)))
            y_loss = Core.Float64(Base.findmin([y_Long_Position_loss, y_Short_Selling_loss])[1]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
        elseif (!(Base.ismissing(y_Long_Position_loss) || Base.isnothing(y_Long_Position_loss))) && (Base.ismissing(y_Short_Selling_loss) || Base.isnothing(y_Short_Selling_loss))
            y_loss = Core.Float64(y_Long_Position_loss);  # 兩次對衝交易之間的最大回撤值，取極值統計;
        elseif (Base.ismissing(y_Long_Position_loss) || Base.isnothing(y_Long_Position_loss)) && (!(Base.ismissing(y_Short_Selling_loss) || Base.isnothing(y_Short_Selling_loss)))
            y_loss = Core.Float64(y_Short_Selling_loss);  # 兩次對衝交易之間的最大回撤值，取極值統計;
        else
            y_loss = Core.nothing;
        end

        return_stepping_Dict["number_transaction_total"] = number_total;
        return_stepping_Dict["number_transaction_total_Long_Position"] = number_total_Long_Position;
        return_stepping_Dict["number_transaction_total_Short_Selling"] = number_total_Short_Selling;
        return_stepping_Dict["maximum_drawdown"] = y_maximum_drawdown;
        return_stepping_Dict["maximum_drawdown_Long_Position"] = y_maximum_drawdown_Long_Position;
        return_stepping_Dict["maximum_drawdown_Short_Selling"] = y_maximum_drawdown_Short_Selling;
        return_stepping_Dict["profit_total"] = y_total;
        return_stepping_Dict["Long_Position_profit_total"] = y_total_Long_Position;
        return_stepping_Dict["Short_Selling_profit_total"] = y_total_Short_Selling;
        return_stepping_Dict["profit_Positive"] = y_Positive;
        return_stepping_Dict["profit_Negative"] = y_Negative;
        return_stepping_Dict["Long_Position_profit_Positive"] = y_Positive_Long_Position;
        return_stepping_Dict["Long_Position_profit_Negative"] = y_Negative_Long_Position;
        return_stepping_Dict["Short_Selling_profit_Positive"] = y_Positive_Short_Selling;
        return_stepping_Dict["Short_Selling_profit_Negative"] = y_Negative_Short_Selling;
        return_stepping_Dict["profit_Positive_probability"] = y_P_Positive;
        return_stepping_Dict["profit_Negative_probability"] = y_P_Negative;
        return_stepping_Dict["Long_Position_profit_Positive_probability"] = y_P_Positive_Long_Position;
        return_stepping_Dict["Long_Position_profit_Negative_probability"] = y_P_Negative_Long_Position;
        return_stepping_Dict["Short_Selling_profit_Positive_probability"] = y_P_Positive_Short_Selling;
        return_stepping_Dict["Short_Selling_profit_Negative_probability"] = y_P_Negative_Short_Selling;
        return_stepping_Dict["average_price_amplitude_date_transaction"] = y_amplitude;
        return_stepping_Dict["Long_Position_average_price_amplitude_date_transaction"] = y_amplitude_Long_Position;
        return_stepping_Dict["Short_Selling_average_price_amplitude_date_transaction"] = y_amplitude_Short_Selling;
        return_stepping_Dict["average_volume_turnover_date_transaction"] = y_turnover;
        return_stepping_Dict["Long_Position_average_volume_turnover_date_transaction"] = y_turnover_Long_Position;
        return_stepping_Dict["Short_Selling_average_volume_turnover_date_transaction"] = y_turnover_Short_Selling;
        return_stepping_Dict["average_date_transaction_between"] = y_date_transaction_between;
        return_stepping_Dict["Long_Position_average_date_transaction_between"] = y_date_transaction_between_Long_Position;
        return_stepping_Dict["Short_Selling_average_date_transaction_between"] = y_date_transaction_between_Short_Selling;

        # 釋放内存;
        stepping_sequence_Array = Core.nothing;
        data_transaction_sequence_Dict = Core.nothing;
        profit_paired_data_transaction_sequence_Dict = Core.nothing;
        Array_PickStock_transaction_Long_Position = Core.nothing;
        Array_PickStock_transaction_Short_Selling = Core.nothing;
        number_transactions_total_Long_Position = Core.nothing;
        number_transactions_total_Short_Selling = Core.nothing;

        # println("number PickStock : ", return_stepping_Dict["number_PickStock"]);
        # println("number PickStock Long Position : ", return_stepping_Dict["number_PickStock_Long_Position"]);
        # println("number PickStock Short Selling : ", return_stepping_Dict["number_PickStock_Short_Selling"]);
        # println("number transaction : ", return_stepping_Dict["number_transaction_total"]);
        # println("number transaction Long Position : ", return_stepping_Dict["number_transaction_total_Long_Position"]);
        # println("number transaction Short Selling : ", return_stepping_Dict["number_transaction_total_Short_Selling"]);
        # println("maximum drawdown : ", return_stepping_Dict["maximum_drawdown"]);
        # println("maximum drawdown Long Position : ", return_stepping_Dict["maximum_drawdown_Long_Position"]);
        # println("maximum drawdown Short Selling : ", return_stepping_Dict["maximum_drawdown_Short_Selling"]);
        # println("profit total : ", return_stepping_Dict["profit_total"]);
        # println("Long Position profit total : ", return_stepping_Dict["Long_Position_profit_total"]);
        # println("Short Selling profit total : ", return_stepping_Dict["Short_Selling_profit_total"]);
        # println("profit Positive : ", return_stepping_Dict["profit_Positive"]);
        # println("profit Negative : ", return_stepping_Dict["profit_Negative"]);
        # println("Long Position profit Positive : ", return_stepping_Dict["Long_Position_profit_Positive"]);
        # println("Long Position profit Negative : ", return_stepping_Dict["Long_Position_profit_Negative"]);
        # println("Short Selling profit Positive : ", return_stepping_Dict["Short_Selling_profit_Positive"]);
        # println("Short Selling profit Negative : ", return_stepping_Dict["Short_Selling_profit_Negative"]);
        # println("profit Positive probability : ", return_stepping_Dict["profit_Positive_probability"]);
        # println("profit Negative probability : ", return_stepping_Dict["profit_Negative_probability"]);
        # println("Long Position profit Positive probability : ", return_stepping_Dict["Long_Position_profit_Positive_probability"]);
        # println("Long Position profit Negative probability : ", return_stepping_Dict["Long_Position_profit_Negative_probability"]);
        # println("Short Selling profit Positive probability : ", return_stepping_Dict["Short_Selling_profit_Positive_probability"]);
        # println("Short Selling profit Negative probability : ", return_stepping_Dict["Short_Selling_profit_Negative_probability"]);
        # println("average price amplitude date transaction : ", return_stepping_Dict["average_price_amplitude_date_transaction"]);
        # println("Long Position average price amplitude date transaction : ", return_stepping_Dict["Long_Position_average_price_amplitude_date_transaction"]);
        # println("Short Selling average price amplitude date transaction : ", return_stepping_Dict["Short_Selling_average_price_amplitude_date_transaction"]);
        # println("average volume turnover date transaction : ", return_stepping_Dict["average_volume_turnover_date_transaction"]);
        # println("Long Position average volume turnover date transaction : ", return_stepping_Dict["Long_Position_average_volume_turnover_date_transaction"]);
        # println("Short Selling average volume turnover date transaction : ", return_stepping_Dict["Short_Selling_average_volume_turnover_date_transaction"]);
        # println("average date transaction between : ", return_stepping_Dict["average_date_transaction_between"]);
        # println("Long Position average date transaction between : ", return_stepping_Dict["Long_Position_average_date_transaction_between"]);
        # println("Short Selling average date transaction between : ", return_stepping_Dict["Short_Selling_average_date_transaction_between"]);
        # # println("PickStock Long Position Array :", "\n", return_stepping_Dict["PickStock_Long_Position"]);
        # # println("PickStock Short Selling Array :", "\n", return_stepping_Dict["PickStock_Short_Selling"]);
        # # println("PickStock Array :", "\n", return_stepping_Dict["PickStock"]);
        # # println("profit paired transaction Dict :", "\n", return_stepping_Dict["profit_paired_transaction"]);
        # # println("transaction sequence Dict :", "\n", return_stepping_Dict["transaction_sequence"]);
        # # println("stepping sequence Array :", "\n", return_stepping_Dict["stepping_sequence"]);
    end

    # http://gadflyjl.org/stable/gallery/geometries/#[Geom.segment](@ref)
    # 繪圖;
    img1 = Core.nothing;
    if false

        ticker_symbol::Core.String = Base.string("002611");  # 流通代碼;

        set_default_plot_size(21cm, 21cm);  # 設定畫布規格;

        # 繪製訓練集折缐圖示;
        # img1 = Core.nothing;
        if Base.isa(steppingData, Base.Dict) && Base.length(steppingData) > 0

            steppingData_index = steppingData[ticker_symbol];
            stepping_result = steppingData[ticker_symbol];  # return_stepping_Dict["stepping_sequence"][ticker_symbol];

            points1 = Gadfly.layer(
                x = [Core.Int64(i) for i in 1:Base.length(steppingData_index["date_transaction"])],  # steppingData_index["date_transaction"],  # Xdata,
                y = steppingData_index["focus"],  # YdataMean,  # Ydata,
                Geom.point,
                color = [colorant"black"],  # "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgrey", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgrey", "lightpink", "lightsalmon"
                Theme(
                    line_width = 1pt,
                    point_size = 2pt,
                    point_shapes = [Gadfly.Shape.hline],  # Gadfly.Shape.circle, Gadfly.Shape.square, Gadfly.Shape.diamond, Gadfly.Shape.cross, Gadfly.Shape.xcross, Gadfly.Shape.utriangle, Gadfly.Shape.dtriangle, Gadfly.Shape.star1, Gadfly.Shape.star2, Gadfly.Shape.hexagon, Gadfly.Shape.octagon, Gadfly.Shape.hline, Gadfly.Shape.vline, Gadfly.Shape.ltriangle, Gadfly.Shape.rtriangle
                )
            );
            smoothline1 = Gadfly.layer(
                x = [Core.Int64(i) for i in 1:Base.length(steppingData_index["date_transaction"])],  # steppingData_index["date_transaction"],  # Xdata,
                y = steppingData_index["focus"],  # YdataMean,  # Yvals,
                # ymin = steppingData_index["low_price"],  # YvalsUncertaintyLower,  # 繪製置信區間填充圖下綫;
                # ymax = steppingData_index["high_price"],  # YvalsUncertaintyUpper,  # 繪製置信區間填充圖上綫;
                Geom.line,  # Geom.smooth,
                # Geom.ribbon(fill=true),  # 繪製置信區間填充圖;
                Theme(
                    # point_size = 5pt,
                    line_width = 1.0pt,
                    line_style = [:solid],  # :dot
                    default_color = "black",  # "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgrey", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgrey", "lightpink", "lightsalmon"
                    alphas = [1],
                    # lowlight_color = c->"gray"
                )  # color = [colorant"red"],
            );
            smoothline2 = Gadfly.layer(
                x = [Core.Int64(i) for i in 1:Base.length(steppingData_index["date_transaction"])],  # steppingData_index["date_transaction"],  # Xdata,
                y = steppingData_index["low_price"],  # YvalsUncertaintyLower,
                Geom.line,  # Geom.smooth,
                Theme(line_width=0.5pt, line_style=[:dot], default_color="black", alphas=[0.3],)  # color=[colorant"yellow"],  # "brown", "purple"
            );
            smoothline3 = Gadfly.layer(
                x = [Core.Int64(i) for i in 1:Base.length(steppingData_index["date_transaction"])],  # steppingData_index["date_transaction"],  # Xdata,
                y = steppingData_index["high_price"],  # YvalsUncertaintyUpper,
                Geom.line,  # Geom.smooth,
                Theme(line_width=0.5pt, line_style=[:dot], default_color="black", alphas=[0.3],)  # color=[colorant"yellow"],  # "brown", "purple"
            );
            # 繪製置信區間填充圖;
            ribbonline1 = Gadfly.layer(
                x = [Core.Int64(i) for i in 1:Base.length(steppingData_index["date_transaction"])],  # steppingData_index["date_transaction"],  # Xdata,
                # y = steppingData_index["focus"],  # YdataMean,  # Yvals,
                ymin = steppingData_index["low_price"],  # YvalsUncertaintyLower,
                ymax = steppingData_index["high_price"],  # YvalsUncertaintyUpper,
                # Geom.line,  # Geom.smooth,
                Geom.ribbon(fill = true),
                Theme(
                    # point_size = 5pt,
                    line_width = 0.1pt,
                    line_style = [:dot],  # :solid
                    default_color = "gray",  # "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgrey", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgrey", "lightpink", "lightsalmon"
                    alphas = [0.5],
                    # lowlight_color = c->"gray"
                )  # color = [colorant"red"],
            );
            smoothline4 = Gadfly.layer(
                x = [Core.Int64(i) for i in 1:Base.length(steppingData_index["date_transaction"])],  # steppingData_index["date_transaction"],  # Xdata,
                y = steppingData_index["opening_price"],  # YvalsUncertaintyLower,
                Geom.line,  # Geom.smooth,
                Theme(line_width=0.5pt, line_style=[:dot], default_color="black", alphas=[0.3],)  # color=[colorant"red"],
            );
            smoothline5 = Gadfly.layer(
                x = [Core.Int64(i) for i in 1:Base.length(steppingData_index["date_transaction"])],  # steppingData_index["date_transaction"],  # Xdata,
                y = steppingData_index["close_price"],  # YvalsUncertaintyUpper,
                Geom.line,  # Geom.smooth,
                Theme(line_width=0.5pt, line_style=[:dot], default_color="black", alphas=[0.3],)  # color=[colorant"green"],
            );
            # 繪製置信區間填充圖;
            ribbonline2 = Gadfly.layer(
                x = [Core.Int64(i) for i in 1:Base.length(steppingData_index["date_transaction"])],  # steppingData_index["date_transaction"],  # Xdata,
                # y = steppingData_index["focus"],  # YdataMean,  # Yvals,
                ymin = [Core.Float64(Base.findmin([Core.Float64(steppingData_index["opening_price"][i]), Core.Float64(steppingData_index["close_price"][i])])[1]) for i in 1:Base.length(steppingData_index["focus"])],  # steppingData_index["opening_price"],  # YvalsUncertaintyLower,
                ymax = [Core.Float64(Base.findmax([Core.Float64(steppingData_index["opening_price"][i]), Core.Float64(steppingData_index["close_price"][i])])[1]) for i in 1:Base.length(steppingData_index["focus"])],  # steppingData_index["close_price"],  # YvalsUncertaintyUpper,
                # Geom.line,  # Geom.smooth,
                Geom.ribbon(fill = true),
                Theme(
                    # point_size = 5pt,
                    line_width = 0.1pt,
                    line_style = [:dot],  # :solid
                    default_color = "gray",  # "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgrey", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgrey", "lightpink", "lightsalmon"
                    alphas = [0.5],
                    # lowlight_color = c->"gray"
                )  # color = [colorant"red"],
            );
            buy_x = Core.Array{Core.Int64, 1}();
            # [if Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("buy") Core.Int64(stepping_result["Long_Position_date_transaction"][i][6]) else Core.nothing end for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])];
            # [(Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("buy")) ? Core.Int64(stepping_result["Long_Position_date_transaction"][i][6]) : Core.nothing for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])];
            # [if Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) === Base.string("buy") Core.Int64(stepping_result["Short_Selling_date_transaction"][i][6]) else Core.nothing end for i in 1:Base.length(stepping_result["Short_Selling_date_transaction"])];
            # [(Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) === Base.string("buy")) ? Core.Int64(stepping_result["Short_Selling_date_transaction"][i][6]) : Core.nothing for i in 1:Base.length(stepping_result["Short_Selling_date_transaction"])];
            buy_y = Core.Array{Core.Float64, 1}();
            # [if Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("buy") Core.Float64(stepping_result["Long_Position_date_transaction"][i][3]) else Core.nothing end for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])];
            # [(Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("buy")) ? Core.Float64(stepping_result["Long_Position_date_transaction"][i][3]) : Core.nothing for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])];
            # [if Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) === Base.string("buy") Core.Float64(stepping_result["Short_Selling_date_transaction"][i][3]) else Core.nothing end for i in 1:Base.length(stepping_result["Short_Selling_date_transaction"])];
            # [(Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) === Base.string("buy")) ? Core.Float64(stepping_result["Short_Selling_date_transaction"][i][3]) : Core.nothing for i in 1:Base.length(stepping_result["Short_Selling_date_transaction"])];
            buy_label = Core.Array{Core.String, 1}();
            # [if Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("buy") Base.string(Base.string(stepping_result["Long_Position_date_transaction"][i][2]) * " " * Base.string(stepping_result["Long_Position_date_transaction"][i][5])) else Core.nothing end for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])];
            # [(Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("buy")) ? Base.string(Base.string(stepping_result["Long_Position_date_transaction"][i][2]) * " " * Base.string(stepping_result["Long_Position_date_transaction"][i][5])) : Core.nothing for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])];
            # [if Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) === Base.string("buy") Base.string(Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) * " " * Base.string(stepping_result["Short_Selling_date_transaction"][i][5])) else Core.nothing end for i in 1:Base.length(stepping_result["Short_Selling_date_transaction"])];
            # [(Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) === Base.string("buy")) ? Base.string(Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) * " " * Base.string(stepping_result["Short_Selling_date_transaction"][i][5])) : Core.nothing for i in 1:Base.length(stepping_result["Short_Selling_date_transaction"])];
            for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])
                if Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("buy")
                    # Base.push!(buy_x, stepping_result["Long_Position_date_transaction"][i][1]);
                    Base.push!(buy_x, Core.Int64(stepping_result["Long_Position_date_transaction"][i][6]));
                    Base.push!(buy_y, Core.Float64(stepping_result["Long_Position_date_transaction"][i][3]));
                    Base.push!(buy_label, Base.string(Base.string(stepping_result["Long_Position_date_transaction"][i][2]) * " " * Base.string(stepping_result["Long_Position_date_transaction"][i][5])));
                end
            end
            # for i in 1:Base.length(stepping_result["Short_Selling_date_transaction"])
            #     if Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) === Base.string("buy")
            #         # Base.push!(buy_x, stepping_result["Short_Selling_date_transaction"][i][1]);
            #         Base.push!(buy_x, Core.Int64(stepping_result["Short_Selling_date_transaction"][i][6]));
            #         Base.push!(buy_y, Core.Float64(stepping_result["Short_Selling_date_transaction"][i][3]));
            #         Base.push!(buy_label, Base.string(Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) * " " * Base.string(stepping_result["Short_Selling_date_transaction"][i][5])));
            #     end
            # end
            points2 = Gadfly.layer(
                x = buy_x,  # [if Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("buy") Core.Int64(stepping_result["Long_Position_date_transaction"][i][6]) else Core.nothing end for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])],  # [Core.Int64(i) for i in 1:Base.length(steppingData_index["Long_Position_date_transaction"])],  # steppingData_index["Long_Position_date_transaction"],  # Xdata,
                y = buy_y,  # [if Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("buy") Core.Float64(stepping_result["Long_Position_date_transaction"][i][3]) else Core.nothing end for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])],  # steppingData_index["focus"],  # YdataMean,  # Ydata,
                Geom.point,
                label = buy_label,  # [if Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("buy") Base.string(Base.string(stepping_result["Long_Position_date_transaction"][i][2]) * " " * Base.string(stepping_result["Long_Position_date_transaction"][i][5])) else Core.nothing end for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])],
                Geom.label(
                    position = :above,  # :left, :right, :above, :below, :centered, or :dynamic
                    hide_overlaps = true
                ),
                color = [colorant"red"],  # "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgrey", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgrey", "lightpink", "lightsalmon"
                Theme(
                    line_width = 1pt,
                    point_size = 3pt,
                    point_shapes = [Gadfly.Shape.vline],  # Gadfly.Shape.circle, Gadfly.Shape.square, Gadfly.Shape.diamond, Gadfly.Shape.cross, Gadfly.Shape.xcross, Gadfly.Shape.utriangle, Gadfly.Shape.dtriangle, Gadfly.Shape.star1, Gadfly.Shape.star2, Gadfly.Shape.hexagon, Gadfly.Shape.octagon, Gadfly.Shape.hline, Gadfly.Shape.vline, Gadfly.Shape.ltriangle, Gadfly.Shape.rtriangle
                )
            );
            sell_x = Core.Array{Core.Int64, 1}();
            # [if Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("sell") Core.Int64(stepping_result["Long_Position_date_transaction"][i][6]) else Core.nothing end for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])];
            # [(Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("sell")) ? Core.Int64(stepping_result["Long_Position_date_transaction"][i][6]) : Core.nothing for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])];
            # [if Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) === Base.string("sell") Core.Int64(stepping_result["Short_Selling_date_transaction"][i][6]) else Core.nothing end for i in 1:Base.length(stepping_result["Short_Selling_date_transaction"])];
            # [(Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) === Base.string("sell")) ? Core.Int64(stepping_result["Short_Selling_date_transaction"][i][6]) : Core.nothing for i in 1:Base.length(stepping_result["Short_Selling_date_transaction"])];
            sell_y = Core.Array{Core.Float64, 1}();
            # [if Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("sell") Core.Float64(stepping_result["Long_Position_date_transaction"][i][3]) else Core.nothing end for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])];
            # [(Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("sell")) ? Core.Float64(stepping_result["Long_Position_date_transaction"][i][3]) : Core.nothing for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])];
            # [if Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) === Base.string("sell") Core.Float64(stepping_result["Short_Selling_date_transaction"][i][3]) else Core.nothing end for i in 1:Base.length(stepping_result["Short_Selling_date_transaction"])];
            # [(Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) === Base.string("sell")) ? Core.Float64(stepping_result["Short_Selling_date_transaction"][i][3]) : Core.nothing for i in 1:Base.length(stepping_result["Short_Selling_date_transaction"])];
            sell_label = Core.Array{Core.String, 1}();
            # [if Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("sell") Base.string(Base.string(stepping_result["Long_Position_date_transaction"][i][2]) * " " * Base.string(stepping_result["Long_Position_date_transaction"][i][5])) else Core.nothing end for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])];
            # [(Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("sell")) ? Base.string(Base.string(stepping_result["Long_Position_date_transaction"][i][2]) * " " * Base.string(stepping_result["Long_Position_date_transaction"][i][5])) : Core.nothing for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])];
            # [if Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) === Base.string("sell") Base.string(Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) * " " * Base.string(stepping_result["Short_Selling_date_transaction"][i][5])) else Core.nothing end for i in 1:Base.length(stepping_result["Short_Selling_date_transaction"])];
            # [(Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) === Base.string("sell")) ? Base.string(Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) * " " * Base.string(stepping_result["Short_Selling_date_transaction"][i][5])) : Core.nothing for i in 1:Base.length(stepping_result["Short_Selling_date_transaction"])];
            for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])
                if Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("sell")
                    # Base.push!(sell_x, stepping_result["Long_Position_date_transaction"][i][1]);
                    Base.push!(sell_x, Core.Int64(stepping_result["Long_Position_date_transaction"][i][6]));
                    Base.push!(sell_y, Core.Float64(stepping_result["Long_Position_date_transaction"][i][3]));
                    Base.push!(sell_label, Base.string(Base.string(stepping_result["Long_Position_date_transaction"][i][2]) * " " * Base.string(stepping_result["Long_Position_date_transaction"][i][5])));
                end
            end
            # for i in 1:Base.length(stepping_result["Short_Selling_date_transaction"])
            #     if Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) === Base.string("sell")
            #         # Base.push!(sell_x, stepping_result["Short_Selling_date_transaction"][i][1]);
            #         Base.push!(sell_x, Core.Int64(stepping_result["Short_Selling_date_transaction"][i][6]));
            #         Base.push!(sell_y, Core.Float64(stepping_result["Short_Selling_date_transaction"][i][3]));
            #         Base.push!(sell_label, Base.string(Base.string(stepping_result["Short_Selling_date_transaction"][i][2]) * " " * Base.string(stepping_result["Short_Selling_date_transaction"][i][5])));
            #     end
            # end
            points3 = Gadfly.layer(
                x = sell_x,  # [if Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("sell") Core.Int64(stepping_result["Long_Position_date_transaction"][i][6]) else Core.nothing end for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])],  # [Core.Int64(i) for i in 1:Base.length(steppingData_index["Long_Position_date_transaction"])],  # steppingData_index["Long_Position_date_transaction"],  # Xdata,
                y = sell_y,  # [if Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("sell") Core.Float64(stepping_result["Long_Position_date_transaction"][i][3]) else Core.nothing end for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])],  # steppingData_index["focus"],  # YdataMean,  # Ydata,
                Geom.point,
                label = sell_label,  # [if Base.string(stepping_result["Long_Position_date_transaction"][i][2]) === Base.string("sell") Base.string(Base.string(stepping_result["Long_Position_date_transaction"][i][2]) * " " * Base.string(stepping_result["Long_Position_date_transaction"][i][5])) else Core.nothing end for i in 1:Base.length(stepping_result["Long_Position_date_transaction"])],
                Geom.label(
                    position = :above,  # :left, :right, :above, :below, :centered, or :dynamic
                    hide_overlaps = true
                ),
                color = [colorant"green"],  # "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgrey", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgrey", "lightpink", "lightsalmon"
                Theme(
                    line_width = 1pt,
                    point_size = 3pt,
                    point_shapes = [Gadfly.Shape.vline],  # Gadfly.Shape.circle, Gadfly.Shape.square, Gadfly.Shape.diamond, Gadfly.Shape.cross, Gadfly.Shape.xcross, Gadfly.Shape.utriangle, Gadfly.Shape.dtriangle, Gadfly.Shape.star1, Gadfly.Shape.star2, Gadfly.Shape.hexagon, Gadfly.Shape.octagon, Gadfly.Shape.hline, Gadfly.Shape.vline, Gadfly.Shape.ltriangle, Gadfly.Shape.rtriangle
                )
            );
            img1 = Gadfly.plot(
                points1,
                # smoothline1,
                smoothline2,
                smoothline3,
                # ribbonline1,
                # smoothline4,
                # smoothline5,
                ribbonline2,
                points2,
                points3,
                # Guide.xlabel("Independent Variable ( x )"),
                Guide.xlabel("transaction date"),
                # Guide.ylabel("Dependent Variable ( y )"),
                Guide.ylabel("transaction price"),
                # Guide.manual_discrete_key("", ["observation values", "polyfit values"]; color=["blue", "red"]),
                Guide.xticks(
                    # ticks = [Core.Int64(i) for i in 1:Base.length(steppingData_index["date_transaction"])],  # 設置 X 軸刻度值;
                    # ticks = [Base.string(Dates.format(steppingData_index["date_transaction"][i], "yyyy-mm-dd")) for i in 1:Base.length(steppingData_index["date_transaction"])],  # 設置 X 軸刻度標簽的文本;
                    # orientation = :vertical,  # 刻度標簽文本旋轉九十度垂直顯示;
                    label = false
                ),
                # Guide.yticks(
                #     ticks = [Core.Int64(i) for i in Core.Int64(Base.floor(Core.Float64(Core.Float64(Base.findmin(steppingData_index["low_price"])[1]) * Core.Float64(0.9)))):Core.Int64(Base.ceil(Core.Float64(Core.Float64(Base.findmax(steppingData_index["high_price"])[1]) * Core.Float64(1.1))))],  # 設置 Y 軸刻度值;
                #     ticks = [Base.string(i) for i in Core.Int64(Base.floor(Core.Float64(Core.Float64(Base.findmin(steppingData_index["low_price"])[1]) * Core.Float64(0.9)))):Core.Int64(Base.ceil(Core.Float64(Core.Float64(Base.findmax(steppingData_index["high_price"])[1]) * Core.Float64(1.1))))],  # 設置 Y 軸刻度標簽的文本;
                #     # ticks = [Core.Int64(i) for i in Core.Int64(Base.floor(Core.Float64(Core.Float64(Base.findmin(steppingData_index["focus"])[1]) * Core.Float64(0.9)))):Core.Int64(Base.ceil(Core.Float64(Core.Float64(Base.findmax(steppingData_index["focus"])[1]) * Core.Float64(1.1))))],  # 設置 Y 軸刻度值;
                #     # ticks = [Base.string(i) for i in Core.Int64(Base.floor(Core.Float64(Core.Float64(Base.findmin(steppingData_index["focus"])[1]) * Core.Float64(0.9)))):Core.Int64(Base.ceil(Core.Float64(Core.Float64(Base.findmax(steppingData_index["focus"])[1]) * Core.Float64(1.1))))],  # 設置 Y 軸刻度標簽的文本;
                #     orientation = :horizontal,  # 刻度標簽文本水平顯示;
                #     label = true
                # ),
                Guide.title("pick stock model ( training )")
            );

            # img1 = Gadfly.plot(
            #     x = steppingData_index["date_transaction"],  # [Base.string(Dates.format(steppingData_index["date_transaction"][i], "yyyy-mm-dd")) for i in 1:Base.length(steppingData_index["date_transaction"])],  # [Core.Int64(i) for i in 1:Base.length(steppingData_index["date_transaction"])],  # steppingData_index["date_transaction"],  # Xdata,
            #     open = steppingData_index["opening_price"],
            #     high = steppingData_index["high_price"],
            #     low = steppingData_index["low_price"],
            #     close = steppingData_index["close_price"],
            #     Geom.candlestick,
            #     Scale.color_discrete_manual("green", "red"),
            #     Scale.x_discrete,
            #     Guide.title("pick stock model ( training )"),
            #     # points2,
            #     # points3,
            #     # Guide.manual_discrete_key("Strategy Trading", ["buy", "sell"]; ["blue", "blue"]),
            #     # Guide.manual_discrete_key(title="Strategy Trading", labels=["buy", "sell"]; pos=[], color=["blue", "blue"], shape=[], size=[]),
            # );
            # Gadfly.draw(
            #     Gadfly.SVG(
            #         "./Curvefit.svg",
            #         21cm,
            #         21cm
            #     ),  # 保存爲 .svg 格式圖片;
            #     # Gadfly.PDF(
            #     #     "Curvefit.pdf",
            #     #     21cm,
            #     #     21cm
            #     # ),  # 保存爲 .pdf 格式圖片;
            #     # Gadfly.PNG(
            #     #     "Curvefit.png",
            #     #     21cm,
            #     #     21cm
            #     # ),  # 保存爲 .png 格式圖片;
            #     img1
            # );
        end

        # # Gadfly.hstack(img1, img2);
        # # Gadfly.title(Gadfly.hstack(img1, img2), "pick stock model optimization");
        # Gadfly.vstack(Gadfly.hstack(img1), Gadfly.hstack(img2));
        # Gadfly.title(Gadfly.vstack(Gadfly.hstack(img1), Gadfly.hstack(img2)), "pick stock model optimization");

        # return_stepping_Dict[ticker_symbol]["Curve-fit-image"] = img1;  # 擬合曲綫繪圖;
        return_stepping_Dict["Curve-fit-image"] = img1;  # 擬合曲綫繪圖;
    end

    return return_stepping_Dict;
end



# # 函數使用示例;
# using JLD;  # 導入第三方擴展包「JLD」，用於操作 Julia 語言專有的硬盤「.jld」文檔數據，需要在控制臺先安裝第三方擴展包「JLD」：julia> using Pkg; Pkg.add("JLD") 成功之後才能使用;
# # https://github.com/JuliaIO/JLD.jl
# # using HDF5;
# # https://github.com/JuliaIO/HDF5.jl
# # using DataFrames;  # 導入第三方擴展包「DataFrames」，需要在控制臺先安裝第三方擴展包「DataFrames」：julia> using Pkg; Pkg.add("DataFrames") 成功之後才能使用;
# # https://github.com/JuliaData/DataFrames.jl
# # https://dataframes.juliadata.org/stable/
# # 將字典（Base.Dict）類型數據，寫入磁盤（hide disk）的 Julia 語言特有類型的 JLD 類型（.jld）的變量存儲文檔;
# output_jld_K_Line_Daily_file = "C:/QuantitativeTrading/Data/steppingData.jld";
# # JLD.save(
# #     output_jld_K_Line_Daily_file,
# #     "stepping_data",
# #     stepping_data
# # );
# stepping_data = JLD.load(
#     output_jld_K_Line_Daily_file,
#     "stepping_data"
# );
# # println(stepping_data);
# if !(Base.isa(stepping_data, Base.Dict) && Base.length(stepping_data) > 0)
#     Base.write(Base.stdout, Base.string("Error : stepping test data sequence Dictionary unrecognize .") * "\n" * Base.string("stepping_data::Base.Dict{Core.String, Core.Any} .") * "\n");
#     Base.exit(0);
# end

# # # 優化求解擇時參數;
# # MarketTiming_Parameter = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則優化之後得到的擇時規則的輸入參數存儲字典;
# # weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
# # Plower_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();
# # Pupper_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();
# # if Base.isa(stepping_data, Base.Dict) && Base.length(stepping_data) > 0
# #     for (key, value) in stepping_data
# #         # println("Key: $key, Value: $value");
# #         if Base.isa(value, Base.Dict) && (Base.haskey(value, "date_transaction") && Base.typeof(value["date_transaction"]) <: Core.Array) && (Base.haskey(value, "turnover_volume") && Base.typeof(value["turnover_volume"]) <: Core.Array) && (Base.haskey(value, "opening_price") && Base.typeof(value["opening_price"]) <: Core.Array) && (Base.haskey(value, "close_price") && Base.typeof(value["close_price"]) <: Core.Array) && (Base.haskey(value, "low_price") && Base.typeof(value["low_price"]) <: Core.Array) && (Base.haskey(value, "high_price") && Base.typeof(value["high_price"]) <: Core.Array) && (Base.haskey(value, "focus") && Base.typeof(value["focus"]) <: Core.Array) && (Base.haskey(value, "amplitude") && Base.typeof(value["amplitude"]) <: Core.Array) && (Base.haskey(value, "amplitude_rate") && Base.typeof(value["amplitude_rate"]) <: Core.Array) && (Base.haskey(value, "opening_price_Standardization") && Base.typeof(value["opening_price_Standardization"]) <: Core.Array) && (Base.haskey(value, "closing_price_Standardization") && Base.typeof(value["closing_price_Standardization"]) <: Core.Array) && (Base.haskey(value, "low_price_Standardization") && Base.typeof(value["low_price_Standardization"]) <: Core.Array) && (Base.haskey(value, "high_price_Standardization") && Base.typeof(value["high_price_Standardization"]) <: Core.Array) && (Base.haskey(value, "turnover_volume_growth_rate") && Base.typeof(value["turnover_volume_growth_rate"]) <: Core.Array) && (Base.haskey(value, "opening_price_growth_rate") && Base.typeof(value["opening_price_growth_rate"]) <: Core.Array) && (Base.haskey(value, "closing_price_growth_rate") && Base.typeof(value["closing_price_growth_rate"]) <: Core.Array) && (Base.haskey(value, "closing_minus_opening_price_growth_rate") && Base.typeof(value["closing_minus_opening_price_growth_rate"]) <: Core.Array) && (Base.haskey(value, "high_price_proportion") && Base.typeof(value["high_price_proportion"]) <: Core.Array) && (Base.haskey(value, "low_price_proportion") && Base.typeof(value["low_price_proportion"]) <: Core.Array)

# #             x0 = value["date_transaction"];  # 交易日期;
# #             x1 = value["turnover_volume"];  # 成交量;
# #             # x2 = value["turnover_amount"];  # 成交總金額;
# #             x3 = value["opening_price"];  # 開盤成交價;
# #             x4 = value["close_price"];  # 收盤成交價;
# #             x5 = value["low_price"];  # 最低成交價;
# #             x6 = value["high_price"];  # 最高成交價;
# #             x7 = value["focus"];  # 當日成交價重心;
# #             x8 = value["amplitude"];  # 當日成交價絕對振幅;
# #             x9 = value["amplitude_rate"];  # 當日成交價相對振幅（%）;
# #             x10 = value["opening_price_Standardization"];  # 日棒缐（K Line Daily）數據交易日首筆成交價（開盤價）標準化值;
# #             x11 = value["closing_price_Standardization"];  # 日棒缐（K Line Daily）數據交易日尾筆成交價（收盤價）標準化值;
# #             x12 = value["low_price_Standardization"];  # 日棒缐（K Line Daily）數據交易日最低成交價標準化值;
# #             x13 = value["high_price_Standardization"];  # 日棒缐（K Line Daily）數據交易日最高成交價標準化值;
# #             x14 = value["turnover_volume_growth_rate"];  # 成交量的成長率;
# #             x15 = value["opening_price_growth_rate"];  # 開盤價的成長率;
# #             x16 = value["closing_price_growth_rate"];  # 收盤價的成長率;
# #             x17 = value["closing_minus_opening_price_growth_rate"];  # 收盤價減開盤價的成長率;
# #             x18 = value["high_price_proportion"];  # 收盤價和開盤價裏的最大值占最高價的比例;
# #             x19 = value["low_price_proportion"];  # 最低價占收盤價和開盤價裏的最小值的比例;
# #             # x20 = value["turnover_rate"];  # 成交量換手率;
# #             # x21 = value["price_earnings"];  # 每股收益（公司經營利潤率 ÷ 股本）;
# #             # x22 = value["book_value_per_share"];  # 每股净值（公司净資產 ÷ 股本）;
# #             # x23 = value["capitalization"];  # 總市值;
# #             # x24 = value["moving_average_5"];  # 收盤價 5 日滑動平均缐;
# #             # x25 = value["moving_average_10"];  # 收盤價 10 日滑動平均缐;
# #             # x26 = value["moving_average_20"];  # 收盤價 20 日滑動平均缐;
# #             # x27 = value["moving_average_30"];  # 收盤價 30 日滑動平均缐;
# #             Pdata_0 = value["Pdata_0"];
# #             Plower = value["Plower"];
# #             Pupper = value["Pupper"];
# #             weight = value["weight"];

# #             # investment_method = "Long_Position"
# #             return_MarketTiming = MarketTiming(
# #                 training_data = Base.Dict{Core.String, Core.Any}(
# #                     Base.string(key) => Base.Dict{Core.String, Core.Any}(
# #                         "date_transaction" => x0,
# #                         "turnover_volume" => x1,
# #                         "opening_price" => x3,
# #                         "close_price" => x4,
# #                         "low_price" => x5,
# #                         "high_price" => x6,
# #                         "focus" => x7,
# #                         "amplitude" => x8,
# #                         "amplitude_rate" => x9,
# #                         "opening_price_Standardization" => x10,
# #                         "closing_price_Standardization" => x11,
# #                         "low_price_Standardization" => x12,
# #                         "high_price_Standardization" => x13,
# #                         "turnover_volume_growth_rate" => x14,
# #                         "opening_price_growth_rate" => x15,
# #                         "closing_price_growth_rate" => x16,
# #                         "closing_minus_opening_price_growth_rate" => x17,
# #                         "high_price_proportion" => x18,
# #                         "low_price_proportion" => x19,
# #                         "Pdata_0" => Pdata_0,
# #                         "Plower" => Plower,
# #                         "Pupper" => Pupper,
# #                         "weight" => weight
# #                     )
# #                 ),  # ::Core.Array{Core.Float64, 2} = testing_data,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
# #                 # training_date_transaction = Core.Array{Dates.Date, 1}(),
# #                 # training_opening_price = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
# #                 # training_close_price = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
# #                 # training_low_price = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
# #                 # training_high_price = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
# #                 # training_turnover_volume = Core.Array{Core.Union{Core.UInt64, Core.String, Core.Nothing}, 1}(),
# #                 # training_turnover_rate = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
# #                 # training_price_earnings = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
# #                 testing_data = Base.Dict{Core.String, Core.Any}(
# #                     Base.string(key) => Base.Dict{Core.String, Core.Any}(
# #                         "date_transaction" => x0,
# #                         "turnover_volume" => x1,
# #                         "opening_price" => x3,
# #                         "close_price" => x4,
# #                         "low_price" => x5,
# #                         "high_price" => x6,
# #                         "focus" => x7,
# #                         "amplitude" => x8,
# #                         "amplitude_rate" => x9,
# #                         "opening_price_Standardization" => x10,
# #                         "closing_price_Standardization" => x11,
# #                         "low_price_Standardization" => x12,
# #                         "high_price_Standardization" => x13,
# #                         "turnover_volume_growth_rate" => x14,
# #                         "opening_price_growth_rate" => x15,
# #                         "closing_price_growth_rate" => x16,
# #                         "closing_minus_opening_price_growth_rate" => x17,
# #                         "high_price_proportion" => x18,
# #                         "low_price_proportion" => x19,
# #                         "Pdata_0" => Pdata_0,
# #                         "Plower" => Plower,
# #                         "Pupper" => Pupper,
# #                         "weight" => weight
# #                     )
# #                 ),  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
# #                 # testing_date_transaction = Core.Array{Dates.Date, 1}(),
# #                 # testing_opening_price = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
# #                 # testing_close_price = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
# #                 # testing_low_price = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
# #                 # testing_high_price = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
# #                 # testing_turnover_volume = Core.Array{Core.Union{Core.UInt64, Core.String, Core.Nothing}, 1}(),
# #                 # testing_turnover_rate = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
# #                 # testing_price_earnings = Core.Array{Core.Union{Core.Float16, Core.String, Core.Nothing}, 1}(),
# #                 Pdata_0 = [Core.Int64(3), Core.Float64(+0.1), Core.Float64(-0.1), Core.Float64(0.0)],  # [Pdata_0[1], Pdata_0[2], Pdata_0[3], Pdata_0[4]],  # Pdata_0, # value["Pdata_0"],
# #                 weight = Core.Array{Core.Float64, 1}(),  # weight,  # value["weight"],
# #                 Plower = [-Base.Inf, -Base.Inf, -Base.Inf, -Base.Inf],  # [Plower[1], Plower[2], Plower[3], Plower[4]],  # Plower, # value["Plower"],
# #                 Pupper = [+Base.Inf, +Base.Inf, +Base.Inf, +Base.Inf],  # [Pupper[1], Pupper[2], Pupper[3], Pupper[4]],  # Pupper, # value["Pupper"],
# #                 MarketTiming_fit_model = MarketTiming_fit_model,
# #                 Quantitative_Indicators_Function = Intuitive_Momentum_KLine,
# #                 investment_method = "Long_Position"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
# #             );
# #             # return_MarketTiming === Base.Dict{Core.String, Core.Any}(
# #             #     "ticker_symbol" => Base.Dict{Core.String, Core.Any}(
# #             #         "Coefficient" => coefficient_from_fit,  # 最優化計算之後得到的參數;
# #             #         "y_profit" => y_profit,  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
# #             #         "y_Long_Position_profit" => y_Long_Position_profit,  # 優化目標變量;
# #             #         "y_Short_Selling_profit" => y_Short_Selling_profit,  # 優化目標變量;
# #             #         "y_loss" => y_loss,  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
# #             #         "y_Long_Position_loss" => y_Long_Position_loss,  # 優化目標變量;
# #             #         "y_Short_Selling_loss" => y_Short_Selling_loss,  # 優化目標變量;
# #             #         "profit_total" => y_total,  # 每兩次對衝交易利潤 × 權重，纍加總計;
# #             #         "Long_Position_profit_total" => y_total_Long_Position,  # 每兩次對衝交易利潤 × 權重，纍加總計;
# #             #         "Short_Selling_profit_total" => y_total_Short_Selling,  # 每兩次對衝交易利潤 × 權重，纍加總計;
# #             #         "profit_Positive" => y_Positive,  # 每兩次對衝交易收益纍加總計;
# #             #         "Long_Position_profit_Positive" => y_Positive_Long_Position,  # 每兩次對衝交易收益纍加總計;
# #             #         "Short_Selling_profit_Positive" => y_Positive_Short_Selling,  # 每兩次對衝交易收益纍加總計;
# #             #         "profit_Positive_probability" => y_P_Positive,  # 每兩次對衝交易正利潤概率;
# #             #         "Long_Position_profit_Positive_probability" => y_P_Positive_Long_Position,  # 每兩次對衝交易正利潤概率;
# #             #         "Short_Selling_profit_Positive_probability" => y_P_Positive_Short_Selling,  # 每兩次對衝交易正利潤概率;
# #             #         "profit_Negative" => y_Negative,  # 每兩次對衝交易損失纍加總計;
# #             #         "Long_Position_profit_Negative" => y_Negative_Long_Position,  # 每兩次對衝交易損失纍加總計;
# #             #         "Short_Selling_profit_Negative" => y_Negative_Short_Selling,  # 每兩次對衝交易損失纍加總計;
# #             #         "profit_Negative_probability" => y_P_Negative,  # 每兩次對衝交易負利潤概率;
# #             #         "Long_Position_profit_Negative_probability" => y_P_Negative_Long_Position,  # 每兩次對衝交易負利潤概率;
# #             #         "Short_Selling_profit_Negative_probability" => y_P_Negative_Short_Selling,  # 每兩次對衝交易負利潤概率;
# #             #         "Long_Position_profit_date_transaction" => y_A_Long_Position,  # 每兩次對衝交易利潤，向量;
# #             #         "Short_Selling_profit_date_transaction" => y_A_Short_Selling,  # 每兩次對衝交易利潤，向量;
# #             #         "maximum_drawdown" => y_maximum_drawdown,  # 兩次對衝交易之間的最大回撤值，取極值統計;
# #             #         "maximum_drawdown_Long_Position" => y_maximum_drawdown_Long_Position,  # 兩次對衝交易之間的最大回撤值，取極值統計;
# #             #         "maximum_drawdown_Short_Selling" => y_maximum_drawdown_Short_Selling,  # 兩次對衝交易之間的最大回撤值，取極值統計;
# #             #         "Long_Position_drawdown_date_transaction" => y_H_Long_Position,  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
# #             #         "Short_Selling_drawdown_date_transaction" => y_H_Short_Selling,  # 向量，記錄做空模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
# #             #         "average_price_amplitude_date_transaction" => y_amplitude,  # 兩兩次對衝交易日成交價振幅平方和，均值;
# #             #         "Long_Position_average_price_amplitude_date_transaction" => y_amplitude_Long_Position,  # 兩兩次對衝交易日成交價振幅平方和，均值;
# #             #         "Short_Selling_average_price_amplitude_date_transaction" => y_amplitude_Short_Selling,  # 兩兩次對衝交易日成交價振幅平方和，均值;
# #             #         "Long_Position_price_amplitude_date_transaction" => y_D_Long_Position,  # 兩次對衝交易日成交價振幅平方和，向量;
# #             #         "Short_Selling_price_amplitude_date_transaction" => y_D_Short_Selling,  # 兩次對衝交易日成交價振幅平方和，向量;
# #             #         "average_volume_turnover_date_transaction" => y_turnover,  # 兩次對衝交易日成交量（換手率）均值;
# #             #         "Long_Position_average_volume_turnover_date_transaction" => y_turnover_Long_Position,  # 兩次對衝交易日成交量（換手率）均值;
# #             #         "Short_Selling_average_volume_turnover_date_transaction" => y_turnover_Short_Selling,  # 兩次對衝交易日成交量（換手率）均值;
# #             #         "Long_Position_volume_turnover_date_transaction" => y_E_Long_Position,  # 兩次對衝交易日成交量（換手率）向量;
# #             #         "Short_Selling_volume_turnover_date_transaction" => y_E_Short_Selling,  # 兩次對衝交易日成交量（換手率）向量;
# #             #         "average_date_transaction_between" => y_date_transaction_between,  # 兩次對衝交易間隔日長，均值;
# #             #         "Long_Position_average_date_transaction_between" => y_date_transaction_between_Long_Position,  # 兩次對衝交易間隔日長，均值;
# #             #         "Short_Selling_average_date_transaction_between" => y_date_transaction_between_Short_Selling,  # 兩次對衝交易間隔日長，均值;
# #             #         "Long_Position_date_transaction_between" => y_C_Long_Position,  # 兩次對衝交易間隔日長，向量;
# #             #         "Short_Selling_date_transaction_between" => y_C_Short_Selling,  # 兩次對衝交易間隔日長，向量;
# #             #         "Long_Position_date_transaction" => y_F_Long_Position,  # 按規則執行交易的日期，向量;
# #             #         "Short_Selling_date_transaction" => y_F_Short_Selling,  # 按規則執行交易的日期，向量;
# #             #         "P1_Array" => P1_Array,  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
# #             #         "revenue_and_expenditure_records_date_transaction" => y_G,  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
# #             #         "weight_MarketTiming" => weight_MarketTiming_Dict
# #             #     );
# #             # );
# #             # println(return_MarketTiming[key]["Coefficient"]);  # 最優化計算之後得到的參數;
# #             # println(return_MarketTiming[key]["y_profit"]);  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
# #             # println(return_MarketTiming[key]["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
# #             # println(return_MarketTiming[key]["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 頻率 × 權重，加權纍加總計;
# #             # println(return_MarketTiming[key]["y_loss"]);  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
# #             # println(return_MarketTiming[key]["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
# #             # println(return_MarketTiming[key]["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 頻率 × 權重，加權取極值總計;
# #             # println(return_MarketTiming[key]["profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
# #             # println(return_MarketTiming[key]["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
# #             # println(return_MarketTiming[key]["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 頻率，纍加總計;
# #             # println(return_MarketTiming[key]["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# #             # println(return_MarketTiming[key]["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# #             # println(return_MarketTiming[key]["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# #             # println(return_MarketTiming[key]["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# #             # println(return_MarketTiming[key]["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# #             # println(return_MarketTiming[key]["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# #             # println(return_MarketTiming[key]["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# #             # println(return_MarketTiming[key]["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# #             # println(return_MarketTiming[key]["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# #             # println(return_MarketTiming[key]["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# #             # println(return_MarketTiming[key]["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# #             # println(return_MarketTiming[key]["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# #             # println(return_MarketTiming[key]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
# #             # println(return_MarketTiming[key]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
# #             # println(return_MarketTiming[key]["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# #             # println(return_MarketTiming[key]["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# #             # println(return_MarketTiming[key]["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# #             # println(return_MarketTiming[key]["Long_Position_drawdown_date_transaction"]);  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
# #             # println(return_MarketTiming[key]["Short_Selling_drawdown_date_transaction"]);  # 向量，記錄做多模式每組對衝交易日的回撤值序列，風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
# #             # println(return_MarketTiming[key]["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# #             # println(return_MarketTiming[key]["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# #             # println(return_MarketTiming[key]["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# #             # println(return_MarketTiming[key]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
# #             # println(return_MarketTiming[key]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
# #             # println(return_MarketTiming[key]["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# #             # println(return_MarketTiming[key]["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# #             # println(return_MarketTiming[key]["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# #             # println(return_MarketTiming[key]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
# #             # println(return_MarketTiming[key]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
# #             # println(return_MarketTiming[key]["average_date_transaction_between"]);  # 兩次交易間隔日長，均值;
# #             # println(return_MarketTiming[key]["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# #             # println(return_MarketTiming[key]["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# #             # println(return_MarketTiming[key]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
# #             # println(return_MarketTiming[key]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
# #             # println(return_MarketTiming[key]["weight_MarketTiming"]);  # 擇時權重，每兩次對衝交易的盈利概率占比;
# #             # println(return_MarketTiming[key]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
# #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
# #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
# #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
# #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
# #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
# #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
# #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
# #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
# #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
# #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
# #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
# #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
# #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
# #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
# #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
# #             # println(return_MarketTiming[key]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
# #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
# #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
# #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
# #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
# #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
# #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
# #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
# #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
# #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
# #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
# #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
# #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
# #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
# #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
# #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
# #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
# #             # println(return_MarketTiming[key]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
# #             # println(return_MarketTiming[key]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
# #             # println(return_MarketTiming[key]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
# #             # MarketTiming_Parameter[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
# #             if Base.isa(MarketTiming_Parameter, Base.Dict) && Base.haskey(MarketTiming_Parameter, Base.string(key))
# #                 if Base.isa(MarketTiming_Parameter[Base.string(key)], Base.Dict)
# #                     MarketTiming_Parameter[Base.string(key)]["Long_Position"] = return_MarketTiming[key]["Coefficient"];
# #                 end
# #             elseif Base.isa(MarketTiming_Parameter, Base.Dict) && (!Base.haskey(MarketTiming_Parameter, Base.string(key)))
# #                 MarketTiming_Parameter[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
# #                 MarketTiming_Parameter[Base.string(key)]["Long_Position"] = return_MarketTiming[key]["Coefficient"];
# #             else
# #             end
# #             if Base.isa(weight_MarketTiming_Dict, Base.Dict) && Base.haskey(weight_MarketTiming_Dict, Base.string(key))
# #                 if Base.isa(weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
# #                     weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = return_MarketTiming[key]["weight_MarketTiming"]["Long_Position"];  # 依照擇時規則交易倉位參數的存儲字典;
# #                 end
# #             elseif Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
# #                 weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
# #                 weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = return_MarketTiming[key]["weight_MarketTiming"]["Long_Position"];  # 依照擇時規則交易倉位參數的存儲字典;
# #             else
# #             end
# #             if Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key))
# #                 if Base.isa(Plower_weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
# #                     Plower_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
# #                 end
# #             elseif Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key)))
# #                 Plower_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
# #                 Plower_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
# #             else
# #             end
# #             if Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key))
# #                 if Base.isa(Pupper_weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
# #                     Pupper_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
# #                 end
# #             elseif Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key)))
# #                 Pupper_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
# #                 Pupper_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
# #             else
# #             end
# #             return_MarketTiming = Core.nothing;  # 釋放内存;

# #             # investment_method = "Short_Selling"
# #             return_MarketTiming = MarketTiming(
# #                 training_data = Base.Dict{Core.String, Core.Any}(Base.string(key) => Base.Dict{Core.String, Core.Any}(
# #                     "date_transaction" => x0,
# #                     "turnover_volume" => x1,
# #                     "opening_price" => x3,
# #                     "close_price" => x4,
# #                     "low_price" => x5,
# #                     "high_price" => x6,
# #                     "focus" => x7,
# #                     "amplitude" => x8,
# #                     "amplitude_rate" => x9,
# #                     "opening_price_Standardization" => x10,
# #                     "closing_price_Standardization" => x11,
# #                     "low_price_Standardization" => x12,
# #                     "high_price_Standardization" => x13,
# #                     "turnover_volume_growth_rate" => x14,
# #                     "opening_price_growth_rate" => x15,
# #                     "closing_price_growth_rate" => x16,
# #                     "closing_minus_opening_price_growth_rate" => x17,
# #                     "high_price_proportion" => x18,
# #                     "low_price_proportion" => x19,
# #                     "Pdata_0" => Pdata_0,
# #                     "Plower" => Plower,
# #                     "Pupper" => Pupper,
# #                     "weight" => weight
# #                     )
# #                 ),  # ::Core.Array{Core.Float64, 2} = testing_data,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
# #                 testing_data = Base.Dict{Core.String, Core.Any}(Base.string(key) => Base.Dict{Core.String, Core.Any}(
# #                     "date_transaction" => x0,
# #                     "turnover_volume" => x1,
# #                     "opening_price" => x3,
# #                     "close_price" => x4,
# #                     "low_price" => x5,
# #                     "high_price" => x6,
# #                     "focus" => x7,
# #                     "amplitude" => x8,
# #                     "amplitude_rate" => x9,
# #                     "opening_price_Standardization" => x10,
# #                     "closing_price_Standardization" => x11,
# #                     "low_price_Standardization" => x12,
# #                     "high_price_Standardization" => x13,
# #                     "turnover_volume_growth_rate" => x14,
# #                     "opening_price_growth_rate" => x15,
# #                     "closing_price_growth_rate" => x16,
# #                     "closing_minus_opening_price_growth_rate" => x17,
# #                     "high_price_proportion" => x18,
# #                     "low_price_proportion" => x19,
# #                     "Pdata_0" => Pdata_0,
# #                     "Plower" => Plower,
# #                     "Pupper" => Pupper,
# #                     "weight" => weight
# #                     )
# #                 ),  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
# #                 Pdata_0 = [Core.Int64(3), Core.Float64(+0.1), Core.Float64(-0.1), Core.Float64(0.0)],  # [Pdata_0[1], Pdata_0[2], Pdata_0[3], Pdata_0[4]],  # Pdata_0, # value["Pdata_0"],
# #                 weight = Core.Array{Core.Float64, 1}(),  # weight,  # value["weight"],
# #                 Plower = [-Base.Inf, -Base.Inf, -Base.Inf, -Base.Inf],  # [Plower[1], Plower[2], Plower[3], Plower[4]],  # Plower, # value["Plower"],
# #                 Pupper = [+Base.Inf, +Base.Inf, +Base.Inf, +Base.Inf],  # [Pupper[1], Pupper[2], Pupper[3], Pupper[4]],  # Pupper, # value["Pupper"],
# #                 MarketTiming_fit_model = MarketTiming_fit_model,
# #                 Quantitative_Indicators_Function = Intuitive_Momentum_KLine,
# #                 investment_method = "Short_Selling"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
# #             );
# #             if Base.isa(MarketTiming_Parameter, Base.Dict) && Base.haskey(MarketTiming_Parameter, Base.string(key))
# #                 if Base.isa(MarketTiming_Parameter[Base.string(key)], Base.Dict)
# #                     MarketTiming_Parameter[Base.string(key)]["Short_Selling"] = return_MarketTiming[key]["Coefficient"];
# #                 end
# #             elseif Base.isa(MarketTiming_Parameter, Base.Dict) && (!Base.haskey(MarketTiming_Parameter, Base.string(key)))
# #                 MarketTiming_Parameter[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
# #                 MarketTiming_Parameter[Base.string(key)]["Short_Selling"] = return_MarketTiming[key]["Coefficient"];
# #             else
# #             end
# #             if Base.isa(weight_MarketTiming_Dict, Base.Dict) && Base.haskey(weight_MarketTiming_Dict, Base.string(key))
# #                 if Base.isa(weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
# #                     weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = return_MarketTiming[key]["weight_MarketTiming"]["Short_Selling"];  # 依照擇時規則交易倉位參數的存儲字典;
# #                 end
# #             elseif Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
# #                 weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
# #                 weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = return_MarketTiming[key]["weight_MarketTiming"]["Short_Selling"];  # 依照擇時規則交易倉位參數的存儲字典;
# #             else
# #             end
# #             if Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key))
# #                 if Base.isa(Plower_weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
# #                     Plower_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
# #                 end
# #             elseif Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key)))
# #                 Plower_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
# #                 Plower_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
# #             else
# #             end
# #             if Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key))
# #                 if Base.isa(Pupper_weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
# #                     Pupper_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
# #                 end
# #             elseif Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key)))
# #                 Pupper_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
# #                 Pupper_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
# #             else
# #             end
# #             return_MarketTiming = Core.nothing;  # 釋放内存;
# #         end
# #     end
# # end
# # # println(MarketTiming_Parameter);
# # # println(weight_MarketTiming_Dict);
# # # println(Plower_weight_MarketTiming_Dict);
# # # println(Pupper_weight_MarketTiming_Dict);

# # # 優化求解選股參數;
# # PickStock_Parameter = Base.Dict{Core.String, Core.Any}();  # 依照選股規則優化之後得到的選股規則的輸入參數存儲字典;
# # PickStock_ticker_symbol = Core.Array{Core.Any, 1}();  # Core.Array{Core.Array{Core.String, 1}, 1}();
# # weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
# # Plower_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
# # Pupper_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
# # if Base.isa(stepping_data, Base.Dict) && Base.length(stepping_data) > 0

# #     # x0 = stepping_data["ticker_symbol"]["date_transaction"];  # 交易日期;
# #     # x1 = stepping_data["ticker_symbol"]["turnover_volume"];  # 成交量;
# #     # # x2 = stepping_data["ticker_symbol"]["turnover_amount"];  # 成交總金額;
# #     # x3 = stepping_data["ticker_symbol"]["opening_price"];  # 開盤成交價;
# #     # x4 = stepping_data["ticker_symbol"]["close_price"];  # 收盤成交價;
# #     # x5 = stepping_data["ticker_symbol"]["low_price"];  # 最低成交價;
# #     # x6 = stepping_data["ticker_symbol"]["high_price"];  # 最高成交價;
# #     # x7 = stepping_data["ticker_symbol"]["focus"];  # 當日成交價重心;
# #     # x8 = stepping_data["ticker_symbol"]["amplitude"];  # 當日成交價絕對振幅;
# #     # x9 = stepping_data["ticker_symbol"]["amplitude_rate"];  # 當日成交價相對振幅（%）;
# #     # x10 = stepping_data["ticker_symbol"]["opening_price_Standardization"];  # 日棒缐（K Line Daily）數據交易日首筆成交價（開盤價）標準化值;
# #     # x11 = stepping_data["ticker_symbol"]["closing_price_Standardization"];  # 日棒缐（K Line Daily）數據交易日尾筆成交價（收盤價）標準化值;
# #     # x12 = stepping_data["ticker_symbol"]["low_price_Standardization"];  # 日棒缐（K Line Daily）數據交易日最低成交價標準化值;
# #     # x13 = stepping_data["ticker_symbol"]["high_price_Standardization"];  # 日棒缐（K Line Daily）數據交易日最高成交價標準化值;
# #     # x14 = stepping_data["ticker_symbol"]["turnover_volume_growth_rate"];  # 成交量的成長率;
# #     # x15 = stepping_data["ticker_symbol"]["opening_price_growth_rate"];  # 開盤價的成長率;
# #     # x16 = stepping_data["ticker_symbol"]["closing_price_growth_rate"];  # 收盤價的成長率;
# #     # x17 = stepping_data["ticker_symbol"]["closing_minus_opening_price_growth_rate"];  # 收盤價減開盤價的成長率;
# #     # x18 = stepping_data["ticker_symbol"]["high_price_proportion"];  # 收盤價和開盤價裏的最大值占最高價的比例;
# #     # x19 = stepping_data["ticker_symbol"]["low_price_proportion"];  # 最低價占收盤價和開盤價裏的最小值的比例;
# #     # # x20 = stepping_data["ticker_symbol"]["turnover_rate"];  # 成交量換手率;
# #     # # x21 = stepping_data["ticker_symbol"]["price_earnings"];  # 每股收益（公司經營利潤率 ÷ 股本）;
# #     # # x22 = stepping_data["ticker_symbol"]["book_value_per_share"];  # 每股净值（公司净資產 ÷ 股本）;
# #     # # x23 = stepping_data["ticker_symbol"]["capitalization"];  # 總市值;
# #     # # x24 = stepping_data["ticker_symbol"]["moving_average_5"];  # 收盤價 5 日滑動平均缐;
# #     # # x25 = stepping_data["ticker_symbol"]["moving_average_10"];  # 收盤價 10 日滑動平均缐;
# #     # # x26 = stepping_data["ticker_symbol"]["moving_average_20"];  # 收盤價 20 日滑動平均缐;
# #     # # x27 = stepping_data["ticker_symbol"]["moving_average_30"];  # 收盤價 30 日滑動平均缐;
# #     # Pdata_0 = stepping_data["ticker_symbol"]["Pdata_0"];
# #     # Plower = stepping_data["ticker_symbol"]["Plower"];
# #     # Pupper = stepping_data["ticker_symbol"]["Pupper"];
# #     # weight = stepping_data["ticker_symbol"]["weight"];
# #     # Pdata_0 = stepping_data["Pdata_0"];
# #     # Plower = stepping_data["Plower"];
# #     # Pupper = stepping_data["Pupper"];
# #     # weight = stepping_data["weight"];

# #     # investment_method = "Long_Position"
# #     return_PickStock = PickStock(
# #         training_data = stepping_data,  # ::Core.Array{Core.Float64, 2} = testing_data,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
# #         testing_data = stepping_data,  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
# #         Pdata_0 = [Core.Int64(3), Core.Int64(10)],  # [Pdata_0[1], Pdata_0[2]],  # Pdata_0, # value["Pdata_0"],
# #         weight = Core.Array{Core.Float64, 1}(),  # weight,  # value["weight"],
# #         Plower = [-Base.Inf, -Base.Inf],  # [Plower[1], Plower[2]],  # Plower, # value["Plower"],
# #         Pupper = [+Base.Inf, +Base.Inf],  # [Pupper[1], Pupper[2]],  # Pupper, # value["Pupper"],
# #         MarketTiming_Parameter = MarketTiming_Parameter,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
# #         PickStock_fit_model = PickStock_fit_model,
# #         MarketTiming = MarketTiming,
# #         MarketTiming_fit_model = MarketTiming_fit_model,
# #         Quantitative_Indicators_Function = Intuitive_Momentum_KLine,
# #         investment_method = "Long_Position"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
# #     );
# #     # println("optimization - coefficient : ", return_PickStock["Coefficient"]);  # 最優化計算之後得到的參數;
# #     # println("optimization - coefficient StandardDeviation : ", return_PickStock["Coefficient-StandardDeviation"]);  # 擬合得到的參數解的標準差;
# #     # println("optimization - coefficient Confidence Lower 95% : ", return_PickStock["Coefficient-Confidence-Lower-95%"]);  # 擬合得到的參數解的區間估計下限;
# #     # println("optimization - coefficient Confidence Upper 95% : ", return_PickStock["Coefficient-Confidence-Upper-95%"]);  # 擬合得到的參數解的區間估計上限;
# #     # println("y - fit : ", return_PickStock["Yfit"]);  # 擬合 y 值;
# #     # println("y - fit Uncertainty Lower : ", return_PickStock["Yfit-Uncertainty-Lower"]);  # 擬合的應變量 Yvals 誤差下限;
# #     # println("y - fit Uncertainty Upper : ", return_PickStock["Yfit-Uncertainty-Upper"]);  # 擬合的應變量 Yvals 誤差上限;
# #     # println("residual : ", return_PickStock["Residual"]);  # 擬合殘差;
# #     # println("optimization - y_profit : ", return_PickStock["y_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
# #     # println("Long Position optimization - y_profit : ", return_PickStock["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
# #     # println("Short Selling optimization - y_profit : ", return_PickStock["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
# #     # println("optimization - y_loss : ", return_PickStock["y_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
# #     # println("Long Position optimization - y_loss : ", return_PickStock["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
# #     # println("Short Selling optimization - y_loss : ", return_PickStock["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
# #     # println("maximum_drawdown : ", return_PickStock["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# #     # println("maximum_drawdown_Long_Position : ", return_PickStock["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# #     # println("maximum_drawdown_Short_Selling : ", return_PickStock["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# #     # println("profit total per share : ", return_PickStock["profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# #     # println("Long Position profit total per share : ", return_PickStock["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# #     # println("Short Selling profit total per share : ", return_PickStock["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# #     # println("profit Positive : ", return_PickStock["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# #     # println("Long Position profit Positive : ", return_PickStock["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# #     # println("Short Selling_profit Positive : ", return_PickStock["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# #     # println("profit Positive probability : ", return_PickStock["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# #     # println("Long Position profit Positive probability : ", return_PickStock["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# #     # println("Short Selling profit Positive probability : ", return_PickStock["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# #     # println("profit Negative : ", return_PickStock["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# #     # println("Long Position profit Negative : ", return_PickStock["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# #     # println("Short Selling profit Negative : ", return_PickStock["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# #     # println("profit Negative probability : ", return_PickStock["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# #     # println("Long Position profit Negative probability : ", return_PickStock["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# #     # println("Short Selling profit Negative probability : ", return_PickStock["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# #     # println("average price amplitude date transaction : ", return_PickStock["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# #     # println("Long Position average price amplitude date transaction : ", return_PickStock["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# #     # println("Short Selling average price amplitude date transaction : ", return_PickStock["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# #     # println("average volume turnover date transaction : ", return_PickStock["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# #     # println("Long Position average volume turnover date transaction : ", return_PickStock["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# #     # println("Short Selling average volume turnover date transaction : ", return_PickStock["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# #     # println("average date transaction between : ", return_PickStock["average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# #     # println("Long Position average date transaction between : ", return_PickStock["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# #     # println("Short Selling average date transaction between : ", return_PickStock["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# #     # println("number PickStock transaction : ", return_PickStock["number_PickStock_transaction"]);  # 交易過股票的總隻數，函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
# #     # println("weight_PickStock : ", return_PickStock["weight_PickStock"]);  # 選股權重，每隻股票的盈利概率占比;
# #     # println("pick stock sort ticker symbol : ", return_PickStock["PickStock_sort"]["ticker_symbol"]);  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;
# #     # println("pick stock sort score : ", return_PickStock["PickStock_sort"]["score"]);  # 依照選股規則排序篩選出的股票得分值存儲數組;
# #     # println(return_PickStock["PickStock_transaction_sequence"]);  # 記錄按規則篩選股票按照擇時規則交易信息的序列字典（Dict）;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]);  # 記錄按規則篩選股票按照擇時規則交易信息的序列字典（Dict）;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
# #     # println(return_PickStock["PickStock_transaction_sequence"]["ticker_symbol"]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
# #     # println("test profit estimate : ", return_PickStock["test_profit"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# #     # println("test odds ratio estimate : ", return_PickStock["test_odds_ratio"]);
# #     # println("test date transaction between : ", return_PickStock["test_date_transaction_between"]);
# #     # # println(return_PickStock["testData"]);;  # 傳入測試數據集的計算結果;
# #     # println("test profit total per share : ", return_PickStock["testData"]["profit_total"]);
# #     # println("test Long Position profit total per share : ", return_PickStock["testData"]["Long_Position_profit_total"]);
# #     # println("test Short Selling profit total per share : ", return_PickStock["testData"]["Short_Selling_profit_total"]);
# #     # println("test profit positive per share : ", return_PickStock["testData"]["profit_Positive"]);
# #     # println("test Long Position profit positive per share : ", return_PickStock["testData"]["Long_Position_profit_Positive"]);
# #     # println("test Short Selling profit positive per share : ", return_PickStock["testData"]["Short_Selling_profit_Positive"]);
# #     # println("test profit positive probability : ", return_PickStock["testData"]["profit_Positive_probability"]);
# #     # println("test Long Position profit positive probability : ", return_PickStock["testData"]["Long_Position_profit_Positive_probability"]);
# #     # println("test Short Selling profit positive probability : ", return_PickStock["testData"]["Short_Selling_profit_Positive_probability"]);
# #     # println("test profit negative per share : ", return_PickStock["testData"]["profit_Negative"]);
# #     # println("test Long Position profit negative per share : ", return_PickStock["testData"]["Long_Position_profit_Negative"]);
# #     # println("test Short Selling profit negative per share : ", return_PickStock["testData"]["Short_Selling_profit_Negative"]);
# #     # println("test profit negative probability : ", return_PickStock["testData"]["profit_Negative_probability"]);
# #     # println("test Long Position profit negative probability : ", return_PickStock["testData"]["Long_Position_profit_Negative_probability"]);
# #     # println("test Short Selling profit negative probability : ", return_PickStock["testData"]["Short_Selling_profit_Negative_probability"]);
# #     # println("test average date transaction between : ", return_PickStock["testData"]["average_date_transaction_between"]);
# #     # println("test Long Position average date transaction between : ", return_PickStock["testData"]["Long_Position_average_date_transaction_between"]);
# #     # println("test Short Selling average date transaction between : ", return_PickStock["testData"]["Short_Selling_average_date_transaction_between"]);
# #     # println("test number_PickStock_transaction : ", return_PickStock["testData"]["number_PickStock_transaction"]);  # 交易過股票的總隻數;
# #     # # println(return_PickStock["testData"]["PickStock_transaction_sequence"]["002611"]["P1_Array"]);
# #     # # println(return_PickStock["testData"]["PickStock_transaction_sequence"]["002611"]["Long_Position_date_transaction"]);
# #     # # println(return_PickStock["testData"]["PickStock_transaction_sequence"]["002611"]["Short_Selling_date_transaction"]);
# #     # # println(return_PickStock["testData"]["PickStock_transaction_sequence"]["002611"]);
# #     # PickStock_Parameter = Base.Dict{Core.String, Core.Any}();
# #     PickStock_Parameter["Long_Position"] = return_PickStock["Coefficient"];
# #     PickStock_ticker_symbol = return_PickStock["PickStock_sort"]["ticker_symbol"];  # Core.Array{Core.Any, 1}();  # Core.Array{Core.Array{Core.String, 1}, 1}();
# #     for (key, value) in return_PickStock["weight_PickStock"]
# #         # println("Key: $key, Value: $value");
# #         if Base.isa(value, Base.Dict) && Base.haskey(value, "Long_Position")
# #             if Base.isa(weight_PickStock_Dict, Base.Dict) && Base.haskey(weight_PickStock_Dict, Base.string(key))
# #                 if Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict)
# #                     weight_PickStock_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
# #                 end
# #             elseif Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
# #                 weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
# #                 weight_PickStock_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
# #             else
# #             end
# #             if Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && Base.haskey(Plower_weight_PickStock_Dict, Base.string(key))
# #                 if Base.isa(Plower_weight_PickStock_Dict[Base.string(key)], Base.Dict)
# #                     Plower_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
# #                 end
# #             elseif Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Plower_weight_PickStock_Dict, Base.string(key)))
# #                 Plower_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
# #                 Plower_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
# #             else
# #             end
# #             if Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key))
# #                 if Base.isa(Pupper_weight_PickStock_Dict[Base.string(key)], Base.Dict)
# #                     Pupper_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
# #                 end
# #             elseif Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key)))
# #                 Pupper_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
# #                 Pupper_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
# #             else
# #             end
# #         end
# #     end
# #     return_PickStock = Core.nothing;  # 釋放内存;

# #     # investment_method = "Short_Selling"
# #     return_PickStock = PickStock(
# #         training_data = stepping_data,  # ::Core.Array{Core.Float64, 2} = testing_data,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
# #         testing_data = stepping_data,  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
# #         Pdata_0 = [Core.Int64(3), Core.Int64(10)],  # [Pdata_0[1], Pdata_0[2]],  # Pdata_0, # value["Pdata_0"],
# #         weight = Core.Array{Core.Float64, 1}(),  # weight,  # value["weight"],
# #         Plower = [-Base.Inf, -Base.Inf],  # [Plower[1], Plower[2]],  # Plower, # value["Plower"],
# #         Pupper = [+Base.Inf, +Base.Inf],  # [Pupper[1], Pupper[2]],  # Pupper, # value["Pupper"],
# #         MarketTiming_Parameter = MarketTiming_Parameter,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
# #         PickStock_fit_model = PickStock_fit_model,
# #         MarketTiming = MarketTiming,
# #         MarketTiming_fit_model = MarketTiming_fit_model,
# #         Quantitative_Indicators_Function = Intuitive_Momentum_KLine,
# #         investment_method = "Short_Selling"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
# #     );
# #     PickStock_Parameter["Short_Selling"] = return_PickStock["Coefficient"];
# #     PickStock_ticker_symbol = return_PickStock["PickStock_sort"]["ticker_symbol"];
# #     for (key, value) in return_PickStock["weight_PickStock"]
# #         # println("Key: $key, Value: $value");
# #         if Base.isa(value, Base.Dict) && Base.haskey(value, "Short_Selling")
# #             if Base.isa(weight_PickStock_Dict, Base.Dict) && Base.haskey(weight_PickStock_Dict, Base.string(key))
# #                 if Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict)
# #                     weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
# #                 end
# #             elseif Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
# #                 weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
# #                 weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
# #             else
# #             end
# #             if Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && Base.haskey(Plower_weight_PickStock_Dict, Base.string(key))
# #                 if Base.isa(Plower_weight_PickStock_Dict[Base.string(key)], Base.Dict)
# #                     Plower_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
# #                 end
# #             elseif Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Plower_weight_PickStock_Dict, Base.string(key)))
# #                 Plower_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
# #                 Plower_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
# #             else
# #             end
# #             if Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key))
# #                 if Base.isa(Pupper_weight_PickStock_Dict[Base.string(key)], Base.Dict)
# #                     Pupper_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
# #                 end
# #             elseif Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key)))
# #                 Pupper_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
# #                 Pupper_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
# #             else
# #             end
# #         end
# #     end
# #     return_PickStock = Core.nothing;  # 釋放内存;
# # end
# # # println(PickStock_Parameter);
# # # println(PickStock_ticker_symbol);
# # # println(weight_PickStock_Dict);
# # # println(Plower_weight_PickStock_Dict);
# # # println(Pupper_weight_PickStock_Dict);

# # SizePosition_Parameter_Array = Core.Array{Core.Any, 1}();  # 依照倉位規則優化之後得到的倉位數據存儲字典;
# # # weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
# # # weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
# # if Base.isa(stepping_data, Base.Dict) && Base.length(stepping_data) > 0

# #     # x0 = stepping_data["ticker_symbol"]["date_transaction"];  # 交易日期;
# #     # x1 = stepping_data["ticker_symbol"]["turnover_volume"];  # 成交量;
# #     # # x2 = stepping_data["ticker_symbol"]["turnover_amount"];  # 成交總金額;
# #     # x3 = stepping_data["ticker_symbol"]["opening_price"];  # 開盤成交價;
# #     # x4 = stepping_data["ticker_symbol"]["close_price"];  # 收盤成交價;
# #     # x5 = stepping_data["ticker_symbol"]["low_price"];  # 最低成交價;
# #     # x6 = stepping_data["ticker_symbol"]["high_price"];  # 最高成交價;
# #     # x7 = stepping_data["ticker_symbol"]["focus"];  # 當日成交價重心;
# #     # x8 = stepping_data["ticker_symbol"]["amplitude"];  # 當日成交價絕對振幅;
# #     # x9 = stepping_data["ticker_symbol"]["amplitude_rate"];  # 當日成交價相對振幅（%）;
# #     # x10 = stepping_data["ticker_symbol"]["opening_price_Standardization"];  # 日棒缐（K Line Daily）數據交易日首筆成交價（開盤價）標準化值;
# #     # x11 = stepping_data["ticker_symbol"]["closing_price_Standardization"];  # 日棒缐（K Line Daily）數據交易日尾筆成交價（收盤價）標準化值;
# #     # x12 = stepping_data["ticker_symbol"]["low_price_Standardization"];  # 日棒缐（K Line Daily）數據交易日最低成交價標準化值;
# #     # x13 = stepping_data["ticker_symbol"]["high_price_Standardization"];  # 日棒缐（K Line Daily）數據交易日最高成交價標準化值;
# #     # x14 = stepping_data["ticker_symbol"]["turnover_volume_growth_rate"];  # 成交量的成長率;
# #     # x15 = stepping_data["ticker_symbol"]["opening_price_growth_rate"];  # 開盤價的成長率;
# #     # x16 = stepping_data["ticker_symbol"]["closing_price_growth_rate"];  # 收盤價的成長率;
# #     # x17 = stepping_data["ticker_symbol"]["closing_minus_opening_price_growth_rate"];  # 收盤價減開盤價的成長率;
# #     # x18 = stepping_data["ticker_symbol"]["high_price_proportion"];  # 收盤價和開盤價裏的最大值占最高價的比例;
# #     # x19 = stepping_data["ticker_symbol"]["low_price_proportion"];  # 最低價占收盤價和開盤價裏的最小值的比例;
# #     # # x20 = stepping_data["ticker_symbol"]["turnover_rate"];  # 成交量換手率;
# #     # # x21 = stepping_data["ticker_symbol"]["price_earnings"];  # 每股收益（公司經營利潤率 ÷ 股本）;
# #     # # x22 = stepping_data["ticker_symbol"]["book_value_per_share"];  # 每股净值（公司净資產 ÷ 股本）;
# #     # # x23 = stepping_data["ticker_symbol"]["capitalization"];  # 總市值;
# #     # # x24 = stepping_data["ticker_symbol"]["moving_average_5"];  # 收盤價 5 日滑動平均缐;
# #     # # x25 = stepping_data["ticker_symbol"]["moving_average_10"];  # 收盤價 10 日滑動平均缐;
# #     # # x26 = stepping_data["ticker_symbol"]["moving_average_20"];  # 收盤價 20 日滑動平均缐;
# #     # # x27 = stepping_data["ticker_symbol"]["moving_average_30"];  # 收盤價 30 日滑動平均缐;
# #     # Pdata_0 = stepping_data["ticker_symbol"]["Pdata_0"];
# #     # Plower = stepping_data["ticker_symbol"]["Plower"];
# #     # Pupper = stepping_data["ticker_symbol"]["Pupper"];
# #     # weight = stepping_data["ticker_symbol"]["weight"];
# #     # Pdata_0 = stepping_data["Pdata_0"];
# #     # Plower = stepping_data["Plower"];
# #     # Pupper = stepping_data["Pupper"];
# #     # weight = stepping_data["weight"];

# #     # investment_method = "Long_Position"
# #     return_SizePosition = SizePosition(
# #         training_data = stepping_data,  # ::Core.Array{Core.Float64, 2} = testing_data,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
# #         testing_data = stepping_data,  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
# #         Pdata_0 = [weight_MarketTiming_Dict, weight_PickStock_Dict],  # training_data["002611"]["Pdata_0"],
# #         weight = Core.Array{Core.Float64, 1}(),  # training_data["002611"]["weight"],
# #         Plower = [Plower_weight_MarketTiming_Dict, Plower_weight_PickStock_Dict],
# #         Pupper = [Pupper_weight_MarketTiming_Dict, Pupper_weight_PickStock_Dict],
# #         MarketTiming_Parameter = MarketTiming_Parameter,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
# #         PickStock_Parameter = PickStock_Parameter,  # 按照選股規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
# #         PickStock_ticker_symbol = PickStock_ticker_symbol,  # Core.Array{Core.Any, 1}(),  # ::Core.Array{Core.Array{Core.String, 1}, 1} = Core.Array{Core.Array{Core.String, 1}, 1}(),  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;
# #         SizePosition_fit_model = SizePosition_fit_model,
# #         PickStock = PickStock,
# #         PickStock_fit_model = PickStock_fit_model,
# #         MarketTiming = MarketTiming,
# #         MarketTiming_fit_model = MarketTiming_fit_model,
# #         Quantitative_Indicators_Function = Intuitive_Momentum_KLine,
# #         investment_method = "Long_Position"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
# #     );
# #     # println("optimization - coefficient 1 - weight_MarketTiming :", "\n", return_SizePosition["Coefficient"][1], "\n", "optimization - coefficient 2 - weight_PickStock :", "\n", return_SizePosition["Coefficient"][2]);  # 最優化計算之後得到的參數;
# #     # # println("optimization - coefficient StandardDeviation : ", return_SizePosition["Coefficient-StandardDeviation"]);  # 擬合得到的參數解的標準差;
# #     # # println("optimization - coefficient Confidence Lower 95% : ", return_SizePosition["Coefficient-Confidence-Lower-95%"]);  # 擬合得到的參數解的區間估計下限;
# #     # # println("optimization - coefficient Confidence Upper 95% : ", return_SizePosition["Coefficient-Confidence-Upper-95%"]);  # 擬合得到的參數解的區間估計上限;
# #     # # println("y - fit : ", return_SizePosition["Yfit"]);  # 擬合 y 值;
# #     # # println("y - fit Uncertainty Lower : ", return_SizePosition["Yfit-Uncertainty-Lower"]);  # 擬合的應變量 Yvals 誤差下限;
# #     # # println("y - fit Uncertainty Upper : ", return_SizePosition["Yfit-Uncertainty-Upper"]);  # 擬合的應變量 Yvals 誤差上限;
# #     # # println("residual : ", return_SizePosition["Residual"]);  # 擬合殘差;
# #     # println("optimization - y_profit : ", return_SizePosition["y_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
# #     # println("Long Position optimization - y_profit : ", return_SizePosition["y_Long_Position_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
# #     # println("Short Selling optimization - y_profit : ", return_SizePosition["y_Short_Selling_profit"]);  # 每兩次對衝交易利潤 × 權重，加權纍加總計;
# #     # println("optimization - y_loss : ", return_SizePosition["y_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
# #     # println("Long Position optimization - y_loss : ", return_SizePosition["y_Long_Position_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
# #     # println("Short Selling optimization - y_loss : ", return_SizePosition["y_Short_Selling_loss"]);  # 每兩次對衝交易最大回撤 × 權重，加權取極值總計;
# #     # println("maximum_drawdown : ", return_SizePosition["maximum_drawdown"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# #     # println("maximum_drawdown_Long_Position : ", return_SizePosition["maximum_drawdown_Long_Position"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# #     # println("maximum_drawdown_Short_Selling : ", return_SizePosition["maximum_drawdown_Short_Selling"]);  # 兩次對衝交易之間的最大回撤值，取極值統計;
# #     # println("profit total per share : ", return_SizePosition["profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# #     # println("Long Position profit total per share : ", return_SizePosition["Long_Position_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# #     # println("Short Selling profit total per share : ", return_SizePosition["Short_Selling_profit_total"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# #     # println("profit Positive : ", return_SizePosition["profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# #     # println("Long Position profit Positive : ", return_SizePosition["Long_Position_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# #     # println("Short Selling_profit Positive : ", return_SizePosition["Short_Selling_profit_Positive"]);  # 每兩次對衝交易收益纍加總計;
# #     # println("profit Positive probability : ", return_SizePosition["profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# #     # println("Long Position profit Positive probability : ", return_SizePosition["Long_Position_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# #     # println("Short Selling profit Positive probability : ", return_SizePosition["Short_Selling_profit_Positive_probability"]);  # 每兩次對衝交易正利潤概率;
# #     # println("profit Negative : ", return_SizePosition["profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# #     # println("Long Position profit Negative : ", return_SizePosition["Long_Position_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# #     # println("Short Selling profit Negative : ", return_SizePosition["Short_Selling_profit_Negative"]);  # 每兩次對衝交易損失纍加總計;
# #     # println("profit Negative probability : ", return_SizePosition["profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# #     # println("Long Position profit Negative probability : ", return_SizePosition["Long_Position_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# #     # println("Short Selling profit Negative probability : ", return_SizePosition["Short_Selling_profit_Negative_probability"]);  # 每兩次對衝交易負利潤概率;
# #     # println("average price amplitude date transaction : ", return_SizePosition["average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# #     # println("Long Position average price amplitude date transaction : ", return_SizePosition["Long_Position_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# #     # println("Short Selling average price amplitude date transaction : ", return_SizePosition["Short_Selling_average_price_amplitude_date_transaction"]);  # 兩兩次對衝交易日成交價振幅平方和，均值;
# #     # println("average volume turnover date transaction : ", return_SizePosition["average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# #     # println("Long Position average volume turnover date transaction : ", return_SizePosition["Long_Position_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# #     # println("Short Selling average volume turnover date transaction : ", return_SizePosition["Short_Selling_average_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）均值;
# #     # println("average date transaction between : ", return_SizePosition["average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# #     # println("Long Position average date transaction between : ", return_SizePosition["Long_Position_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# #     # println("Short Selling average date transaction between : ", return_SizePosition["Short_Selling_average_date_transaction_between"]);  # 兩次對衝交易間隔日長，均值;
# #     # println("number SizePosition transaction : ", return_SizePosition["number_PickStock_transaction"]);  # 交易過股票的總隻數，函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]);  # 記錄按規則篩選股票按照擇時規則交易信息的序列字典（Dict）;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]);  # 記錄按規則篩選股票按照擇時規則交易信息的序列字典（Dict）;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_profit_date_transaction"]);  # 每兩次對衝交易利潤，向量;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_price_amplitude_date_transaction"]);  # 兩次對衝交易日成交價振幅平方和，向量;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_volume_turnover_date_transaction"]);  # 兩次對衝交易日成交量（換手率）向量;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction_between"]);  # 兩次對衝交易間隔日長，向量;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"]);  # 按規則執行交易的日期，向量;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][1]);  # 交易規則自動選取的交易日期;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][3]);  # 交易規則自動選取的成交價;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][4]);  # 交易規則自動選取的成交量;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][8]);  # 當日總成交量（turnover volume）;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][9]);  # 當日開盤（opening）成交價;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][10]);  # 當日收盤（closing）成交價;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][11]);  # 當日最低（low）成交價;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][12]);  # 當日最高（high）成交價;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][15]);  # 當日每股收益（price earnings）;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Long_Position_date_transaction"][16]);  # 當日每股净值（book value per share）;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"]);  # 按規則執行交易的日期，向量;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][1]);  # 交易規則自動選取的交易日期;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][2]);  # 交易規則自動選取的買入或賣出;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][3]);  # 交易規則自動選取的成交價;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][4]);  # 交易規則自動選取的成交量;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][5]);  # 交易規則自動選取的成交次數記錄;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][6]);  # 交易規則自動選取的交易日期的序列號，用於繪圖可視化;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][7]);  # 交易日（Dates.Date 類型）;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][8]);  # 當日總成交量（turnover volume）;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][9]);  # 當日開盤（opening）成交價;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][10]);  # 當日收盤（closing）成交價;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][11]);  # 當日最低（low）成交價;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][12]);  # 當日最高（high）成交價;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][13]);  # 當日總成交金額（turnover amount）;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][14]);  # 當日成交量（turnover volume）換手率（turnover rate）;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][15]);  # 當日每股收益（price earnings）;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["Short_Selling_date_transaction"][16]);  # 當日每股净值（book value per share）;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["revenue_and_expenditure_records_date_transaction"]);  # 每次交易的收支記錄序列，不區分做多（Long Position）或做空（Short Selling），向量;
# #     # println(return_SizePosition["SizePosition_transaction_sequence"]["ticker_symbol"]["P1_Array"]);  # 依照擇時規則計算得到參數 P1 值的序列存儲數組;
# #     # println("test profit estimate : ", return_SizePosition["test_profit"]);  # 每兩次對衝交易利潤 × 權重，纍加總計;
# #     # println("test odds ratio estimate : ", return_SizePosition["test_odds_ratio"]);
# #     # println("test date transaction between : ", return_SizePosition["test_date_transaction_between"]);
# #     # # println(return_SizePosition["testData"]);;  # 傳入測試數據集的計算結果;
# #     # println("test profit total per share : ", return_SizePosition["testData"]["profit_total"]);
# #     # println("test Long Position profit total per share : ", return_SizePosition["testData"]["Long_Position_profit_total"]);
# #     # println("test Short Selling profit total per share : ", return_SizePosition["testData"]["Short_Selling_profit_total"]);
# #     # println("test profit positive per share : ", return_SizePosition["testData"]["profit_Positive"]);
# #     # println("test Long Position profit positive per share : ", return_SizePosition["testData"]["Long_Position_profit_Positive"]);
# #     # println("test Short Selling profit positive per share : ", return_SizePosition["testData"]["Short_Selling_profit_Positive"]);
# #     # println("test profit positive probability : ", return_SizePosition["testData"]["profit_Positive_probability"]);
# #     # println("test Long Position profit positive probability : ", return_SizePosition["testData"]["Long_Position_profit_Positive_probability"]);
# #     # println("test Short Selling profit positive probability : ", return_SizePosition["testData"]["Short_Selling_profit_Positive_probability"]);
# #     # println("test profit negative per share : ", return_SizePosition["testData"]["profit_Negative"]);
# #     # println("test Long Position profit negative per share : ", return_SizePosition["testData"]["Long_Position_profit_Negative"]);
# #     # println("test Short Selling profit negative per share : ", return_SizePosition["testData"]["Short_Selling_profit_Negative"]);
# #     # println("test profit negative probability : ", return_SizePosition["testData"]["profit_Negative_probability"]);
# #     # println("test Long Position profit negative probability : ", return_SizePosition["testData"]["Long_Position_profit_Negative_probability"]);
# #     # println("test Short Selling profit negative probability : ", return_SizePosition["testData"]["Short_Selling_profit_Negative_probability"]);
# #     # println("test average date transaction between : ", return_SizePosition["testData"]["average_date_transaction_between"]);
# #     # println("test Long Position average date transaction between : ", return_SizePosition["testData"]["Long_Position_average_date_transaction_between"]);
# #     # println("test Short Selling average date transaction between : ", return_SizePosition["testData"]["Short_Selling_average_date_transaction_between"]);
# #     # println("test number SizePosition transaction : ", return_SizePosition["testData"]["number_PickStock_transaction"]);  # 交易過股票的總隻數;
# #     # # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]["P1_Array"]);
# #     # # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]["Long_Position_date_transaction"]);
# #     # # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]["Short_Selling_date_transaction"]);
# #     # # println(return_SizePosition["testData"]["SizePosition_transaction_sequence"]["002611"]);
# #     # weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
# #     # weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
# #     if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 1 && Base.isa(return_SizePosition["Coefficient"][1], Base.Dict)
# #         for (key, value) in return_SizePosition["Coefficient"][1]
# #             # println("Key: $key, Value: $value");
# #             if Base.isa(value, Base.Dict) && Base.haskey(value, "Long_Position")
# #                 if Base.isa(weight_MarketTiming_Dict, Base.Dict) && Base.haskey(weight_MarketTiming_Dict, Base.string(key))
# #                     if Base.isa(weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
# #                         weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
# #                     end
# #                 elseif Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
# #                     weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
# #                     weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
# #                 else
# #                 end
# #             end
# #         end
# #     end
# #     if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 2 && Base.isa(return_SizePosition["Coefficient"][2], Base.Dict)
# #         for (key, value) in return_SizePosition["Coefficient"][2]
# #             # println("Key: $key, Value: $value");
# #             if Base.isa(value, Base.Dict) && Base.haskey(value, "Long_Position")
# #                 if Base.isa(weight_PickStock_Dict, Base.Dict) && Base.haskey(weight_PickStock_Dict, Base.string(key))
# #                     if Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict)
# #                         weight_PickStock_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
# #                     end
# #                 elseif Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
# #                     weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
# #                     weight_PickStock_Dict[Base.string(key)]["Long_Position"] = value["Long_Position"];
# #                 else
# #                 end
# #             end
# #         end
# #     end
# #     return_SizePosition = Core.nothing;  # 釋放内存;

# #     # investment_method = "Short_Selling"
# #     return_SizePosition = SizePosition(
# #         training_data = stepping_data,  # ::Core.Array{Core.Float64, 2} = testing_data,  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
# #         testing_data = stepping_data,  # ::Core.Array{Core.Float64, 2};  # ::Core.Array{Core.Array{Core.Float64, 1}, 1};
# #         Pdata_0 = [weight_MarketTiming_Dict, weight_PickStock_Dict],  # training_data["002611"]["Pdata_0"],
# #         weight = Core.Array{Core.Float64, 1}(),  # training_data["002611"]["weight"],
# #         Plower = [Plower_weight_MarketTiming_Dict, Plower_weight_PickStock_Dict],
# #         Pupper = [Pupper_weight_MarketTiming_Dict, Pupper_weight_PickStock_Dict],
# #         MarketTiming_Parameter = MarketTiming_Parameter,  # 按照擇時規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
# #         PickStock_Parameter = PickStock_Parameter,  # 按照選股規則優化之後的參數字典;  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),
# #         PickStock_ticker_symbol = PickStock_ticker_symbol,  # Core.Array{Core.Any, 1}(),  # ::Core.Array{Core.Array{Core.String, 1}, 1} = Core.Array{Core.Array{Core.String, 1}, 1}(),  # 依照選股規則排序篩選出的股票代碼字符串存儲數組;
# #         SizePosition_fit_model = SizePosition_fit_model,
# #         PickStock = PickStock,
# #         PickStock_fit_model = PickStock_fit_model,
# #         MarketTiming = MarketTiming,
# #         MarketTiming_fit_model = MarketTiming_fit_model,
# #         Quantitative_Indicators_Function = Intuitive_Momentum_KLine,
# #         investment_method = "Short_Selling"  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
# #     );
# #     # weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
# #     # weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
# #     if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 1 && Base.isa(return_SizePosition["Coefficient"][1], Base.Dict)
# #         for (key, value) in return_SizePosition["Coefficient"][1]
# #             # println("Key: $key, Value: $value");
# #             if Base.isa(value, Base.Dict) && Base.haskey(value, "Short_Selling")
# #                 if Base.isa(weight_MarketTiming_Dict, Base.Dict) && Base.haskey(weight_MarketTiming_Dict, Base.string(key))
# #                     if Base.isa(weight_MarketTiming_Dict[Base.string(key)], Base.Dict)
# #                         weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
# #                     end
# #                 elseif Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
# #                     weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
# #                     weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
# #                 else
# #                 end
# #             end
# #         end
# #     end
# #     if Base.typeof(return_SizePosition["Coefficient"]) <: Core.Array && Base.length(return_SizePosition["Coefficient"]) >= 2 && Base.isa(return_SizePosition["Coefficient"][2], Base.Dict)
# #         for (key, value) in return_SizePosition["Coefficient"][2]
# #             # println("Key: $key, Value: $value");
# #             if Base.isa(value, Base.Dict) && Base.haskey(value, "Short_Selling")
# #                 if Base.isa(weight_PickStock_Dict, Base.Dict) && Base.haskey(weight_PickStock_Dict, Base.string(key))
# #                     if Base.isa(weight_PickStock_Dict[Base.string(key)], Base.Dict)
# #                         weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
# #                     end
# #                 elseif Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
# #                     weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
# #                     weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = value["Short_Selling"];
# #                 else
# #                 end
# #             end
# #         end
# #     end
# #     return_SizePosition = Core.nothing;  # 釋放内存;
# # end
# # SizePosition_Parameter_Array = [weight_MarketTiming_Dict, weight_PickStock_Dict];
# # # println(SizePosition_Parameter_Array);
# # # println("optimization - coefficient 1 - weight_MarketTiming :", "\n", SizePosition_Parameter_Array[1]);  # 最優化計算之後得到的參數;
# # # println("optimization - coefficient 2 - weight_PickStock :", "\n", SizePosition_Parameter_Array[2]);  # 最優化計算之後得到的參數;

# # 求解各股票裏的最長交易天數;
# # 交易過股票的總隻數，函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
# maximum_ticker_symbol_stepping_data = Core.Int64(0);  # Core.Int64(Base.length([key for key in Base.keys(stepping_data)]));  # 交易過股票的總隻數;
# maximum_stepping_data = Core.Int64(0);  # 各股票裏的最長交易天數;
# minimum_stepping_data = Core.Int64(0);  # 各股票裏的最短交易天數;
# if Base.isa(stepping_data, Base.Dict) && Core.Int64(Base.length(stepping_data)) > Core.Int64(0)

#     # 交易過股票的總隻數，函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
#     global maximum_ticker_symbol_stepping_data = Core.Int64(Base.length([key for key in Base.keys(stepping_data)]));  # 交易過股票的總隻數;
#     # println(maximum_ticker_symbol_stepping_data);
#     global maximum_stepping_data = Core.Int64(0);  # 各股票裏的最長交易天數;
#     global minimum_stepping_data = Core.Int64(0);  # 各股票裏的最短交易天數;
#     stepping_data_Array = Core.Array{Core.Int64, 1}();
#     # 遍歷字典的鍵:值對;
#     for (key, value) in stepping_data
#         # println("Key: $key, Value: $value");
#         if Base.isa(value, Base.Dict)
#             if Base.haskey(value, "date_transaction") && Base.typeof(value["date_transaction"]) <: Core.Array
#                 # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
#                 Base.push!(stepping_data_Array, Core.Int64(Base.length(value["date_transaction"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

#                 # 篩選最長交易天數;
#                 if Core.Int64(Base.length(value["date_transaction"])) > Core.Int64(maximum_stepping_data)
#                     maximum_stepping_data_2 = Core.Int64(Base.length(value["date_transaction"]));
#                     global maximum_stepping_data *= Core.Int64(0);
#                     global maximum_stepping_data += Core.Int64(maximum_stepping_data_2);
#                 end
#             end
#             if Base.haskey(value, "turnover_volume") && Base.typeof(value["turnover_volume"]) <: Core.Array
#                 # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
#                 Base.push!(stepping_data_Array, Core.Int64(Base.length(value["turnover_volume"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

#                 # 篩選最長交易天數;
#                 if Core.Int64(Base.length(value["turnover_volume"])) > Core.Int64(maximum_stepping_data)
#                     maximum_stepping_data_2 = Core.Int64(Base.length(value["turnover_volume"]));
#                     global maximum_stepping_data *= Core.Int64(0);
#                     global maximum_stepping_data += Core.Int64(maximum_stepping_data_2);
#                 end
#             end
#             if Base.haskey(value, "opening_price") && Base.typeof(value["opening_price"]) <: Core.Array
#                 # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
#                 Base.push!(stepping_data_Array, Core.Int64(Base.length(value["opening_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

#                 # 篩選最長交易天數;
#                 if Core.Int64(Base.length(value["opening_price"])) > Core.Int64(maximum_stepping_data)
#                     maximum_stepping_data_2 = Core.Int64(Base.length(value["opening_price"]));
#                     global maximum_stepping_data *= Core.Int64(0);
#                     global maximum_stepping_data += Core.Int64(maximum_stepping_data_2);
#                 end
#             end
#             if Base.haskey(value, "close_price") && Base.typeof(value["close_price"]) <: Core.Array
#                 # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
#                 Base.push!(stepping_data_Array, Core.Int64(Base.length(value["close_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

#                 # 篩選最長交易天數;
#                 if Core.Int64(Base.length(value["close_price"])) > Core.Int64(maximum_stepping_data)
#                     maximum_stepping_data_2 = Core.Int64(Base.length(value["close_price"]));
#                     global maximum_stepping_data *= Core.Int64(0);
#                     global maximum_stepping_data += Core.Int64(maximum_stepping_data_2);
#                 end
#             end
#             if Base.haskey(value, "low_price") && Base.typeof(value["low_price"]) <: Core.Array
#                 # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
#                 Base.push!(stepping_data_Array, Core.Int64(Base.length(value["low_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

#                 # 篩選最長交易天數;
#                 if Core.Int64(Base.length(value["low_price"])) > Core.Int64(maximum_stepping_data)
#                     maximum_stepping_data_2 = Core.Int64(Base.length(value["low_price"]));
#                     global maximum_stepping_data *= Core.Int64(0);
#                     global maximum_stepping_data += Core.Int64(maximum_stepping_data_2);
#                 end
#             end
#             if Base.haskey(value, "high_price") && Base.typeof(value["high_price"]) <: Core.Array
#                 # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;
#                 Base.push!(stepping_data_Array, Core.Int64(Base.length(value["high_price"])));  # 記錄交易天數，使用 push! 函數在數組末尾追加推入新元;

#                 # 篩選最長交易天數;
#                 if Core.Int64(Base.length(value["high_price"])) > Core.Int64(maximum_stepping_data)
#                     maximum_stepping_data_2 = Core.Int64(Base.length(value["high_price"]));
#                     global maximum_stepping_data *= Core.Int64(0);
#                     global maximum_stepping_data += Core.Int64(maximum_stepping_data_2);
#                 end
#             end
#         end
#     end
#     # println(maximum_stepping_data);
#     if Base.length(stepping_data_Array) > 0
#         minimum_stepping_data_2 = Core.Int64(Base.findmin(stepping_data_Array)[1]);
#         global minimum_stepping_data *= Core.Int64(0);
#         global minimum_stepping_data += Core.Int64(minimum_stepping_data_2);
#     end
#     # println(minimum_stepping_data);
#     stepping_data_Array = Core.nothing;
# end

# MarketTiming_Parameter = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則優化之後得到的擇時規則的輸入參數存儲字典;
# weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();  # 依照擇時規則交易倉位參數的存儲字典;
# Plower_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();
# Pupper_weight_MarketTiming_Dict = Base.Dict{Core.String, Core.Any}();
# if Base.isa(stepping_data, Base.Dict) && Base.length(stepping_data) > 0
#     for (key, value) in stepping_data
#         if Base.isa(MarketTiming_Parameter, Base.Dict) && (!Base.haskey(MarketTiming_Parameter, Base.string(key)))
#             MarketTiming_Parameter[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
#         end
#         if Base.isa(weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(weight_MarketTiming_Dict, Base.string(key)))
#             weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
#         end
#         if Base.isa(Plower_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Plower_weight_MarketTiming_Dict, Base.string(key)))
#             Plower_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
#         end
#         if Base.isa(Pupper_weight_MarketTiming_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_MarketTiming_Dict, Base.string(key)))
#             Pupper_weight_MarketTiming_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
#         end
#         MarketTiming_Parameter[Base.string(key)]["Long_Position"] = [5, 0.1, -0.1, 0.0];
#         MarketTiming_Parameter[Base.string(key)]["Short_Selling"] = [5, 0.1, -0.1, 0.0];
#         weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = 1.0;
#         weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = 1.0;
#         Plower_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
#         Plower_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
#         Pupper_weight_MarketTiming_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
#         Pupper_weight_MarketTiming_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
#     end
# end
# MarketTiming_Parameter_Dict = MarketTiming_Parameter;

# PickStock_Parameter = Base.Dict{Core.String, Core.Any}();  # 依照選股規則優化之後得到的選股規則的輸入參數存儲字典;
# PickStock_Parameter["Long_Position"] = [5, 3];
# PickStock_Parameter["Short_Selling"] = [5, 3];
# PickStock_ticker_symbol = [Base.string(item) for item in Base.keys(stepping_data)];  # Core.Array{Core.Any, 1}();  # Core.Array{Core.Array{Core.String, 1}, 1}();
# PickStock_ticker_symbol = [PickStock_ticker_symbol for i = Core.Int64(1):Core.Int64(maximum_stepping_data)];
# weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();  # 依照選股規則配置占比倉位參數的存儲字典;
# Plower_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
# Pupper_weight_PickStock_Dict = Base.Dict{Core.String, Core.Any}();
# if Base.isa(stepping_data, Base.Dict) && Base.length(stepping_data) > 0
#     for (key, value) in stepping_data
#         if Base.isa(weight_PickStock_Dict, Base.Dict) && (!Base.haskey(weight_PickStock_Dict, Base.string(key)))
#             weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
#         end
#         if Base.isa(Plower_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Plower_weight_PickStock_Dict, Base.string(key)))
#             Plower_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
#         end
#         if Base.isa(Pupper_weight_PickStock_Dict, Base.Dict) && (!Base.haskey(Pupper_weight_PickStock_Dict, Base.string(key)))
#             Pupper_weight_PickStock_Dict[Base.string(key)] = Base.Dict{Core.String, Core.Any}();
#         end
#         weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(Core.Int64(1) / Core.Int64(Base.length(Base.keys(stepping_data))));
#         Plower_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(0.0);
#         Pupper_weight_PickStock_Dict[Base.string(key)]["Long_Position"] = Core.Float64(1.0);
#         weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(Core.Int64(1) / Core.Int64(Base.length(Base.keys(stepping_data))));
#         Plower_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(0.0);
#         Pupper_weight_PickStock_Dict[Base.string(key)]["Short_Selling"] = Core.Float64(1.0);
#     end
# end
# PickStock_Parameter_Dict = PickStock_Parameter;
# PickStock_ticker_symbol_Array = PickStock_ticker_symbol;

# SizePosition_Parameter_Array = [weight_MarketTiming_Dict, weight_PickStock_Dict];

# # 推進分析訓練集數據序列截取;
# investment_method = "Long_Position_and_Short_Selling";  # "Long_Position_and_Short_Selling", "Long_Position", "Short_Selling";
# # risk_threshold_drawdown_loss = Core.Float64(0.0);  # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
# training_data_sequence_length = Core.Int64(60);
# training_data_ticker_symbol_Array = [Base.string(item) for item in Base.keys(stepping_data)];  # 函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
# testing_data_ticker_symbol_Array = [Base.string(item) for item in Base.keys(stepping_data)];  # 函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
# testing_data_sequence_length = Core.Int64(1);

# return_stepping_Dict = BackTesting_Stepper(
#     steppingData = stepping_data,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # ::Core.Array{Core.Float64, 2} = Core.Array{Core.Float64, 2}(undef, (0, 0)), # ::Core.Array{Core.Array{Core.Float64, 1}, 1} = Core.Array{Core.Array{Core.Float64, 1}, 1}(),
#     # risk_threshold = risk_threshold_drawdown_loss,  # ::Core.Float64 = Core.Float64(0.0),  # 風險控制閾值，强制平倉，可接受的最大回撤比例：Long_Position = sell_price ÷ buy_price、Short_Selling = 1 + ((sell_price - buy_price) ÷ sell_price) ;
#     training_sequence_length = training_data_sequence_length,  # ::Core.Int64 = Core.Int64(60),
#     training_ticker_symbol = training_data_ticker_symbol_Array,  # ::Core.Array{Core.String, 1} = [Base.string(item) for item in Base.keys(stepping_data)],  # 函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
#     testing_ticker_symbol = testing_data_ticker_symbol_Array,  # ::Core.Array{Core.String, 1} = [Base.string(item) for item in Base.keys(stepping_data)],  # 函數 Base.keys(Dict) 表示獲取字典的所有 key 值，返回值爲字符串向量（Base.Vector）;
#     testing_sequence_length = testing_data_sequence_length,  # ::Core.Int64 = Core.Int64(1),
#     SizePosition = SizePosition,  # = (arguments) -> begin return arguments; end,
#     SizePosition_fit_model = SizePosition_fit_model,  # = (arguments) -> begin return arguments; end,
#     SizePosition_Pdata_0 = SizePosition_Parameter_Array,  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64())), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],
#     SizePosition_weight = Core.Array{Core.Any, 1}(),  # [Core.Float64(1.0) for i in 1:Base.length(training_data)],
#     SizePosition_Plower = [Plower_weight_MarketTiming_Dict, Plower_weight_PickStock_Dict],  # [-Base.Inf, -Base.Inf],  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(0.0), "Short_Selling" => ::Core.Float64 = Core.Float64(0.0))), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],
#     SizePosition_Pupper = [Pupper_weight_MarketTiming_Dict, Pupper_weight_PickStock_Dict],  # [+Base.Inf, +Base.Inf],  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(1.0), "Short_Selling" => ::Core.Float64 = Core.Float64(1.0))), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],
#     PickStock = PickStock,  # = (arguments) -> begin return arguments; end,
#     PickStock_fit_model = PickStock_fit_model,  # = (arguments) -> begin return arguments; end,
#     PickStock_Pdata_0 = [5, 3],  # PickStock_Parameter,  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64())), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],
#     PickStock_weight = Core.Array{Core.Any, 1}(),  # [Core.Float64(1.0) for i in 1:Base.length(training_data)],
#     PickStock_Plower = [Core.Int64(1), Core.Int64(1)],  # [-Base.Inf, -Base.Inf],  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(0.0), "Short_Selling" => ::Core.Float64 = Core.Float64(0.0))), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],
#     PickStock_Pupper = [Core.Int64([if (Core.Int64(maximum_stepping_data) > Core.Int64(0)) Core.Int64(maximum_stepping_data) else Core.Int64(1) end for i in Core.Int64(1):Core.Int64(1)][Core.Int64(1)]), Core.Int64([if (Core.Int64(maximum_ticker_symbol_stepping_data) > Core.Int64(0)) Core.Int64(maximum_ticker_symbol_stepping_data) else Core.Int64(1) end for i in Core.Int64(1):Core.Int64(1)][Core.Int64(1)])],  # [+Base.Inf, +Base.Inf],  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(1.0), "Short_Selling" => ::Core.Float64 = Core.Float64(1.0))), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],
#     MarketTiming = MarketTiming,  # = (arguments) -> begin return arguments; end,
#     MarketTiming_fit_model = MarketTiming_fit_model,  # = (arguments) -> begin return arguments; end,
#     MarketTiming_Pdata_0 = [5, 0.1, -0.1, 0.0],  # MarketTiming_Parameter,# ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64())), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],
#     MarketTiming_weight = Core.Array{Core.Any, 1}(),  # [Core.Float64(1.0) for i in 1:Base.length(training_data)],
#     MarketTiming_Plower = [Core.Int64(1), -Base.Inf, -Base.Inf, -Base.Inf],  # [-Base.Inf, -Base.Inf, -Base.Inf, -Base.Inf],  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(0.0), "Short_Selling" => ::Core.Float64 = Core.Float64(0.0))), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],
#     MarketTiming_Pupper = [Core.Int64([if (Core.Int64(maximum_stepping_data) > Core.Int64(0)) Core.Int64(maximum_stepping_data) else Core.Int64(1) end for i in Core.Int64(1):Core.Int64(1)][Core.Int64(1)]), +Base.Inf, +Base.Inf, +Base.Inf],  # [+Base.Inf, +Base.Inf, +Base.Inf, +Base.Inf],  # ::Core.Array{Core.Any, 1}[::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(1.0), "Short_Selling" => ::Core.Float64 = Core.Float64(1.0))), ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("ticker_symbol" => Base.Dict{Core.String, Core.Any}("Long_Position" => ::Core.Float64 = Core.Float64(), "Short_Selling" => ::Core.Float64 = Core.Float64()))],
#     Quantitative_Indicators_Function = Intuitive_Momentum_KLine,  # = (arguments) -> begin return arguments; end,
#     investment_method = investment_method  # "Long_Position_and_Short_Selling" , "Long_Position" , "Short_Selling" ;
# );
# println("number PickStock : ", return_stepping_Dict["number_PickStock"]);
# println("number PickStock Long Position : ", return_stepping_Dict["number_PickStock_Long_Position"]);
# println("number PickStock Short Selling : ", return_stepping_Dict["number_PickStock_Short_Selling"]);
# println("number transaction : ", return_stepping_Dict["number_transaction_total"]);
# println("number transaction Long Position : ", return_stepping_Dict["number_transaction_total_Long_Position"]);
# println("number transaction Short Selling : ", return_stepping_Dict["number_transaction_total_Short_Selling"]);
# println("maximum drawdown : ", return_stepping_Dict["maximum_drawdown"]);
# println("maximum drawdown Long Position : ", return_stepping_Dict["maximum_drawdown_Long_Position"]);
# println("maximum drawdown Short Selling : ", return_stepping_Dict["maximum_drawdown_Short_Selling"]);
# println("profit total : ", return_stepping_Dict["profit_total"]);
# println("Long Position profit total : ", return_stepping_Dict["Long_Position_profit_total"]);
# println("Short Selling profit total : ", return_stepping_Dict["Short_Selling_profit_total"]);
# println("profit Positive : ", return_stepping_Dict["profit_Positive"]);
# println("profit Negative : ", return_stepping_Dict["profit_Negative"]);
# println("Long Position profit Positive : ", return_stepping_Dict["Long_Position_profit_Positive"]);
# println("Long Position profit Negative : ", return_stepping_Dict["Long_Position_profit_Negative"]);
# println("Short Selling profit Positive : ", return_stepping_Dict["Short_Selling_profit_Positive"]);
# println("Short Selling profit Negative : ", return_stepping_Dict["Short_Selling_profit_Negative"]);
# println("profit Positive probability : ", return_stepping_Dict["profit_Positive_probability"]);
# println("profit Negative probability : ", return_stepping_Dict["profit_Negative_probability"]);
# println("Long Position profit Positive probability : ", return_stepping_Dict["Long_Position_profit_Positive_probability"]);
# println("Long Position profit Negative probability : ", return_stepping_Dict["Long_Position_profit_Negative_probability"]);
# println("Short Selling profit Positive probability : ", return_stepping_Dict["Short_Selling_profit_Positive_probability"]);
# println("Short Selling profit Negative probability : ", return_stepping_Dict["Short_Selling_profit_Negative_probability"]);
# println("average price amplitude date transaction : ", return_stepping_Dict["average_price_amplitude_date_transaction"]);
# println("Long Position average price amplitude date transaction : ", return_stepping_Dict["Long_Position_average_price_amplitude_date_transaction"]);
# println("Short Selling average price amplitude date transaction : ", return_stepping_Dict["Short_Selling_average_price_amplitude_date_transaction"]);
# println("average volume turnover date transaction : ", return_stepping_Dict["average_volume_turnover_date_transaction"]);
# println("Long Position average volume turnover date transaction : ", return_stepping_Dict["Long_Position_average_volume_turnover_date_transaction"]);
# println("Short Selling average volume turnover date transaction : ", return_stepping_Dict["Short_Selling_average_volume_turnover_date_transaction"]);
# println("average date transaction between : ", return_stepping_Dict["average_date_transaction_between"]);
# println("Long Position average date transaction between : ", return_stepping_Dict["Long_Position_average_date_transaction_between"]);
# println("Short Selling average date transaction between : ", return_stepping_Dict["Short_Selling_average_date_transaction_between"]);
# # println("PickStock Long Position Array :", "\n", return_stepping_Dict["PickStock_Long_Position"]);
# # println("PickStock Short Selling Array :", "\n", return_stepping_Dict["PickStock_Short_Selling"]);
# # println("PickStock Array :", "\n", return_stepping_Dict["PickStock"]);
# # println("profit paired transaction Dict :", "\n", return_stepping_Dict["profit_paired_transaction"]);
# # println("transaction sequence Dict :", "\n", return_stepping_Dict["transaction_sequence"]);
# # println("stepping sequence Array :", "\n", return_stepping_Dict["stepping_sequence"]);
